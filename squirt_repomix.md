This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-30T17:36:01.777Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------
User Provided Header:
-----------------------
Squirt repo

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
public/
  index.html
  main.324fa52b.css
  manifest.json
  service-worker.js
src/
  css/
    form-styles.css
    layout-fixes.css
    mobile-fixes.css
    styles.css
    yasgui-styles.css
  html/
    index.html
  js/
    core/
      errors.js
      state.js
      views.js
    services/
      rdf/
        rdf-extractor.js
        rdf-model.js
      sparql/
        endpoints.js
        sparql.js
      templates/
        post-article.njk
    ui/
      components/
        endpoint-indicator.js
        endpoints-list.js
        forms.js
        notifications.js
      views/
        settings.js
        wiki-editor.js
        yasgui-view.js
    utils/
      utils.js
    app.js
    router.js
  config.json
test/
  spec/
    about.md
    sparql.spec.js
    sparql1.spec.js
  setup.js
.babelrc
.gitignore
about.md
babel.config.json
jasmine.json
jest.config.js
package.json
tree.xml
webpack.config.js

================================================================
Files
================================================================

================
File: public/index.html
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Post information to the web easily with Squirt">
    <meta name="theme-color" content="#3498db">
    <title>Squirt</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <!-- PWA manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- iOS PWA support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Squirt">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon.png">
<link rel="icon" href="favicon.ico"><script defer src="main.bundle.js"></script><link href="main.324fa52b.css" rel="stylesheet"></head>

<body>
    <header>
        <h1>Squirt</h1>
        <nav>
            <a href="#" data-view="post-view">Post</a>
            <a href="#" data-view="wiki-view">Wiki</a>
            <a href="#" data-view="yasgui-view">SPARQL</a>
            <a href="#" data-view="developer-view">Developer</a>
            <a href="#" data-view="profile-view">Profile</a>
            <a href="#" data-view="settings-view">Settings</a>
        </nav>
    </header>
    

    <main>
        <!-- Post View -->
        <div id="post-view" class="view">
            <h2>Create Post</h2>
            <form id="post-form" class="form-group">
                <div class="form-field">
                    <label for="post-type">Post Type</label>
                    <select id="post-type" name="post-type" required>
                        <option value="entry">Entry</option>
                        <option value="link" selected>Link</option>
                    </select>
                </div>
                
                <!-- Static form fields for Link type -->
                <div class="form-fields">
                    <div class="form-field">
                        <label for="url">URL</label>
                        <div style="display: flex; align-items: center;">
                            <input type="url" id="url" name="url" placeholder="https://example.com" required style="flex: 1;">
                            <button type="button" id="extract-metadata" class="extract-button" style="margin-left: 8px;">Extract</button>
                        </div>
                    </div>
                    
                    <div class="form-field">
                        <label for="title">Title</label>
                        <input type="text" id="title" name="title" placeholder="Enter a title">
                    </div>
                    
                    <div class="form-field">
                        <label for="content">Content</label>
                        <textarea id="content" name="content" rows="5" placeholder="Enter your content here..."></textarea>
                    </div>
                    
                    <div class="form-field">
                        <label for="tags">Tags (comma separated)</label>
                        <input type="text" id="tags" name="tags" placeholder="tag1, tag2, tag3">
                    </div>
                </div>
                
                <button type="submit" class="button-primary">Post</button>
            </form>
            
            <div id="post-preview" style="margin-top: 20px;"></div>
        </div>

        <!-- Wiki View -->
        <div id="wiki-view" class="view hidden">
            <h2>Wiki</h2>
            <div class="wiki-editor">
                <div class="form-field">
                    <label for="wiki-title">Title</label>
                    <input type="text" id="wiki-title" name="title" required>
                </div>
                <div class="form-field">
                    <label for="wiki-content">Content (Markdown supported)</label>
                    <textarea id="wiki-content" name="content" rows="10" required></textarea>
                </div>
                <div class="form-field">
                    <label for="wiki-tags">Tags (comma separated)</label>
                    <input type="text" id="wiki-tags" name="tags" placeholder="tag1, tag2, tag3">
                </div>
                <button type="button" id="save-wiki">Save</button>
            </div>
            <div class="wiki-entries"></div>
        </div>

        <div id="yasgui-view" class="view hidden">
            <h2>SPARQL Query Editor</h2>
            <div id="yasgui-container" class="yasgui-container"></div>
        </div>
        
        <!-- Developer View -->
        <div id="developer-view" class="view hidden">
            <h2>Developer Tools</h2>
            <div class="developer-section">
                <h3>SPARQL Query</h3>
                <div class="form-field">
                    <textarea id="sparql-query" rows="10" placeholder="Enter SPARQL query..."></textarea>
                </div>
                <button type="button" id="run-query">Run Query</button>
                <div id="query-results" class="results-container"></div>
            </div>
        </div>

        <!-- Profile View -->
        <div id="profile-view" class="view hidden">
            <h2>Profile</h2>
            <form id="profile-form" class="form-group">
                <div class="form-field">
                    <label for="profile-name">Name</label>
                    <input type="text" id="profile-name" name="name">
                </div>
                <div class="form-field">
                    <label for="profile-email">Email</label>
                    <input type="email" id="profile-email" name="email">
                </div>
                <div class="form-field">
                    <label for="profile-bio">Bio</label>
                    <textarea id="profile-bio" name="bio"></textarea>
                </div>
                <button type="submit">Save Profile</button>
            </form>
        </div>

        <!-- Settings View -->
        <div id="settings-view" class="view hidden">
            <h2>Settings</h2>
            
            <!-- Appearance Section -->
            <div class="settings-section">
                <h3>Appearance</h3>
                <div class="form-field">
                    <label for="theme-selector">Theme</label>
                    <select id="theme-selector">
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                        <option value="system">System Preference</option>
                    </select>
                </div>
            </div>
            
            <!-- Endpoints Section -->
            <div class="settings-section">
                <h3>SPARQL Endpoints</h3>
                <div id="endpoints-list"></div>
                <form id="endpoint-form" class="form-group">
                    <input type="text" id="endpoint-label" placeholder="Endpoint Label" required>
                    <input type="url" id="endpoint-url" placeholder="Enter SPARQL endpoint URL" required>
                    <button type="submit">Add Endpoint</button>
                </form>
            </div>
            
            <!-- Storage Section -->
            <div class="settings-section storage-section">
                <h3>Storage</h3>
                <div id="storage-usage">Calculating storage usage...</div>
            </div>
        </div>
    </main>
</body>

</html>

================
File: public/main.324fa52b.css
================
:root {
  --primary-color: #3498db;
  --error-color: #e74c3c;
  --success-color: #2ecc71;
  --background-color: #f9f9f9;
  --text-color: #2c3e50;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  line-height: 1.6;
  margin: 0;
  padding: 0;
  background: var(--background-color);
  color: var(--text-color);
}

header {
  background: white;
  padding: 1rem;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

nav {
  display: flex;
  gap: 1rem;
}

nav a {
  color: var(--text-color);
  text-decoration: none;
  padding: 0.5rem 1rem;
  border-radius: 4px;
}

nav a:hover {
  background: var(--background-color);
}

main {
  max-width: 800px;
  margin: 2rem auto;
  padding: 0 1rem;
}

.hidden {
  display: none;
}

/* Settings Styles */
.settings-section {
  background: white;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  margin-bottom: 2rem;
}

.settings-section h3 {
  margin-top: 0;
  margin-bottom: 1rem;
  color: var(--text-color);
}

.endpoint-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  border-bottom: 1px solid #eee;
}

.endpoint-header {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.endpoint-url {
  font-size: 0.875rem;
  color: #666;
  margin-top: 0.25rem;
}

.endpoint-status {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #999;
  transition: background-color 0.3s ease;
}

.endpoint-status.checking {
  animation: pulse 1.5s infinite;
  background: var(--primary-color);
}

.endpoint-status.active {
  background: var(--success-color);
}

.endpoint-status.inactive {
  background: var(--error-color);
}

.endpoint-label[contenteditable] {
  padding: 0.25rem;
  border-radius: 4px;
}

.endpoint-label[contenteditable]:focus {
  outline: 2px solid var(--primary-color);
  background: white;
}

.endpoint-actions {
  display: flex;
  gap: 0.5rem;
}

#endpoint-form {
  display: grid;
  grid-template-columns: 1fr 2fr auto;
  gap: 0.5rem;
  margin-top: 1rem;
}

@keyframes pulse {
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
}

/* YASGUI specific styles */
.yasgui-container {
  width: 100%;
  height: 600px;
  margin-top: 1rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  overflow: hidden;
}

/* Override YASGUI styles to match application theme */
.yasgui .yasqe .CodeMirror {
  font-family: monospace;
  font-size: 14px;
}

.yasgui .tabPanel {
  background-color: var(--background-color, #f9f9f9);
}

.yasgui .tabItem.active {
  background-color: var(--primary-color, #3498db);
  color: white;
}

.yasgui button.btn-primary {
  background-color: var(--primary-color, #3498db);
  border-color: var(--primary-color, #3498db);
}

.yasgui button.btn-primary:hover {
  background-color: #2980b9;
  border-color: #2980b9;
}
/* Form Styles */
.form-field {
  margin-bottom: 1rem;
}

.form-field label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
}

.form-field input,
.form-field textarea,
.form-field select {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
  font-size: 1rem;
  font-family: inherit;
}

.form-field textarea {
  min-height: 100px;
  resize: vertical;
}

.form-field input:focus,
.form-field textarea:focus,
.form-field select:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
}

button[type="submit"],
.button-primary {
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  padding: 0.75rem 1rem;
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s;
}

button[type="submit"]:hover,
.button-primary:hover {
  background-color: #2980b9;
}

/* Post form specific styles */
#post-form {
  background: white;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.form-fields {
  margin-top: 1rem;
}

/* Extract button */
.extract-button {
  margin-left: 8px;
  padding: 0.5rem 1rem;
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.875rem;
}

.extract-button:hover {
  background-color: #2980b9;
}

.extract-button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

/* Link preview */
.link-preview {
  margin-top: 1rem;
  border: 1px solid #ddd;
  border-radius: 8px;
  overflow: hidden;
}

.preview-card {
  display: flex;
  flex-direction: column;
  max-width: 100%;
}

.preview-image {
  width: 100%;
  max-height: 200px;
  overflow: hidden;
}

.preview-image img {
  width: 100%;
  height: auto;
  object-fit: cover;
}

.preview-content {
  padding: 1rem;
}

.preview-title {
  margin: 0 0 0.5rem 0;
  font-size: 1.25rem;
  color: var(--text-color);
}

.preview-description {
  margin: 0 0 0.5rem 0;
  font-size: 0.875rem;
  color: #666;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.preview-site {
  font-size: 0.75rem;
  color: #999;
}

@media (min-width: 768px) {
  .preview-card {
    flex-direction: row;
  }
  
  .preview-image {
    width: 200px;
    max-height: none;
  }
  
  .preview-content {
    flex: 1;
  }
}

/* YASGUI specific styles */
.yasgui-container {
  width: 100%;
  min-height: 600px;
  margin-top: 1rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  overflow: hidden;
}

/* Ensure YASGUI fits properly in the container */
.yasgui {
  width: 100%;
  height: 100%;
}

/* Override YASGUI styles to match application theme */
.yasgui .yasqe .CodeMirror {
  font-family: monospace;
  font-size: 14px;
  height: auto;
}

.yasgui .tabPanel {
  background-color: var(--background-color, #f9f9f9);
}

.yasgui .tabItem.active {
  background-color: var(--primary-color, #3498db);
  color: white;
}

.yasgui button.btn-primary {
  background-color: var(--primary-color, #3498db);
  border-color: var(--primary-color, #3498db);
}

.yasgui button.btn-primary:hover {
  background-color: #2980b9;
  border-color: #2980b9;
}

/* Fix layout issues */
.yasgui .CodeMirror-scroll {
  min-height: 200px;
}

.yasgui .yasr {
  min-height: 300px;
}

/* Make table results more readable */
.yasgui .yasr_results table {
  margin: 1em 0;
  border-collapse: collapse;
  width: 100%;
}

.yasgui .yasr_results table th,
.yasgui .yasr_results table td {
  border: 1px solid #ddd;
  padding: 8px;
}

.yasgui .yasr_results table tr:nth-child(even) {
  background-color: #f2f2f2;
}

.yasgui .yasr_results table th {
  padding-top: 12px;
  padding-bottom: 12px;
  text-align: left;
  background-color: var(--primary-color, #3498db);
  color: white;
}

/* Fix for potential responsive issues */
@media (max-width: 768px) {
  .yasgui-container {
    min-height: 400px;
  }
  
  .yasgui .yasqe .CodeMirror {
    font-size: 12px;
  }
  
  .yasgui .yasr_header {
    flex-direction: column;
  }
}

/* Fix for potential font issues */
.yasgui .yasqe .cm-atom,
.yasgui .yasqe .cm-string {
  font-family: monospace;
}

/* Fix for button alignment */
.yasgui .yasqe_buttons {
  display: flex;
  align-items: center;
  gap: 5px;
}

/* Fix potential flex issues */
.yasqe .CodeMirror {
  flex: 1;
  display: flex;
  flex-direction: column;
}

/* Ensure SVG icons are visible */
.yasgui svg {
  fill: currentColor;
}
/* BASICS */

.CodeMirror {
  /* Set height, width, borders, and global font properties here */
  font-family: monospace;
  height: 300px;
  color: black;
  direction: ltr;
}

/* PADDING */

.CodeMirror-lines {
  padding: 4px 0; /* Vertical padding around content */
}
.CodeMirror pre.CodeMirror-line,
.CodeMirror pre.CodeMirror-line-like {
  padding: 0 4px; /* Horizontal padding of content */
}

.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
  background-color: white; /* The little square between H and V scrollbars */
}

/* GUTTER */

.CodeMirror-gutters {
  border-right: 1px solid #ddd;
  background-color: #f7f7f7;
  white-space: nowrap;
}
.CodeMirror-linenumbers {}
.CodeMirror-linenumber {
  padding: 0 3px 0 5px;
  min-width: 20px;
  text-align: right;
  color: #999;
  white-space: nowrap;
}

.CodeMirror-guttermarker { color: black; }
.CodeMirror-guttermarker-subtle { color: #999; }

/* CURSOR */

.CodeMirror-cursor {
  border-left: 1px solid black;
  border-right: none;
  width: 0;
}
/* Shown when moving in bi-directional text */
.CodeMirror div.CodeMirror-secondarycursor {
  border-left: 1px solid silver;
}
.cm-fat-cursor .CodeMirror-cursor {
  width: auto;
  border: 0 !important;
  background: #7e7;
}
.cm-fat-cursor div.CodeMirror-cursors {
  z-index: 1;
}
.cm-fat-cursor .CodeMirror-line::selection,
.cm-fat-cursor .CodeMirror-line > span::selection, 
.cm-fat-cursor .CodeMirror-line > span > span::selection { background: transparent; }
.cm-fat-cursor .CodeMirror-line::-moz-selection,
.cm-fat-cursor .CodeMirror-line > span::-moz-selection,
.cm-fat-cursor .CodeMirror-line > span > span::-moz-selection { background: transparent; }
.cm-fat-cursor { caret-color: transparent; }
@-moz-keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}
@-webkit-keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}
@keyframes blink {
  0% {}
  50% { background-color: transparent; }
  100% {}
}

/* Can style cursor different in overwrite (non-insert) mode */
.CodeMirror-overwrite .CodeMirror-cursor {}

.cm-tab { display: inline-block; text-decoration: inherit; }

.CodeMirror-rulers {
  position: absolute;
  left: 0; right: 0; top: -50px; bottom: 0;
  overflow: hidden;
}
.CodeMirror-ruler {
  border-left: 1px solid #ccc;
  top: 0; bottom: 0;
  position: absolute;
}

/* DEFAULT THEME */

.cm-s-default .cm-header {color: blue;}
.cm-s-default .cm-quote {color: #090;}
.cm-negative {color: #d44;}
.cm-positive {color: #292;}
.cm-header, .cm-strong {font-weight: bold;}
.cm-em {font-style: italic;}
.cm-link {text-decoration: underline;}
.cm-strikethrough {text-decoration: line-through;}

.cm-s-default .cm-keyword {color: #708;}
.cm-s-default .cm-atom {color: #219;}
.cm-s-default .cm-number {color: #164;}
.cm-s-default .cm-def {color: #00f;}
.cm-s-default .cm-variable,
.cm-s-default .cm-punctuation,
.cm-s-default .cm-property,
.cm-s-default .cm-operator {}
.cm-s-default .cm-variable-2 {color: #05a;}
.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}
.cm-s-default .cm-comment {color: #a50;}
.cm-s-default .cm-string {color: #a11;}
.cm-s-default .cm-string-2 {color: #f50;}
.cm-s-default .cm-meta {color: #555;}
.cm-s-default .cm-qualifier {color: #555;}
.cm-s-default .cm-builtin {color: #30a;}
.cm-s-default .cm-bracket {color: #997;}
.cm-s-default .cm-tag {color: #170;}
.cm-s-default .cm-attribute {color: #00c;}
.cm-s-default .cm-hr {color: #999;}
.cm-s-default .cm-link {color: #00c;}

.cm-s-default .cm-error {color: #f00;}
.cm-invalidchar {color: #f00;}

.CodeMirror-composing { border-bottom: 2px solid; }

/* Default styles for common addons */

div.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}
div.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}
.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }
.CodeMirror-activeline-background {background: #e8f2ff;}

/* STOP */

/* The rest of this file contains styles related to the mechanics of
   the editor. You probably shouldn't touch them. */

.CodeMirror {
  position: relative;
  overflow: hidden;
  background: white;
}

.CodeMirror-scroll {
  overflow: scroll !important; /* Things will break if this is overridden */
  /* 50px is the magic margin used to hide the element's real scrollbars */
  /* See overflow: hidden in .CodeMirror */
  margin-bottom: -50px; margin-right: -50px;
  padding-bottom: 50px;
  height: 100%;
  outline: none; /* Prevent dragging from highlighting the element */
  position: relative;
  z-index: 0;
}
.CodeMirror-sizer {
  position: relative;
  border-right: 50px solid transparent;
}

/* The fake, visible scrollbars. Used to force redraw during scrolling
   before actual scrolling happens, thus preventing shaking and
   flickering artifacts. */
.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {
  position: absolute;
  z-index: 6;
  display: none;
  outline: none;
}
.CodeMirror-vscrollbar {
  right: 0; top: 0;
  overflow-x: hidden;
  overflow-y: scroll;
}
.CodeMirror-hscrollbar {
  bottom: 0; left: 0;
  overflow-y: hidden;
  overflow-x: scroll;
}
.CodeMirror-scrollbar-filler {
  right: 0; bottom: 0;
}
.CodeMirror-gutter-filler {
  left: 0; bottom: 0;
}

.CodeMirror-gutters {
  position: absolute; left: 0; top: 0;
  min-height: 100%;
  z-index: 3;
}
.CodeMirror-gutter {
  white-space: normal;
  height: 100%;
  display: inline-block;
  vertical-align: top;
  margin-bottom: -50px;
}
.CodeMirror-gutter-wrapper {
  position: absolute;
  z-index: 4;
  background: none !important;
  border: none !important;
}
.CodeMirror-gutter-background {
  position: absolute;
  top: 0; bottom: 0;
  z-index: 4;
}
.CodeMirror-gutter-elt {
  position: absolute;
  cursor: default;
  z-index: 4;
}
.CodeMirror-gutter-wrapper ::selection { background-color: transparent }
.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }

.CodeMirror-lines {
  cursor: text;
  min-height: 1px; /* prevents collapsing before first draw */
}
.CodeMirror pre.CodeMirror-line,
.CodeMirror pre.CodeMirror-line-like {
  /* Reset some styles that the rest of the page might have set */
  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;
  border-width: 0;
  background: transparent;
  font-family: inherit;
  font-size: inherit;
  margin: 0;
  white-space: pre;
  word-wrap: normal;
  line-height: inherit;
  color: inherit;
  z-index: 2;
  position: relative;
  overflow: visible;
  -webkit-tap-highlight-color: transparent;
  -webkit-font-variant-ligatures: contextual;
  font-variant-ligatures: contextual;
}
.CodeMirror-wrap pre.CodeMirror-line,
.CodeMirror-wrap pre.CodeMirror-line-like {
  word-wrap: break-word;
  white-space: pre-wrap;
  word-break: normal;
}

.CodeMirror-linebackground {
  position: absolute;
  left: 0; right: 0; top: 0; bottom: 0;
  z-index: 0;
}

.CodeMirror-linewidget {
  position: relative;
  z-index: 2;
  padding: 0.1px; /* Force widget margins to stay inside of the container */
}

.CodeMirror-widget {}

.CodeMirror-rtl pre { direction: rtl; }

.CodeMirror-code {
  outline: none;
}

/* Force content-box sizing for the elements where we expect it */
.CodeMirror-scroll,
.CodeMirror-sizer,
.CodeMirror-gutter,
.CodeMirror-gutters,
.CodeMirror-linenumber {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
}

.CodeMirror-measure {
  position: absolute;
  width: 100%;
  height: 0;
  overflow: hidden;
  visibility: hidden;
}

.CodeMirror-cursor {
  position: absolute;
  pointer-events: none;
}
.CodeMirror-measure pre { position: static; }

div.CodeMirror-cursors {
  visibility: hidden;
  position: relative;
  z-index: 3;
}
div.CodeMirror-dragcursors {
  visibility: visible;
}

.CodeMirror-focused div.CodeMirror-cursors {
  visibility: visible;
}

.CodeMirror-selected { background: #d9d9d9; }
.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }
.CodeMirror-crosshair { cursor: crosshair; }
.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }
.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }

.cm-searching {
  background-color: #ffa;
  background-color: rgba(255, 255, 0, .4);
}

/* Used to force a border model for a node */
.cm-force-border { padding-right: .1px; }

@media print {
  /* Hide the cursor when printing */
  .CodeMirror div.CodeMirror-cursors {
    visibility: hidden;
  }
}

/* See issue #2901 */
.cm-tab-wrap-hack:after { content: ''; }

/* Help users use markselection to safely style text background */
span.CodeMirror-selectedtext { background: none; }

/* Based on Sublime Text's Monokai theme */

.cm-s-monokai.CodeMirror { background: #272822; color: #f8f8f2; }
.cm-s-monokai div.CodeMirror-selected { background: #49483E; }
.cm-s-monokai .CodeMirror-line::selection, .cm-s-monokai .CodeMirror-line > span::selection, .cm-s-monokai .CodeMirror-line > span > span::selection { background: rgba(73, 72, 62, .99); }
.cm-s-monokai .CodeMirror-line::-moz-selection, .cm-s-monokai .CodeMirror-line > span::-moz-selection, .cm-s-monokai .CodeMirror-line > span > span::-moz-selection { background: rgba(73, 72, 62, .99); }
.cm-s-monokai .CodeMirror-gutters { background: #272822; border-right: 0px; }
.cm-s-monokai .CodeMirror-guttermarker { color: white; }
.cm-s-monokai .CodeMirror-guttermarker-subtle { color: #d0d0d0; }
.cm-s-monokai .CodeMirror-linenumber { color: #d0d0d0; }
.cm-s-monokai .CodeMirror-cursor { border-left: 1px solid #f8f8f0; }

.cm-s-monokai span.cm-comment { color: #75715e; }
.cm-s-monokai span.cm-atom { color: #ae81ff; }
.cm-s-monokai span.cm-number { color: #ae81ff; }

.cm-s-monokai span.cm-comment.cm-attribute { color: #97b757; }
.cm-s-monokai span.cm-comment.cm-def { color: #bc9262; }
.cm-s-monokai span.cm-comment.cm-tag { color: #bc6283; }
.cm-s-monokai span.cm-comment.cm-type { color: #5998a6; }

.cm-s-monokai span.cm-property, .cm-s-monokai span.cm-attribute { color: #a6e22e; }
.cm-s-monokai span.cm-keyword { color: #f92672; }
.cm-s-monokai span.cm-builtin { color: #66d9ef; }
.cm-s-monokai span.cm-string { color: #e6db74; }

.cm-s-monokai span.cm-variable { color: #f8f8f2; }
.cm-s-monokai span.cm-variable-2 { color: #9effff; }
.cm-s-monokai span.cm-variable-3, .cm-s-monokai span.cm-type { color: #66d9ef; }
.cm-s-monokai span.cm-def { color: #fd971f; }
.cm-s-monokai span.cm-bracket { color: #f8f8f2; }
.cm-s-monokai span.cm-tag { color: #f92672; }
.cm-s-monokai span.cm-header { color: #ae81ff; }
.cm-s-monokai span.cm-link { color: #ae81ff; }
.cm-s-monokai span.cm-error { background: #f92672; color: #f8f8f0; }

.cm-s-monokai .CodeMirror-activeline-background { background: #373831; }
.cm-s-monokai .CodeMirror-matchingbracket {
  text-decoration: underline;
  color: white !important;
}

.yasr .yasr_btn{border:none;background:inherit}.yasr .svgImg{display:flex;flex-direction:row}.yasr .svgImg svg{max-width:100%;max-height:100%;width:15px;height:15px;align-self:center}.yasr .yasr_btn.yasr_external_ref_btn{font-weight:600;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.yasr .yasr_btn.yasr_external_ref_btn:active,.yasr .yasr_btn.yasr_external_ref_btn:focus{color:inherit;-webkit-text-decoration-color:inherit;text-decoration-color:inherit}.yasr .yasr_btn.yasr_external_ref_btn .svgImg svg{width:18px;height:18px}.yasr a{color:#428bca;text-decoration:none}.yasr a:active,.yasr a:hover{outline:0;color:#2a6496;text-decoration:underline}.yasr .yasr_btnGroup{margin:0;padding:0;list-style:none;display:flex;overflow-x:auto;overflow-y:hidden}.yasr .yasr_btnGroup .plugin_icon{height:15px;width:15px;margin-right:5px;text-align:center}.yasr .yasr_btnGroup .yasr_btn{border-bottom:2px solid transparent;padding-left:6px;padding-right:6px;margin-left:6px;margin-right:6px}.yasr .yasr_btnGroup .yasr_btn.selected{border-bottom:2px solid #337ab7}@media (max-width:768px){.yasr .yasr_btn span{display:none}.yasr .yasr_btn .plugin_icon{margin-right:0}}.yasr .yasr_header{display:flex;flex-wrap:wrap}.yasr .yasr_fallback_info:not(:empty){margin-top:5px;border:1px solid #d1d1d1;padding:.5rem;background:#f7f7f7}.yasr .yasr_fallback_info:not(:empty) p{margin:0}.yasr .yasr_help_variable{background:#dff0ff;color:#428bca}.yasr .yasr_response_chip{color:#505050;background:#f5f5f5;border-radius:6px;display:flex;font-size:11pt;max-height:16pt;align-self:center;align-items:center;justify-content:center;white-space:nowrap;padding:6px;margin-left:5px;overflow:visible;box-sizing:border-box}.yasr .yasr_response_chip.empty{display:none}.yasr .yasr_plugin_control{display:flex;margin-left:auto;align-items:center}.yasr .yasr_plugin_control:empty{display:none}.yasr .yasr_btn{color:#505050;fill:#505050;display:flex;align-items:center;justify-content:center;cursor:pointer;white-space:nowrap;padding:6px 12px;overflow:visible;box-sizing:border-box}.yasr .yasr_btn.btn_icon{padding:4px 8px}.yasr .yasr_btn.disabled,.yasr .yasr_btn[disabled]{cursor:default;opacity:.5;box-shadow:none}.yasr .yasr_btn:not(.disabled):hover{fill:#000;color:#000}.yasr .yasr_btn.selected,.yasr .yasr_btn:focus{color:#337ab7;fill:#337ab7}.yasr .space_element{flex-grow:1;min-width:10px}.yasr .tableControls{display:flex;align-items:center;padding:0 5px 0 0;flex-wrap:wrap}.yasr .tableControls .tableFilter{margin-right:10px;height:100%}.yasr .tableControls .tableSizer{height:100%}.yasr .tableControls .switch{display:flex;align-items:center;margin-right:10px}.yasr .dataTable.ellipseTable{white-space:nowrap}.yasr .dataTable.ellipseTable div:not(.expanded){overflow:hidden;text-overflow:ellipsis}.yasr .dataTable:not(.ellipseTable) div:not(.expanded),.yasr .expanded{word-break:break-all}.yasr .expanded{white-space:normal}.yasr .expandable:not(.expanded){cursor:pointer}.yasr .expandable:not(.expanded) a{pointer-events:none}.yasr .dataTables_wrapper{font-size:.9em;min-width:100%}.yasr .dataTables_wrapper .grip-container{max-width:100%}.yasr .dataTables_wrapper .grip-padding>tbody>tr>td,.yasr .dataTables_wrapper .grip-padding>tbody>tr>th{padding-left:7px!important;padding-right:5px!important}.yasr .dataTables_wrapper .dataTable{min-width:100%;box-sizing:border-box}.yasr .dataTables_wrapper .dataTable.no-footer{border-bottom:none}.yasr .dataTables_wrapper .dataTable thead .sorting{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAQAAADYWf5HAAAAkElEQVQoz7XQMQ5AQBCF4dWQSJxC5wwax1Cq1e7BAdxD5SL+Tq/QCM1oNiJidwox0355mXnG/DrEtIQ6azioNZQxI0ykPhTQIwhCR+BmBYtlK7kLJYwWCcJA9M4qdrZrd8pPjZWPtOqdRQy320YSV17OatFC4euts6z39GYMKRPCTKY9UnPQ6P+GtMRfGtPnBCiqhAeJPmkqAAAAAElFTkSuQmCC)}.yasr .dataTables_wrapper .dataTable thead .sorting_asc{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAYAAAByUDbMAAAAZ0lEQVQ4y2NgGLKgquEuFxBPAGI2ahhWCsS/gDibUoO0gPgxEP8H4ttArEyuQYxAPBdqEAxPBImTY5gjEL9DM+wTENuQahAvEO9DMwiGdwAxOymGJQLxTyD+jgWDxCMZRsEoGAVoAADeemwtPcZI2wAAAABJRU5ErkJggg==)}.yasr .dataTables_wrapper .dataTable thead .sorting_desc{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAYAAAByUDbMAAAAZUlEQVQ4y2NgGAWjYBSggaqGu5FA/BOIv2PBIPFEUgxjB+IdQPwfC94HxLykus4GiD+hGfQOiB3J8SojEE9EM2wuSJzcsFMG4ttQgx4DsRalkZENxL+AuJQaMcsGxBOAmGvopk8AVz1sLZgg0bsAAAAASUVORK5CYII=)}.yasr .dataTables_wrapper .dataTable thead .sorting_asc_disabled{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAQAAADYWf5HAAAAW0lEQVQoz2NgoCm4w3Vnwh02wspK7/y6k01Ikdadx3f+37l9RxmfIsY7c4GKQHDiHUbcyhzvvIMq+3THBpci3jv7oIpAcMcdduzKEu/8vPMdDn/eiWQYBYMKAAC3ykIEuYQJUgAAAABJRU5ErkJggg==)}.yasr .dataTables_wrapper .dataTable thead .sorting_desc_disabled{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAATCAQAAADYWf5HAAAAWUlEQVQoz2NgGAWDCtyJvPPzznc4/HknEbsy9js77vyHw313eHGZZ3PnE1TRuzuOuK1lvDMRqmzuHUZ87lO+cxuo6PEdLUIeyb7z604pYf+y3Zlwh4u2YQoAc7ZCBHH4jigAAAAASUVORK5CYII=)}.yasr .dataTables_wrapper .dataTable tbody tr:hover{background-color:#f9f9f9}.yasr .dataTables_wrapper .dataTable thead tr th{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-weight:700;text-align:start;overflow:hidden;text-overflow:ellipsis;border:none;padding:5px 5px 5px 7px;min-width:28px}.yasr .dataTables_wrapper .dataTable thead tr th.sorting{min-width:10px;padding-right:18px}.yasr .dataTables_wrapper .dataTable thead tr th:hover{background-color:#f9f9f9}.yasr .dataTables_wrapper .dataTable td{padding:5px}.yasr .dataTables_wrapper .dataTable td>div{-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto}.yasr .dataTables_wrapper .dataTable td>div.rowNumber{word-break:keep-all;overflow:visible}.yasr .dataTables_wrapper .dataTable td .tableEllipse{cursor:pointer;font-weight:700;padding:0 2px;background-color:rgba(66,139,202,.2);border-radius:2px;margin:0 3px}.yasr .dataTables_wrapper div.dataTables_paginate.paging_simple_numbers a.paginate_button{border:none;background:transparent}.yasr .dataTables_wrapper div.dataTables_paginate.paging_simple_numbers a.paginate_button .disabled{color:#505050}.yasr .dataTables_wrapper div.dataTables_paginate.paging_simple_numbers a.paginate_button.current{border:none;background:transparent;text-decoration:underline!important}.yasr .dataTables_wrapper div.dataTables_paginate.paging_simple_numbers a.paginate_button:hover{border:none;background:transparent}.yasr .dataTables_wrapper div.dataTables_paginate.paging_simple_numbers a.paginate_button:hover:not(.disabled){color:#000!important}.yasr .dataTables_wrapper div.dataTables_paginate.paging_simple_numbers a.paginate_button:active{box-shadow:none}table.dataTable{width:100%;margin:0 auto;clear:both;border-collapse:separate;border-spacing:0}table.dataTable tfoot th,table.dataTable thead th{font-weight:700}table.dataTable thead td,table.dataTable thead th{padding:10px 18px;border-bottom:1px solid #111}table.dataTable thead td:active,table.dataTable thead th:active{outline:none}table.dataTable tfoot td,table.dataTable tfoot th{padding:10px 18px 6px;border-top:1px solid #111}table.dataTable thead .sorting,table.dataTable thead .sorting_asc,table.dataTable thead .sorting_asc_disabled,table.dataTable thead .sorting_desc,table.dataTable thead .sorting_desc_disabled{cursor:pointer;*cursor:hand;background-repeat:no-repeat;background-position:100%}table.dataTable tbody tr{background-color:#fff}table.dataTable tbody tr.selected{background-color:#b0bed9}table.dataTable tbody td,table.dataTable tbody th{padding:8px 10px}table.dataTable.display tbody td,table.dataTable.display tbody th,table.dataTable.row-border tbody td,table.dataTable.row-border tbody th{border-top:1px solid #ddd}table.dataTable.display tbody tr:first-child td,table.dataTable.display tbody tr:first-child th,table.dataTable.row-border tbody tr:first-child td,table.dataTable.row-border tbody tr:first-child th{border-top:none}table.dataTable.cell-border tbody td,table.dataTable.cell-border tbody th{border-top:1px solid #ddd;border-right:1px solid #ddd}table.dataTable.cell-border tbody tr td:first-child,table.dataTable.cell-border tbody tr th:first-child{border-left:1px solid #ddd}table.dataTable.cell-border tbody tr:first-child td,table.dataTable.cell-border tbody tr:first-child th{border-top:none}table.dataTable.display tbody tr.odd,table.dataTable.stripe tbody tr.odd{background-color:#f9f9f9}table.dataTable.display tbody tr.odd.selected,table.dataTable.stripe tbody tr.odd.selected{background-color:#acbad4}table.dataTable.display tbody tr:hover,table.dataTable.hover tbody tr:hover{background-color:#f6f6f6}table.dataTable.display tbody tr:hover.selected,table.dataTable.hover tbody tr:hover.selected{background-color:#aab7d1}table.dataTable.display tbody tr>.sorting_1,table.dataTable.display tbody tr>.sorting_2,table.dataTable.display tbody tr>.sorting_3,table.dataTable.order-column tbody tr>.sorting_1,table.dataTable.order-column tbody tr>.sorting_2,table.dataTable.order-column tbody tr>.sorting_3{background-color:#fafafa}table.dataTable.display tbody tr.selected>.sorting_1,table.dataTable.display tbody tr.selected>.sorting_2,table.dataTable.display tbody tr.selected>.sorting_3,table.dataTable.order-column tbody tr.selected>.sorting_1,table.dataTable.order-column tbody tr.selected>.sorting_2,table.dataTable.order-column tbody tr.selected>.sorting_3{background-color:#acbad5}table.dataTable.display tbody tr.odd>.sorting_1,table.dataTable.order-column.stripe tbody tr.odd>.sorting_1{background-color:#f1f1f1}table.dataTable.display tbody tr.odd>.sorting_2,table.dataTable.order-column.stripe tbody tr.odd>.sorting_2{background-color:#f3f3f3}table.dataTable.display tbody tr.odd>.sorting_3,table.dataTable.order-column.stripe tbody tr.odd>.sorting_3{background-color:#f5f5f5}table.dataTable.display tbody tr.odd.selected>.sorting_1,table.dataTable.order-column.stripe tbody tr.odd.selected>.sorting_1{background-color:#a6b4cd}table.dataTable.display tbody tr.odd.selected>.sorting_2,table.dataTable.order-column.stripe tbody tr.odd.selected>.sorting_2{background-color:#a8b5cf}table.dataTable.display tbody tr.odd.selected>.sorting_3,table.dataTable.order-column.stripe tbody tr.odd.selected>.sorting_3{background-color:#a9b7d1}table.dataTable.display tbody tr.even>.sorting_1,table.dataTable.order-column.stripe tbody tr.even>.sorting_1{background-color:#fafafa}table.dataTable.display tbody tr.even>.sorting_2,table.dataTable.order-column.stripe tbody tr.even>.sorting_2{background-color:#fcfcfc}table.dataTable.display tbody tr.even>.sorting_3,table.dataTable.order-column.stripe tbody tr.even>.sorting_3{background-color:#fefefe}table.dataTable.display tbody tr.even.selected>.sorting_1,table.dataTable.order-column.stripe tbody tr.even.selected>.sorting_1{background-color:#acbad5}table.dataTable.display tbody tr.even.selected>.sorting_2,table.dataTable.order-column.stripe tbody tr.even.selected>.sorting_2{background-color:#aebcd6}table.dataTable.display tbody tr.even.selected>.sorting_3,table.dataTable.order-column.stripe tbody tr.even.selected>.sorting_3{background-color:#afbdd8}table.dataTable.display tbody tr:hover>.sorting_1,table.dataTable.order-column.hover tbody tr:hover>.sorting_1{background-color:#eaeaea}table.dataTable.display tbody tr:hover>.sorting_2,table.dataTable.order-column.hover tbody tr:hover>.sorting_2{background-color:#ececec}table.dataTable.display tbody tr:hover>.sorting_3,table.dataTable.order-column.hover tbody tr:hover>.sorting_3{background-color:#efefef}table.dataTable.display tbody tr:hover.selected>.sorting_1,table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_1{background-color:#a2aec7}table.dataTable.display tbody tr:hover.selected>.sorting_2,table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_2{background-color:#a3b0c9}table.dataTable.display tbody tr:hover.selected>.sorting_3,table.dataTable.order-column.hover tbody tr:hover.selected>.sorting_3{background-color:#a5b2cb}table.dataTable.no-footer{border-bottom:1px solid #111}table.dataTable.nowrap td,table.dataTable.nowrap th{white-space:nowrap}table.dataTable.compact thead td,table.dataTable.compact thead th{padding:4px 17px}table.dataTable.compact tbody td,table.dataTable.compact tbody th,table.dataTable.compact tfoot td,table.dataTable.compact tfoot th{padding:4px}table.dataTable td.dt-left,table.dataTable th.dt-left{text-align:left}table.dataTable td.dataTables_empty,table.dataTable td.dt-center,table.dataTable th.dt-center{text-align:center}table.dataTable td.dt-right,table.dataTable th.dt-right{text-align:right}table.dataTable td.dt-justify,table.dataTable th.dt-justify{text-align:justify}table.dataTable td.dt-nowrap,table.dataTable th.dt-nowrap{white-space:nowrap}table.dataTable tfoot td.dt-head-left,table.dataTable tfoot th.dt-head-left,table.dataTable thead td.dt-head-left,table.dataTable thead th.dt-head-left{text-align:left}table.dataTable tfoot td.dt-head-center,table.dataTable tfoot th.dt-head-center,table.dataTable thead td.dt-head-center,table.dataTable thead th.dt-head-center{text-align:center}table.dataTable tfoot td.dt-head-right,table.dataTable tfoot th.dt-head-right,table.dataTable thead td.dt-head-right,table.dataTable thead th.dt-head-right{text-align:right}table.dataTable tfoot td.dt-head-justify,table.dataTable tfoot th.dt-head-justify,table.dataTable thead td.dt-head-justify,table.dataTable thead th.dt-head-justify{text-align:justify}table.dataTable tfoot td.dt-head-nowrap,table.dataTable tfoot th.dt-head-nowrap,table.dataTable thead td.dt-head-nowrap,table.dataTable thead th.dt-head-nowrap{white-space:nowrap}table.dataTable tbody td.dt-body-left,table.dataTable tbody th.dt-body-left{text-align:left}table.dataTable tbody td.dt-body-center,table.dataTable tbody th.dt-body-center{text-align:center}table.dataTable tbody td.dt-body-right,table.dataTable tbody th.dt-body-right{text-align:right}table.dataTable tbody td.dt-body-justify,table.dataTable tbody th.dt-body-justify{text-align:justify}table.dataTable tbody td.dt-body-nowrap,table.dataTable tbody th.dt-body-nowrap{white-space:nowrap}table.dataTable,table.dataTable td,table.dataTable th{box-sizing:content-box}.dataTables_wrapper{position:relative;clear:both;*zoom:1;zoom:1}.dataTables_wrapper .dataTables_length{float:left}.dataTables_wrapper .dataTables_length select{border:1px solid #aaa;border-radius:3px;background-color:transparent;padding:4px}.dataTables_wrapper .dataTables_filter{float:right;text-align:right}.dataTables_wrapper .dataTables_filter input{border:1px solid #aaa;border-radius:3px;padding:5px;background-color:transparent;margin-left:3px}.dataTables_wrapper .dataTables_info{clear:both;float:left;padding-top:.755em}.dataTables_wrapper .dataTables_paginate{float:right;text-align:right;padding-top:.25em}.dataTables_wrapper .dataTables_paginate .paginate_button{box-sizing:border-box;display:inline-block;min-width:1.5em;padding:.5em 1em;margin-left:2px;text-align:center;text-decoration:none!important;cursor:pointer;*cursor:hand;color:#333!important;border:1px solid transparent;border-radius:2px}.dataTables_wrapper .dataTables_paginate .paginate_button.current,.dataTables_wrapper .dataTables_paginate .paginate_button.current:hover{color:#333!important;border:1px solid #979797;background-color:#fff;background:-webkit-gradient(linear,left top,left bottom,color-stop(0,#fff),color-stop(100%,#dcdcdc));background:-webkit-linear-gradient(top,#fff,#dcdcdc);background:-moz-linear-gradient(top,#fff 0,#dcdcdc 100%);background:-ms-linear-gradient(top,#fff 0,#dcdcdc 100%);background:-o-linear-gradient(top,#fff 0,#dcdcdc 100%);background:linear-gradient(180deg,#fff 0,#dcdcdc)}.dataTables_wrapper .dataTables_paginate .paginate_button.disabled,.dataTables_wrapper .dataTables_paginate .paginate_button.disabled:active,.dataTables_wrapper .dataTables_paginate .paginate_button.disabled:hover{cursor:default;color:#666!important;border:1px solid transparent;background:transparent;box-shadow:none}.dataTables_wrapper .dataTables_paginate .paginate_button:hover{color:#fff!important;border:1px solid #111;background-color:#585858;background:-webkit-gradient(linear,left top,left bottom,color-stop(0,#585858),color-stop(100%,#111));background:-webkit-linear-gradient(top,#585858,#111);background:-moz-linear-gradient(top,#585858 0,#111 100%);background:-ms-linear-gradient(top,#585858 0,#111 100%);background:-o-linear-gradient(top,#585858 0,#111 100%);background:linear-gradient(180deg,#585858 0,#111)}.dataTables_wrapper .dataTables_paginate .paginate_button:active{outline:none;background-color:#2b2b2b;background:-webkit-gradient(linear,left top,left bottom,color-stop(0,#2b2b2b),color-stop(100%,#0c0c0c));background:-webkit-linear-gradient(top,#2b2b2b,#0c0c0c);background:-moz-linear-gradient(top,#2b2b2b 0,#0c0c0c 100%);background:-ms-linear-gradient(top,#2b2b2b 0,#0c0c0c 100%);background:-o-linear-gradient(top,#2b2b2b 0,#0c0c0c 100%);background:linear-gradient(180deg,#2b2b2b 0,#0c0c0c);box-shadow:inset 0 0 3px #111}.dataTables_wrapper .dataTables_paginate .ellipsis{padding:0 1em}.dataTables_wrapper .dataTables_processing{position:absolute;top:50%;left:50%;width:100%;height:40px;margin-left:-50%;margin-top:-25px;padding-top:20px;text-align:center;font-size:1.2em;background-color:#fff;background:-webkit-gradient(linear,left top,right top,color-stop(0,hsla(0,0%,100%,0)),color-stop(25%,hsla(0,0%,100%,.9)),color-stop(75%,hsla(0,0%,100%,.9)),color-stop(100%,hsla(0,0%,100%,0)));background:-webkit-linear-gradient(left,hsla(0,0%,100%,0),hsla(0,0%,100%,.9) 25%,hsla(0,0%,100%,.9) 75%,hsla(0,0%,100%,0));background:-moz-linear-gradient(left,hsla(0,0%,100%,0) 0,hsla(0,0%,100%,.9) 25%,hsla(0,0%,100%,.9) 75%,hsla(0,0%,100%,0) 100%);background:-ms-linear-gradient(left,hsla(0,0%,100%,0) 0,hsla(0,0%,100%,.9) 25%,hsla(0,0%,100%,.9) 75%,hsla(0,0%,100%,0) 100%);background:-o-linear-gradient(left,hsla(0,0%,100%,0) 0,hsla(0,0%,100%,.9) 25%,hsla(0,0%,100%,.9) 75%,hsla(0,0%,100%,0) 100%);background:linear-gradient(90deg,hsla(0,0%,100%,0) 0,hsla(0,0%,100%,.9) 25%,hsla(0,0%,100%,.9) 75%,hsla(0,0%,100%,0))}.dataTables_wrapper .dataTables_filter,.dataTables_wrapper .dataTables_info,.dataTables_wrapper .dataTables_length,.dataTables_wrapper .dataTables_paginate,.dataTables_wrapper .dataTables_processing{color:#333}.dataTables_wrapper .dataTables_scroll{clear:both}.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody{*margin-top:-1px;-webkit-overflow-scrolling:touch}.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>tbody>tr>td,.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>tbody>tr>th,.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>thead>tr>td,.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>thead>tr>th{vertical-align:middle}.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>tbody>tr>td>div.dataTables_sizing,.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>tbody>tr>th>div.dataTables_sizing,.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>thead>tr>td>div.dataTables_sizing,.dataTables_wrapper .dataTables_scroll div.dataTables_scrollBody>table>thead>tr>th>div.dataTables_sizing{height:0;overflow:hidden;margin:0!important;padding:0!important}.dataTables_wrapper.no-footer .dataTables_scrollBody{border-bottom:1px solid #111}.dataTables_wrapper.no-footer div.dataTables_scrollBody>table,.dataTables_wrapper.no-footer div.dataTables_scrollHead table.dataTable{border-bottom:none}.dataTables_wrapper:after{visibility:hidden;display:block;content:"";clear:both;height:0}@media screen and (max-width:767px){.dataTables_wrapper .dataTables_info,.dataTables_wrapper .dataTables_paginate{float:none;text-align:center}.dataTables_wrapper .dataTables_paginate{margin-top:.5em}}@media screen and (max-width:640px){.dataTables_wrapper .dataTables_filter,.dataTables_wrapper .dataTables_length{float:none;text-align:center}.dataTables_wrapper .dataTables_filter{margin-top:.5em}}.yasr .booleanResult{display:flex;align-items:center;justify-content:center}.yasr .booleanResult svg{margin-bottom:-10px;margin-right:7px}.yasr .yasr_results{position:relative}.yasr .yasr_results .CodeMirror{border:1px solid #d1d1d1;margin-top:5px;height:100%}.yasr .yasr_results .CodeMirror.overflow:before{background:linear-gradient(transparent,hsla(0,0%,100%,.666667) 75%,#fff);content:"";width:100%;height:100%;z-index:1200;position:absolute;pointer-events:none}.yasr .yasr_results .overlay{width:100%;position:absolute;bottom:0;z-index:1201;display:flex;pointer-events:none}.yasr .yasr_results .overlay:after,.yasr .yasr_results .overlay:before{content:"";flex-grow:1}.yasr .yasr_results .overlay_content{display:flex;align-content:center;justify-content:center;align-items:center;background:#fff;pointer-events:all;background:linear-gradient(90deg,transparent,#fff 5%,#fff 95%,transparent)}.yasr .yasr_results .yasr_btn.overlay_btn{border:1px solid #337ab7;background:#fff;color:#337ab7;padding:10px;margin:10px}.yasr .yasr_results .yasr_btn.overlay_btn svg{margin-left:.5rem;fill:#337ab7;color:#337ab7}.yasr .yasr_results .yasr_btn.overlay_btn:hover{color:#255681;border-color:#337ab7;fill:#255681}.yasr .yasr_results .yasr_btn.overlay_btn:hover svg{color:#255681;fill:#255681}.CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-fat-cursor-mark{background-color:rgba(20,255,20,.5)}.cm-animate-fat-cursor,.cm-fat-cursor-mark{-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite}.cm-animate-fat-cursor{width:auto;border:0;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:0;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-invalidchar,.cm-s-default .cm-error{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0b0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#a22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-50px;margin-right:-50px;padding-bottom:50px;height:100%;outline:none;position:relative}.CodeMirror-sizer{position:relative;border-right:50px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-50px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:none!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre.CodeMirror-line,.CodeMirror-wrap pre.CodeMirror-line-like{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;padding:.1px}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:none}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}.CodeMirror-focused div.CodeMirror-cursors,div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:""}span.CodeMirror-selectedtext{background:none}.yasr .errorResult{padding:10px}.yasr .errorResult .errorHeader{overflow:hidden}.yasr .errorResult .errorHeader .yasr_tryQuery{float:right;text-decoration:none;padding-top:3px;padding-bottom:3px}.yasr .errorResult .errorHeader span.status{display:inline-block;padding:.35em .5rem;font-size:75%;font-weight:600;line-height:1.35;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:.25em;color:#fff;background-color:#dc3545}.yasr .errorResult .errorMessageContainer{display:flex}.yasr .errorResult .errorMessageContainer .errorMessage{flex-grow:1;width:0;min-width:100px;overflow:auto;display:block;padding:10px;margin:10px 0;font-size:13px;line-height:1.42857;word-break:break-all;word-wrap:break-word;color:#333;background-color:#f5f5f5;border:1px solid #ccc;border-radius:4px}.yasr .errorResult .redOutline{color:#a94442;background-color:#f2dede;margin-top:10px;padding:5px 1em;border:1px solid #ebccd1;border-radius:4px}.yasqe .CodeMirror{min-height:60px}.yasqe .svgImg{display:inline-block}.yasqe span.shortlinkErr{font-size:small;color:red;font-weight:700;float:left}.yasqe .CodeMirror-hint{max-width:30em}.yasqe .notificationContainer{width:100%;display:flex;justify-content:center;position:absolute;bottom:0}.yasqe .notification{z-index:4;padding:0 5px;max-height:0;color:#999;background-color:#eee;font-size:90%;text-align:center;transition:max-height .2s ease-in;border-top-right-radius:2px;border-top-left-radius:2px}.yasqe .notification.active{max-height:3rem}.yasqe .parseErrorIcon{width:13px;height:13px;margin-top:2px;margin-left:2px}.yasqe .parseErrorIcon svg g{fill:red}.yasqe .yasqe_tooltip{background:#333;background:rgba(0,0,0,.8);border-radius:5px;color:#fff;padding:5px 15px;width:220px;white-space:pre-wrap;white-space:normal;margin-top:5px}.yasqe .notificationLoader{width:18px;height:18px;vertical-align:middle}.yasqe .resizeWrapper{width:100%;height:10px;display:flex;align-items:center;justify-content:center;cursor:row-resize}.yasqe .resizeChip{width:20%;height:4px;background-color:#d1d1d1;visibility:hidden;border-radius:2px}.yasqe:hover .resizeChip{visibility:visible}.yasqe .yasqe_btn{color:#333;background-color:#fff;border:1px solid #ccc;display:inline-block;text-align:center;vertical-align:middle;cursor:pointer;white-space:nowrap;padding:6px 12px;border-radius:2px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:visible;box-sizing:border-box}.yasqe .yasqe_btn.btn_icon{padding:4px 8px}.yasqe .yasqe_btn.disabled,.yasqe .yasqe_btn[disabled]{cursor:default;opacity:.5;filter:alpha(opacity=50);box-shadow:none}.yasqe .yasqe_btn:hover{outline:0;background-color:#ebebeb;border-color:#adadad}.yasqe .yasqe_btn.selected,.yasqe .yasqe_btn:focus{color:#fff;outline:0;background-color:#337ab7;border-color:#337ab7}.yasqe .yasqe_btn.btn_icon:focus{color:#333;background-color:#fff;border:1px solid #ccc}.yasqe .yasqe_btn.yasqe_btn-sm{padding:1px 5px;font-size:12px;line-height:1.5;border-radius:3px}.yasqe .yasqe_buttons{position:absolute;top:10px;right:20px;z-index:5}.yasqe .yasqe_buttons svg{fill:#505050}.yasqe .yasqe_buttons .yasqe_share{cursor:pointer;margin-top:3px;display:inline-block;border:none;background:none}.yasqe .yasqe_buttons .yasqe_share svg{height:25px;width:25px}.yasqe .yasqe_buttons button{vertical-align:top;margin-left:5px}.yasqe .yasqe_buttons .yasqe_sharePopup{position:absolute;padding:4px;margin-left:0;background-color:#fff;border:1px solid #e3e3e3;border-radius:2px;box-shadow:inset 0 1px 1px rgba(0,0,0,.05);width:600px;height:auto;display:flex}.yasqe .yasqe_buttons .yasqe_sharePopup .inputWrapper{flex-grow:100}.yasqe .yasqe_buttons .yasqe_sharePopup input{float:left;width:100%;border:0;-ms-box-sizing:border-box;-khtml-box-sizing:border-box;box-sizing:border-box}.yasqe .yasqe_buttons .yasqe_sharePopup button{float:right;margin-left:5px}.yasqe .yasqe_buttons .yasqe_sharePopup textarea{width:100%}.yasqe .yasqe_buttons .yasqe_queryButton{display:inline-block;position:relative;border:none;background:none;padding:0;cursor:pointer;width:40px;height:40px}.yasqe .yasqe_buttons .yasqe_queryButton .queryIcon{display:block}.yasqe .yasqe_buttons .yasqe_queryButton .queryIcon svg{width:40px;height:40px}.yasqe .yasqe_buttons .yasqe_queryButton .svgImg{position:absolute;height:inherit;top:0}.yasqe .yasqe_buttons .yasqe_queryButton.busy svg #loadingIcon{stroke-dasharray:100;-webkit-animation:dash 1.5s linear infinite;animation:dash 1.5s linear infinite;stroke-width:8px;stroke:#fff}@-webkit-keyframes dash{to{stroke-dashoffset:200}}@keyframes dash{to{stroke-dashoffset:200}}@-webkit-keyframes rotate{to{transform:rotate(1turn)}}@keyframes rotate{to{transform:rotate(1turn)}}.yasqe .yasqe_buttons .yasqe_queryButton .warningIcon{display:none}.yasqe .yasqe_buttons .yasqe_queryButton.query_error .warningIcon{display:block;top:5px;right:0}.yasqe .yasqe_buttons .yasqe_queryButton.query_error .warningIcon svg{width:15px;height:15px}.yasqe .yasqe_buttons .yasqe_queryButton.query_error .warningIcon svg g{fill:red}.yasqe .yasqe_buttons .yasqe_queryButton.query_disabled{cursor:not-allowed}.yasqe .yasqe_buttons .yasqe_queryButton.query_disabled .queryIcon{opacity:.5;filter:alpha(opacity=50)}@-webkit-keyframes spin{to{transform:rotate(1turn)}}.CodeMirror-hints{position:absolute;z-index:10;overflow:hidden;list-style:none;margin:0;padding:2px;box-shadow:2px 3px 5px rgba(0,0,0,.2);border-radius:3px;border:1px solid silver;background:#fff;font-size:90%;font-family:monospace;max-height:20em;overflow-y:auto}.CodeMirror-hint{margin:0;padding:0 4px;border-radius:2px;white-space:pre;color:#000;cursor:pointer}li.CodeMirror-hint-active{background:#08f;color:#fff}.CodeMirror-foldmarker{color:#00f;text-shadow:#b9f 1px 1px 2px,#b9f -1px -1px 2px,#b9f 1px -1px 2px,#b9f -1px 1px 2px;font-family:arial;line-height:.3;cursor:pointer}.CodeMirror-foldgutter{width:.7em}.CodeMirror-foldgutter-folded,.CodeMirror-foldgutter-open{cursor:pointer}.CodeMirror-foldgutter-open:after{content:"\25BE"}.CodeMirror-foldgutter-folded:after{content:"\25B8"}.yasqe .CodeMirror{line-height:1.5em;font-size:14px;border:1px solid #d1d1d1}.yasqe span.cm-error{border-bottom:2px dotted red}.yasqe .gutterErrorBar{width:4px}.yasqe .CodeMirror-foldmarker{color:#6e2500;text-shadow:#ff935e 1px 1px 2px,#ff935e -1px -1px 2px,#ff935e 1px -1px 2px,#ff935e -1px 1px 2px;font-size:19px}.yasqe .cm-matchhighlight{background-color:#dbdeed}.CodeMirror-hints.default{max-width:1000px}.CodeMirror-hints.default li{text-overflow:ellipsis;overflow:hidden}@media only screen and (max-width:1000px){.CodeMirror-hints.default{max-width:800px}}.yasgui .tabMenu{background:#f5f5f5;z-index:7;transition:all .5s;transform:translate3d(-100%,0,0) rotateY(90deg);transform-origin:100% 50%;visibility:hidden;width:600px;border:1px solid #ccc;position:absolute;top:35px;left:0;perspective:1500px;perspective-origin:0 50%;transform-style:preserve-3d}.yasgui .tabMenu.open{visibility:visible;transform:translate3d(-100%,0,0) rotateY(0deg);transition:all .5s;left:600px}@media (-ms-high-contrast:active),(-ms-high-contrast:none){.yasgui .tabMenu.open{min-width:600px}}@media (-ms-high-contrast:active),(-ms-high-contrast:none){.yasgui .tabMenu{height:0}}.yasgui .tabMenu .requestConfigWrapper{padding:10px;overflow:hidden;display:flex;flex-wrap:nowrap;background:#f5f5f5}.yasgui .tabMenu .requestConfigWrapper .selectorButton{background-color:transparent;border:none;border-bottom:1px solid #d1d1d1;height:30px;color:#505050;cursor:pointer}.yasgui .tabMenu .requestConfigWrapper .selectorButton:hover{color:#000;border-color:#000}.yasgui .tabMenu .requestConfigWrapper .selectorButton.selected{color:#337ab7;border-bottom:2px solid #337ab7}.yasgui .tabMenu .requestConfigWrapper .selectorButton:focus{outline:none}.yasgui .tabMenu .requestConfigWrapper .selectorButton:focus-visible{color:#000;border-color:#000}.yasgui .tabMenu .acceptWrapper{flex-direction:row}.yasgui .tabMenu .acceptWrapper .acceptLabel{justify-self:center}.yasgui .tabMenu .acceptWrapper .selector{flex-direction:column;display:flex;padding:2.5px 5px;flex-grow:1;width:100%}.yasgui .tabMenu .acceptWrapper .selector .selectorLabel{align-self:center;font-weight:700;font-size:small}.yasgui .tabMenu .textSetting{display:flex;flex-direction:column}.yasgui .tabMenu .textSetting .label{align-self:flex-start}.yasgui .tabMenu .textSetting .graphInput{white-space:nowrap}.yasgui .tabMenu .textSetting .textRow{flex-direction:row;flex-wrap:nowrap;white-space:nowrap}.yasgui .tabMenu .textSetting .removeButton{border:none;background:transparent;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.yasgui .tabMenu .textSetting .removeButton:hover{background:transparent;border-color:#000;color:#000;cursor:pointer}.yasgui .tabMenu .label{-webkit-text-decoration:#000;text-decoration:#000;font-weight:700;white-space:nowrap;padding-right:5px;align-self:center}.yasgui .autocomplete{padding:3px 6px;margin:4px 0;border:2px solid #ccc;width:100%;box-sizing:border-box;transition:border-color .2s ease-in}.yasgui .autocomplete:hover{border-color:#bbb}.yasgui .autocomplete:focus{border-color:#337ab7;background:none;outline:none}.yasgui .autocompleteWrapper{width:100%;max-width:700px;margin-left:10px;position:relative}.yasgui .autocompleteList{position:absolute;max-height:300px;overflow-y:auto;z-index:6;margin:-4px 0 0;padding:0;list-style:none;background:#fff;border:1px solid #aaa;box-sizing:border-box;left:0;right:0}.yasgui .autocompleteList:hover .autoComplete_result.autoComplete_selected:not(:hover){background:unset}.yasgui .autocompleteList:hover .autoComplete_result.autoComplete_selected:not(:hover) .removeItem{visibility:hidden}.yasgui .autocompleteList .autoComplete_result{cursor:pointer;padding:5px 10px;margin:0;overflow:hidden;display:flex;transition:background visibility .2s ease-in}.yasgui .autocompleteList .autoComplete_result b{color:#1f49a3}.yasgui .autocompleteList .autoComplete_result .autoComplete_highlighted{font-weight:700}.yasgui .autocompleteList .autoComplete_result.autoComplete_selected{background:#ccc}.yasgui .autocompleteList .autoComplete_result.autoComplete_selected .removeItem{visibility:visible}.yasgui .autocompleteList .autoComplete_result:hover{background:#ccc}.yasgui .autocompleteList .autoComplete_result:hover .removeItem{visibility:visible}.yasgui .autocompleteList .noResults{padding:5px 10px;margin:0}.yasgui .autocompleteList .removeItem{color:#000;font-size:15px;text-shadow:0 1px 0 #fff;opacity:.5;font-weight:700;text-align:end;margin-left:auto;visibility:hidden;background:none;border:none;cursor:pointer;margin-right:-10px;padding-right:20px}.yasgui .autocompleteList .removeItem:hover{opacity:.8;color:#1f49a3}.yasgui .autocompleteList:empty{display:none}.yasgui .tabPanel{display:none;position:relative}.yasgui .tabPanel.active{display:block}.yasgui .yasr{margin-top:5px}.yasgui .tabContextButton{border:none;background:none;align-self:center;padding-left:10px;cursor:pointer;color:#505050;fill:#505050}.yasgui .tabContextButton .svgImg{width:15px;height:15px;font-family:initial}.yasgui .tabContextButton svg{max-width:15px;max-height:15px}.yasgui .tabContextButton:hover{color:#000;fill:#000}.yasgui .controlbar{display:flex;align-content:center;max-height:35px}.yasgui.context-menu{position:absolute;z-index:10;background:#fff;min-width:160px;font-size:14px;border:1px solid rgba(0,0,0,.15);border-bottom-right-radius:4px;border-bottom-left-radius:4px;box-shadow:0 6px 12px rgba(0,0,0,.175);background-clip:padding-box}.yasgui.context-menu hr{margin:8px auto;border:none;border-top:1px solid #aaa;border-bottom:1px solid #fff}.yasgui.context-menu .context-menu-list{padding:0}.yasgui.context-menu .context-menu-item{display:block;padding:3px 20px;clear:both;font-weight:400;line-height:1.42857;color:#333;white-space:nowrap;cursor:pointer}.yasgui.context-menu .context-menu-item:hover{text-decoration:none;color:#000;background-color:#f5f5f5}.yasgui.context-menu .context-menu-item.disabled{text-decoration:none;color:grey;background-color:#e5e5e5;cursor:not-allowed}.yasgui .tabsList{display:flex;flex-wrap:wrap}.yasgui .tabsList .sortable-placeholder{min-width:100px;min-height:35px;border:2px dotted #888}.yasgui .tabsList a{cursor:pointer;display:flex;align-items:center;justify-content:center;min-height:35px;border-bottom:2px solid transparent;box-sizing:border-box}.yasgui .tabsList .addTab{cursor:pointer;height:100%;font-size:120%;font-weight:800;margin-left:15px;padding:0 5px 2px;background:inherit;border:none;color:#337ab7}.yasgui .tabsList .addTab:focus-visible,.yasgui .tabsList .addTab:hover{transform:scale(1.1)}.yasgui .tabsList .addTab:focus{color:#faa857}.yasgui .tabsList .tab{position:relative}.yasgui .tabsList .tab .loader{display:none;background-color:#d5d5d5;height:2px;position:absolute;bottom:0;left:0;right:100%;-webkit-animation-name:slide;animation-name:slide;-webkit-animation-duration:2s;animation-duration:2s;-webkit-animation-timing-function:ease;animation-timing-function:ease;-webkit-animation-iteration-count:infinite;animation-iteration-count:infinite}@-webkit-keyframes slide{0%{left:0;right:100%}70%{left:0;right:0}to{left:100%;right:0}}@keyframes slide{0%{left:0;right:100%}70%{left:0;right:0}to{left:100%;right:0}}.yasgui .tabsList .tab.active .loader{background-color:#9fc4e4}.yasgui .tabsList .tab:hover .loader{background-color:#337ab7}.yasgui .tabsList .tab.querying .loader{display:block}.yasgui .tabsList .tab.active a{border-bottom-color:#337ab7;color:#555}.yasgui .tabsList .tab input{display:none;outline:none;border:none}.yasgui .tabsList .tab.renaming .closeTab,.yasgui .tabsList .tab.renaming span{display:none}.yasgui .tabsList .tab.renaming input{display:block}.yasgui .tabsList .tab a{font-weight:600;color:#888;font-size:15px;line-height:1.5rem;font-weight:500;min-width:120px;padding:0 24px 0 30px;white-space:nowrap;overflow:hidden}.yasgui .tabsList .tab a:hover{border-bottom-color:#9fc4e4;color:#555}.yasgui .tabsList .tab a:focus{border-bottom-color:#faa857;color:#555}.yasgui .tabsList .tab a .closeTab{color:#000;margin-left:7px;font-size:15px;text-shadow:0 1px 0 #fff;opacity:.2;font-weight:700;padding:2px}.yasgui .tabsList .tab a .closeTab:hover{opacity:.5}.yasgui a{color:#337ab7;text-decoration:none}.yasgui .yasgui_textfield{display:block;padding-top:18.75px;position:relative}.yasgui .yasgui_textfield>label{position:absolute;top:0;display:block;width:100%;color:rgba(0,0,0,.54);font-size:12px;font-weight:400;line-height:15px;overflow-x:hidden;text-overflow:ellipsis;white-space:nowrap}.yasgui .yasgui_textfield>input,.yasgui .yasgui_textfield>textarea{box-sizing:border-box;display:block;color:rgba(0,0,0,.87);border:none;border-bottom:1px solid rgba(0,0,0,.26);outline:none;width:100%;padding:0;box-shadow:none;border-radius:0;font-size:15px;font-family:inherit;line-height:inherit;background-image:none}.yasgui .yasgui_textfield>input:focus,.yasgui .yasgui_textfield>textarea:focus{border-color:#337ab7;border-width:2px}.yasgui .yasgui_textfield>input:focus~label,.yasgui .yasgui_textfield>textarea:focus~label{color:#337ab7}.modal-dialog.google-visualization-charteditor-dialog{z-index:11;width:auto;margin:inherit}.modal-dialog.google-visualization-charteditor-dialog .charts-flat-menu-button{box-sizing:content-box}

================
File: public/manifest.json
================
// public/manifest.json
{
  "name": "Squirt",
  "short_name": "Squirt",
  "description": "Post information to the web easily with Squirt",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#f9f9f9",
  "theme_color": "#3498db",
  "icons": [
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "share_target": {
    "action": "/",
    "method": "GET",
    "enctype": "application/x-www-form-urlencoded",
    "params": {
      "title": "title",
      "text": "text",
      "url": "url"
    }
  }
}

================
File: public/service-worker.js
================
// public/service-worker.js
const CACHE_NAME = 'squirt-cache-v1';
const urlsToCache = [
  '/',
  '/index.html',
  '/main.bundle.js',
  '/main.*.css',
  '/favicon.ico'
];

// Install service worker and cache static assets
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        console.log('Opened cache');
        return cache.addAll(urlsToCache);
      })
  );
});

// Activate service worker and clean up old caches
self.addEventListener('activate', event => {
  const cacheWhitelist = [CACHE_NAME];
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheWhitelist.indexOf(cacheName) === -1) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// Fetch resources from cache or network
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // Cache hit - return response
        if (response) {
          return response;
        }
        
        // Clone the request because it's a one-time use
        const fetchRequest = event.request.clone();
        
        // Skip non-GET requests like SPARQL POST requests
        if (fetchRequest.method !== 'GET') {
          return fetch(fetchRequest);
        }

        return fetch(fetchRequest).then(
          response => {
            // Check if we received a valid response
            if (!response || response.status !== 200 || response.type !== 'basic') {
              return response;
            }

            // Clone the response because it's a one-time use
            const responseToCache = response.clone();

            caches.open(CACHE_NAME)
              .then(cache => {
                cache.put(event.request, responseToCache);
              });

            return response;
          }
        );
      })
  );
});

================
File: src/css/form-styles.css
================
/* src/css/form-styles.css - Improved responsive form styles */
.form-field {
  margin-bottom: var(--spacing-md);
}

.form-field label {
  display: block;
  margin-bottom: var(--spacing-xs);
  font-weight: 500;
  color: var(--text-color);
}

.form-field input,
.form-field textarea,
.form-field select {
  width: 100%;
  padding: var(--spacing-sm) var(--spacing-md);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  background: var(--card-background);
  color: var(--text-color);
  font-size: 1rem;
  font-family: inherit;
  transition: border-color 0.2s, box-shadow 0.2s;
}

.form-field textarea {
  min-height: 120px;
  resize: vertical;
}

.form-field input:focus,
.form-field textarea:focus,
.form-field select:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
}

button[type="submit"],
.button-primary {
  display: inline-block;
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: var(--border-radius);
  padding: var(--spacing-sm) var(--spacing-lg);
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s;
  text-align: center;
}

button[type="submit"]:hover,
.button-primary:hover {
  background-color: var(--secondary-color);
}

/* Post form specific styles */
#post-form {
  background: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow);
}

.form-fields {
  margin-top: var(--spacing-md);
}

/* Input with button combination */
.input-with-button {
  display: flex;
  gap: var(--spacing-sm);
  flex-direction: column;
}

/* Extract button */
.extract-button {
  padding: var(--spacing-sm) var(--spacing-md);
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: var(--border-radius);
  cursor: pointer;
  font-size: 0.875rem;
  transition: background-color 0.2s;
}

.extract-button:hover {
  background-color: var(--secondary-color);
}

.extract-button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

/* Link preview */
.link-preview {
  margin-top: var(--spacing-md);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  overflow: hidden;
  background: var(--card-background);
}

.preview-card {
  display: flex;
  flex-direction: column;
  max-width: 100%;
}

.preview-image {
  width: 100%;
  max-height: 200px;
  overflow: hidden;
}

.preview-image img {
  width: 100%;
  height: auto;
  object-fit: cover;
}

.preview-content {
  padding: var(--spacing-md);
}

.preview-title {
  margin: 0 0 var(--spacing-sm) 0;
  font-size: 1.25rem;
  color: var(--text-color);
}

.preview-description {
  margin: 0 0 var(--spacing-sm) 0;
  font-size: 0.875rem;
  color: var(--text-color);
  opacity: 0.8;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.preview-site {
  font-size: 0.75rem;
  color: var(--text-color);
  opacity: 0.6;
}

#post-preview {
  margin-top: var(--spacing-lg);
}

/* Notification styles */
.notifications-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1000;
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-width: 300px;
  pointer-events: none;
}

.notification {
  padding: 10px 15px;
  border-radius: var(--border-radius);
  color: white;
  box-shadow: var(--shadow);
  animation: notification-slide-in 0.3s ease-out;
  position: relative;
  overflow: hidden;
  pointer-events: auto;
}

.notification::before {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 3px;
  background: rgba(255, 255, 255, 0.5);
  animation: notification-timer 5s linear forwards;
}

.notification.success {
  background-color: var(--success-color);
}

.notification.error {
  background-color: var(--error-color);
}

.notification.info {
  background-color: var(--primary-color);
}

.notification.warning {
  background-color: #ed8936;
}

.notification.fade-out {
  opacity: 0;
  transform: translateX(100%);
  transition: opacity 0.3s, transform 0.3s;
}

@keyframes notification-slide-in {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes notification-timer {
  from {
    width: 100%;
  }
  to {
    width: 0%;
  }
}

/* Wiki editor styles */
.wiki-editor {
  background: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow);
  margin-bottom: var(--spacing-lg);
}

.wiki-preview {
  margin-top: var(--spacing-lg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: var(--spacing-lg);
  background: var(--card-background);
}

.preview-content {
  max-width: 100%;
  overflow-x: auto;
}

.wiki-entries {
  margin-top: var(--spacing-lg);
}

.editor-toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-xs);
  margin-bottom: var(--spacing-sm);
  padding: var(--spacing-sm);
  background: rgba(0, 0, 0, 0.05);
  border-radius: var(--border-radius);
}

/* Media queries for form responsiveness */
@media (min-width: 768px) {
  .input-with-button {
    flex-direction: row;
  }
  
  .extract-button {
    flex-shrink: 0;
  }
  
  .preview-card {
    flex-direction: row;
  }
  
  .preview-image {
    width: 200px;
    max-height: none;
  }
  
  .preview-content {
    flex: 1;
  }
  
  .storage-actions {
    display: flex;
    gap: var(--spacing-md);
  }
}

================
File: src/css/layout-fixes.css
================
/* src/css/layout-fixes.css - Layout fixes for desktop view and YASGUI component */

/* Fix for YASGUI container to show full results */
.yasgui-container {
  width: 100%;
  height: 700px;
  margin-top: var(--spacing-md);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  overflow: hidden;
}

/* Ensure the YASGUI component fills its container */
.yasgui {
  width: 100% !important;
  height: 100% !important;
}

/* Fix YASGUI results panel */
.yasgui .yasr {
  height: 60% !important;
  overflow: auto !important;
}

/* Fix YASGUI query editor */
.yasgui .yasqe {
  height: 40% !important;
}

.yasgui .yasqe .CodeMirror {
  height: 100% !important;
}

/* Fix markdown editor alignment */
.wiki-editor {
  margin-bottom: var(--spacing-lg);
  background: var(--card-background);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow);
}

/* ===== CodeMirror Fixes ===== */
/* These specific overrides fix the horizontal scrollbar issues */

/* Main container fixes */
.CodeMirror {
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  height: auto !important;
  min-height: 200px;
  font-family: monospace;
  line-height: 1.5;
  overflow: hidden !important;
}

/* Fix the scroll container that causes the middle scrollbar */
.CodeMirror-scroll {
  margin-bottom: 0 !important;
  margin-right: 0 !important;
  padding-bottom: 0 !important;
  padding-right: 0 !important;
  overflow-x: hidden !important;
  /* Important override to prevent the 50px offset that causes the scrollbar */
  height: auto !important;
}

/* Ensure sizer doesn't create overflow */
.CodeMirror-sizer {
  margin-bottom: 0 !important;
  border-right-width: 0 !important;
}

/* Prevent scrollbars */
.CodeMirror-hscrollbar,
.CodeMirror-vscrollbar,
.CodeMirror-scrollbar-filler,
.CodeMirror-gutter-filler {
  display: none !important;
}

/* Force text wrapping in CodeMirror */
.CodeMirror-wrap pre.CodeMirror-line,
.CodeMirror-wrap pre.CodeMirror-line-like {
  word-wrap: break-word !important;
  white-space: pre-wrap !important;
  word-break: normal !important;
}

/* Ensure container knows to enable wrapping */
.CodeMirror-wrap {
  word-wrap: break-word !important;
}

/* Make editor toolbar more consistent */
.editor-toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
  margin-bottom: 10px;
  background: rgba(0, 0, 0, 0.05);
  border-radius: 4px;
  padding: 5px;
}

/* Fix preview panel alignment */
.wiki-preview {
  margin-top: var(--spacing-lg);
  padding: var(--spacing-md);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  background: var(--card-background);
}

/* Fix wiki entries styling */
.wiki-entries {
  margin-top: var(--spacing-lg);
}

.entry-item {
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  background: var(--card-background);
}

/* Better desktop spacing */
@media (min-width: 1024px) {
  .yasgui-container {
    height: 800px;
  }
  
  .CodeMirror {
    min-height: 300px;
  }
  
  /* Fix desktop layout for markdown editors */
  main {
    max-width: 1200px;
    padding: var(--spacing-xl);
  }
  
  .view {
    padding: var(--spacing-xl);
  }
}

/* Fix editor content overflow */
.form-field textarea, 
.wiki-editor .form-field textarea {
  max-width: 100%;
  width: 100%;
  box-sizing: border-box;
}

================
File: src/css/mobile-fixes.css
================
/* Additional Mobile Layout Improvements */

/* Responsive layout for YASGUI component */
.yasgui-container {
  min-height: 300px; /* Smaller on mobile */
}

/* Improved form spacing on mobile */
@media (max-width: 767px) {
  .view {
    padding: var(--spacing-md);
  }
  
  #post-form {
    padding: var(--spacing-md);
  }
  
  .hamburger-menu {
    display: block;
    position: absolute;
    top: var(--spacing-md);
    right: var(--spacing-md);
    z-index: 101;
  }
  
  h2 {
    font-size: 1.5rem;
    margin-bottom: var(--spacing-md);
  }
  
  /* Ensure forms are mobile-friendly */
  button[type="submit"],
  .button-primary {
    width: 100%;
    margin-top: var(--spacing-sm);
  }
  
  /* Adjust endpoint actions on mobile */
  .endpoint-actions {
    margin-top: var(--spacing-sm);
  }
  
  /* Adjust navigation when visible on mobile */
  nav.visible {
    border-top: 1px solid var(--border-color);
    padding-top: var(--spacing-sm);
  }
  
  /* Storage section buttons on mobile */
  .storage-actions {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm);
  }
  
  /* Better spacing for wiki editor on mobile */
  .wiki-editor {
    padding: var(--spacing-md);
  }
  
  .editor-toolbar {
    gap: 2px;
    justify-content: center;
  }
  
  /* Fix notification container position on mobile */
  .notifications-container {
    top: 10px;
    right: 10px;
    left: 10px;
    max-width: none;
  }
}

/* Medium screens */
@media (min-width: 768px) and (max-width: 1023px) {
  /* Two-column grid for dashboard on medium screens */
  .dashboard-grid {
    grid-template-columns: repeat(2, 1fr);
  }
  
  /* Adjust YASGUI height for medium screens */
  .yasgui-container {
    min-height: 400px;
  }
  
  /* Better padding for medium screens */
  .view {
    padding: var(--spacing-lg);
  }
  
  /* Header layout for medium screens */
  header {
    display: flex;
    flex-direction: column;
  }
  
  nav {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
  }
}

/* All screen sizes - improve contrast for form elements */
.form-field input::placeholder,
.form-field textarea::placeholder {
  opacity: 0.6;
}

/* Improve active state for all interactive elements */
button:active,
.button-primary:active,
input[type="submit"]:active {
  transform: translateY(1px);
}

/* Fix layout when keyboard is visible on mobile */
@media (max-height: 450px) and (max-width: 767px) {
  header {
    position: static;
  }
  
  main {
    padding-top: var(--spacing-sm);
  }
}

/* Print styles - hide unnecessary elements when printing */
@media print {
  header,
  nav,
  .hamburger-menu,
  .notifications-container,
  button {
    display: none !important;
  }
  
  main {
    padding: 0;
    margin: 0;
  }
  
  .view {
    box-shadow: none;
    padding: 0;
  }
}

================
File: src/css/styles.css
================
/* src/css/styles.css - Main application styles with improved responsive layout */
:root {
  --primary-color: #3498db;
  --secondary-color: #2980b9;
  --error-color: #e74c3c;
  --success-color: #2ecc71;
  --background-color: #f9f9f9;
  --card-background: #ffffff;
  --text-color: #2c3e50;
  --border-color: #e1e1e1;
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;
  --spacing-xl: 2rem;
  --border-radius: 8px;
  --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

/* Dark theme variables */
[data-theme="dark"] {
  --primary-color: #3498db;
  --secondary-color: #2980b9;
  --error-color: #e74c3c;
  --success-color: #2ecc71;
  --background-color: #1a1a1a;
  --card-background: #2c2c2c;
  --text-color: #f9f9f9;
  --border-color: #444444;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  line-height: 1.6;
  background: var(--background-color);
  color: var(--text-color);
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

header {
  background: var(--card-background);
  padding: var(--spacing-md);
  box-shadow: var(--shadow);
  position: sticky;
  top: 0;
  z-index: 100;
}

header h1 {
  font-size: 1.5rem;
  margin-bottom: var(--spacing-sm);
}

nav {
  display: none; /* Hidden by default on mobile */
  flex-direction: column;
  gap: var(--spacing-xs);
  margin-top: var(--spacing-sm);
}

nav.visible {
  display: flex;
}

nav a {
  color: var(--text-color);
  text-decoration: none;
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius);
  transition: background-color 0.2s, color 0.2s;
}

nav a:hover, nav a.active {
  background: var(--primary-color);
  color: white;
}

main {
  flex: 1;
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: var(--spacing-md);
}

.view {
  background: var(--card-background);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow);
  padding: var(--spacing-lg);
  margin-bottom: var(--spacing-lg);
}

.hidden {
  display: none;
}

/* Settings Styles */
.settings-section {
  background: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow);
  margin-bottom: var(--spacing-lg);
}

.settings-section h3 {
  margin-top: 0;
  margin-bottom: var(--spacing-md);
  color: var(--text-color);
  border-bottom: 1px solid var(--border-color);
  padding-bottom: var(--spacing-sm);
}

.endpoint-item {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
  padding: var(--spacing-md);
  border-bottom: 1px solid var(--border-color);
}

.endpoint-header {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.endpoint-url {
  font-size: 0.875rem;
  color: var(--text-color);
  opacity: 0.7;
  margin-top: var(--spacing-xs);
  word-break: break-all;
}

.endpoint-status {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #999;
  transition: background-color 0.3s ease;
  flex-shrink: 0;
}

.endpoint-status.checking {
  animation: pulse 1.5s infinite;
  background: var(--primary-color);
}

.endpoint-status.active {
  background: var(--success-color);
}

.endpoint-status.inactive {
  background: var(--error-color);
}

.endpoint-label[contenteditable] {
  padding: var(--spacing-xs);
  border-radius: 4px;
}

.endpoint-label[contenteditable]:focus {
  outline: 2px solid var(--primary-color);
  background: var(--card-background);
}

.endpoint-actions {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-sm);
}

.endpoint-actions button {
  padding: var(--spacing-xs) var(--spacing-sm);
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

#endpoint-form {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--spacing-sm);
  margin-top: var(--spacing-md);
}

@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.4; }
  100% { opacity: 1; }
}

/* YASGUI specific styles */
.yasgui-container {
  width: 100%;
  height: 500px;
  margin-top: var(--spacing-md);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  overflow: hidden;
}

/* Hamburger menu */
.hamburger-menu {
  display: block;
  position: absolute;
  top: var(--spacing-md);
  right: var(--spacing-md);
}

.hamburger-button {
  background: transparent;
  border: none;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  height: 24px;
  width: 30px;
  padding: 0;
}

.hamburger-button span {
  background-color: var(--text-color);
  border-radius: 3px;
  display: block;
  height: 3px;
  transition: all 0.3s ease;
  width: 100%;
}

.hamburger-menu.active .hamburger-button span:nth-child(1) {
  transform: translateY(10px) rotate(45deg);
}

.hamburger-menu.active .hamburger-button span:nth-child(2) {
  opacity: 0;
}

.hamburger-menu.active .hamburger-button span:nth-child(3) {
  transform: translateY(-10px) rotate(-45deg);
}

/* Header layout */
.header-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/* Dashboard grid layout for when we have multiple components */
.dashboard-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--spacing-lg);
}

/* Storage management section */
.storage-section {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

.storage-section button {
  padding: var(--spacing-sm) var(--spacing-md);
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: var(--border-radius);
  cursor: pointer;
  transition: background-color 0.2s;
}

.storage-section button:hover {
  background: var(--secondary-color);
}

.storage-section button.danger {
  background: var(--error-color);
}

#storage-usage {
  padding: var(--spacing-md);
  background: rgba(0, 0, 0, 0.05);
  border-radius: var(--border-radius);
}

/* Media Queries for responsive design */
@media (min-width: 768px) {
  header h1 {
    font-size: 1.75rem;
  }
  
  .hamburger-menu {
    display: none;
  }
  
  nav {
    display: flex;
    flex-direction: row;
    margin-top: 0;
  }
  
  .endpoint-item {
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
  }
  
  #endpoint-form {
    grid-template-columns: 1fr 2fr auto;
  }
  
  .dashboard-grid {
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  }
  
  .yasgui-container {
    height: 600px;
  }
}

@media (min-width: 1024px) {
  header {
    padding: var(--spacing-md) var(--spacing-xl);
  }
  
  main {
    padding: var(--spacing-xl);
  }
  
  header h1 {
    font-size: 2rem;
  }
  
  .view {
    padding: var(--spacing-xl);
  }
  
  .yasgui-container {
    height: 700px;
  }
}

================
File: src/css/yasgui-styles.css
================
/* src/css/yasgui-styles.css */
/* Container for YASGUI component */
.yasgui-container {
  width: 100%;
  height: 600px;
  margin-top: 1rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
}

/* Initialization button container */
.yasgui-init {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
}

.yasgui-init button {
  padding: 12px 24px;
  font-size: 16px;
  background-color: var(--primary-color, #3498db);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  transition: background-color 0.2s;
}

.yasgui-init button:hover {
  background-color: #2980b9;
}

/* Error message */
.error-message {
  padding: 15px;
  color: #721c24;
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 4px;
  margin: 10px 0;
}

/* YASGUI specific styles */
.yasgui {
  width: 100% !important;
  height: 600px !important;
}

/* Query editor styles */
.yasgui .yasqe {
  height: 40% !important;
}

.yasgui .yasqe .CodeMirror {
  height: 100% !important;
}

/* Results area styles */
.yasgui .yasr {
  height: 60% !important;
}

/* Tab panel sizing */
.yasgui .tabPanel {
  height: 100% !important;
}

/* Ensure buttons have correct theme */
.yasgui button.btn-primary {
  background-color: var(--primary-color, #3498db);
  border-color: var(--primary-color, #3498db);
}

.yasgui button.btn-primary:hover {
  background-color: #2980b9;
  border-color: #2980b9;
}

/* Make results tables more readable */
.yasgui .yasr_results table {
  margin: 1em 0;
  border-collapse: collapse;
  width: 100%;
}

.yasgui .yasr_results table th,
.yasgui .yasr_results table td {
  border: 1px solid #ddd;
  padding: 8px;
}

.yasgui .yasr_results table tr:nth-child(even) {
  background-color: #f2f2f2;
}

.yasgui .yasr_results table th {
  padding-top: 12px;
  padding-bottom: 12px;
  text-align: left;
  background-color: var(--primary-color, #3498db);
  color: white;
}

================
File: src/html/index.html
================
<!-- src/html/index.html - Improved responsive layout structure -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Post information to the web easily with Squirt">
    <meta name="theme-color" content="#3498db">
    <title>Squirt</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    
    <!-- PWA manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- iOS PWA support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Squirt">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon.png">
</head>

<body>
    <header>
        <div class="header-container">
            <h1>Squirt</h1>
            <div class="hamburger-menu">
                <button class="hamburger-button" aria-label="Menu">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
        </div>
        <nav>
            <a href="#" data-view="post-view">Post</a>
            <a href="#" data-view="wiki-view">Wiki</a>
            <a href="#" data-view="yasgui-view">SPARQL</a>
            <a href="#" data-view="developer-view">Developer</a>
            <a href="#" data-view="profile-view">Profile</a>
            <a href="#" data-view="settings-view">Settings</a>
        </nav>
    </header>
    
    <main>
        <!-- Post View -->
        <div id="post-view" class="view">
            <h2>Create Post</h2>
            <form id="post-form" class="form-group">
                <div class="form-field">
                    <label for="post-type">Post Type</label>
                    <select id="post-type" name="post-type" required>
                        <option value="entry">Entry</option>
                        <option value="link" selected>Link</option>
                    </select>
                </div>
                
                <!-- Static form fields for Link type -->
                <div class="form-fields">
                    <div class="form-field">
                        <label for="url">URL</label>
                        <div class="input-with-button">
                            <input type="url" id="url" name="url" placeholder="https://example.com" required>
                            <button type="button" id="extract-metadata" class="extract-button">Extract</button>
                        </div>
                    </div>
                    
                    <div class="form-field">
                        <label for="title">Title</label>
                        <input type="text" id="title" name="title" placeholder="Enter a title">
                    </div>
                    
                    <div class="form-field">
                        <label for="content">Content</label>
                        <textarea id="content" name="content" rows="5" placeholder="Enter your content here..."></textarea>
                    </div>
                    
                    <div class="form-field">
                        <label for="tags">Tags (comma separated)</label>
                        <input type="text" id="tags" name="tags" placeholder="tag1, tag2, tag3">
                    </div>
                </div>
                
                <button type="submit" class="button-primary">Post</button>
            </form>
            
            <div id="post-preview"></div>
        </div>

        <!-- Wiki View -->
        <div id="wiki-view" class="view hidden">
            <h2>Wiki</h2>
            <div class="wiki-editor">
                <div class="form-field">
                    <label for="wiki-title">Title</label>
                    <input type="text" id="wiki-title" name="title" required>
                </div>
                <div class="form-field">
                    <label for="wiki-content">Content (Markdown supported)</label>
                    <textarea id="wiki-content" name="content" rows="10" required></textarea>
                </div>
                <div class="form-field">
                    <label for="wiki-tags">Tags (comma separated)</label>
                    <input type="text" id="wiki-tags" name="tags" placeholder="tag1, tag2, tag3">
                </div>
                <button type="button" id="save-wiki" class="button-primary">Save</button>
            </div>
            <div class="wiki-entries"></div>
        </div>

        <div id="yasgui-view" class="view hidden">
            <h2>SPARQL Query Editor</h2>
            <div id="yasgui-container" class="yasgui-container"></div>
        </div>
        
        <!-- Developer View -->
        <div id="developer-view" class="view hidden">
            <h2>Developer Tools</h2>
            <div class="developer-section">
                <h3>SPARQL Query</h3>
                <div class="form-field">
                    <textarea id="sparql-query" rows="10" placeholder="Enter SPARQL query..."></textarea>
                </div>
                <button type="button" id="run-query" class="button-primary">Run Query</button>
                <div id="query-results" class="results-container"></div>
            </div>
        </div>

        <!-- Profile View -->
        <div id="profile-view" class="view hidden">
            <h2>Profile</h2>
            <form id="profile-form" class="form-group">
                <div class="form-field">
                    <label for="profile-name">Name</label>
                    <input type="text" id="profile-name" name="name">
                </div>
                <div class="form-field">
                    <label for="profile-email">Email</label>
                    <input type="email" id="profile-email" name="email">
                </div>
                <div class="form-field">
                    <label for="profile-bio">Bio</label>
                    <textarea id="profile-bio" name="bio" rows="5"></textarea>
                </div>
                <button type="submit" class="button-primary">Save Profile</button>
            </form>
        </div>

        <!-- Settings View -->
        <div id="settings-view" class="view hidden">
            <h2>Settings</h2>
            
            <div class="dashboard-grid">
                <!-- Appearance Section -->
                <div class="settings-section">
                    <h3>Appearance</h3>
                    <div class="form-field">
                        <label for="theme-selector">Theme</label>
                        <select id="theme-selector">
                            <option value="light">Light</option>
                            <option value="dark">Dark</option>
                            <option value="system">System Preference</option>
                        </select>
                    </div>
                </div>
                
                <!-- Endpoints Section -->
                <div class="settings-section">
                    <h3>SPARQL Endpoints</h3>
                    <div id="endpoints-list"></div>
                    <form id="endpoint-form" class="form-group">
                        <input type="text" id="endpoint-label" placeholder="Endpoint Label" required>
                        <input type="url" id="endpoint-url" placeholder="Enter SPARQL endpoint URL" required>
                        <button type="submit" class="button-primary">Add</button>
                    </form>
                </div>
                
                <!-- Storage Section -->
                <div class="settings-section storage-section">
                    <h3>Storage</h3>
                    <div id="storage-usage">Calculating storage usage...</div>
                    <div class="storage-actions">
                        <button id="export-data" class="button-primary">Export Data</button>
                        <button id="import-data" class="button-primary">Import Data</button>
                        <button id="clear-data" class="button-primary danger">Clear All Data</button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Notifications Container -->
    <div class="notifications-container"></div>
</body>

</html>

================
File: src/js/core/errors.js
================
/**
 * Custom application error class with additional details
 */
export class AppError extends Error {
    constructor(message, code, details = {}) {
        super(message);
        this.name = 'AppError';
        this.code = code;
        this.details = details;
    }
}

/**
 * SPARQL-specific error class
 */
export class SparqlError extends AppError {
    constructor(message, details = {}) {
        super(message, 'SPARQL_ERROR', details);
        this.name = 'SparqlError';
    }
}

/**
 * Network error class
 */
export class NetworkError extends AppError {
    constructor(message, details = {}) {
        super(message, 'NETWORK_ERROR', details);
        this.name = 'NetworkError';
    }
}

/**
 * Error handler for centralized error management
 */
export const ErrorHandler = {
    /**
     * Handle an error by logging it and optionally displaying a user-friendly message
     * @param {Error} error - The error to handle
     * @param {boolean} showToUser - Whether to show the error to the user
     */
    handle(error, showToUser = true) {
        console.error('Error:', error);
        
        // Determine if error should be shown to user
        if (showToUser) {
            // Use notification system if available
            if (typeof window.showNotification === 'function') {
                window.showNotification(this.getUserFriendlyMessage(error), 'error');
            } else {
                console.warn(this.getUserFriendlyMessage(error));
            }
        }
        
        // Track error for analytics
        this.trackError(error);
    },

    /**
     * Get a user-friendly error message
     * @param {Error} error - The error object
     * @returns {string} A user-friendly error message
     */
    getUserFriendlyMessage(error) {
        // Handle specific error types
        if (error instanceof SparqlError) {
            return 'SPARQL endpoint error. Please check your endpoint settings.';
        }
        
        if (error instanceof NetworkError) {
            return 'Network error. Please check your connection and try again.';
        }
        
        if (error instanceof AppError) {
            return error.message;
        }
        
        // Generic error checking by name/message
        if (error.name === 'NetworkError' || error.message.includes('network') || error.message.includes('fetch')) {
            return 'Network error. Please check your connection and try again.';
        }
        
        if (error.name === 'SyntaxError' || error.message.includes('syntax')) {
            return 'There was a syntax error in the request. Please try again.';
        }
        
        if (error.message.includes('endpoint') || error.message.includes('SPARQL')) {
            return 'SPARQL endpoint error. Please check your endpoint settings.';
        }
        
        // For security, don't expose detailed error messages to the user
        return error.userMessage || 'An error occurred. Please try again.';
    },
    
    /**
     * Track errors for analytics
     * @param {Error} error - The error to track
     */
    trackError(error) {
        // Basic implementation - can be expanded to send to a real analytics service
        if (window.errorLog === undefined) {
            window.errorLog = [];
        }
        
        window.errorLog.push({
            timestamp: new Date().toISOString(),
            message: error.message,
            stack: error.stack,
            type: error.name
        });
    },
    
    /**
     * Create a custom error with a user-friendly message
     * @param {string} message - Technical error message
     * @param {string} userMessage - User-friendly error message
     * @param {string} code - Error code
     * @returns {AppError} Custom error object
     */
    createError(message, userMessage, code = 'APP_ERROR') {
        const error = new AppError(message, code);
        error.userMessage = userMessage;
        return error;
    }
};

================
File: src/js/core/state.js
================
export class StateManager {
    constructor() {
        this.state = {
            endpoints: [],
            currentView: null,
            user: null,
            posts: [],
            drafts: []
        };
        this.listeners = new Map();
    }

    subscribe(key, callback) {
        if (!this.listeners.has(key)) {
            this.listeners.set(key, new Set());
        }
        this.listeners.get(key).add(callback);
    }

    update(key, value) {
        this.state[key] = value;
        if (this.listeners.has(key)) {
            this.listeners.get(key).forEach(callback => callback(value));
        }
    }

    get(key) {
        return this.state[key];
    }
}

export const state = new StateManager();

================
File: src/js/core/views.js
================
/**
 * Application views definition
 * Centralized to avoid circular dependencies
 */
export const VIEWS = {
  POST: 'post-view',
  DEVELOPER: 'developer-view',
  WIKI: 'wiki-view',
  YASGUI: 'yasgui-view',
  PROFILE: 'profile-view',
  SETTINGS: 'settings-view'
};

================
File: src/js/services/rdf/rdf-extractor.js
================
import rdf from 'rdf-ext';
import { generateNid } from '../../utils/utils.js';
import { namespaces } from '../../utils/utils.js';

export class RDFFormExtractor {
  constructor() {
    this.dataset = rdf.dataset();
  }

  async extract(form) {
    const formData = new FormData(form);
    const subject = rdf.namedNode(generateNid(formData.get('title')));

    for (const element of form.elements) {
      if (!element.name) continue;

      const predicate = rdf.namedNode(element.dataset.namespace + element.dataset.term);
      const object = this.createObject(element);

      if (object) {
        this.dataset.add(rdf.quad(subject, predicate, object));
      }
    }

    // Add type and timestamp
    const type = rdf.namedNode('http://purl.org/stuff/squirt/' + form.dataset.type);
    const now = new Date().toISOString();

    this.dataset.add(rdf.quad(
      subject,
      rdf.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
      type
    ));

    this.dataset.add(rdf.quad(
      subject,
      rdf.namedNode('http://purl.org/dc/terms/created'),
      rdf.literal(now, rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
    ));

    return this.dataset;
  }

  createObject(element) {
    const value = element.value.trim();
    if (!value) return null;

    switch (element.type) {
      case 'url':
        return rdf.namedNode(value);
      case 'number':
        return rdf.literal(value, rdf.namedNode('http://www.w3.org/2001/XMLSchema#decimal'));
      default:
        return rdf.literal(value);
    }
  }
}

/**
 * Extract metadata from a URL and create an RDF dataset
 * @param {string} url - The URL to extract metadata from
 * @returns {Promise<Object>} - Object containing dataset and metadata
 */
export async function extractFromUrl(url) {
  try {
    const metadata = await extractMetadataFromUrl(url);
    return {
      metadata,
      dataset: createDatasetFromMetadata(metadata)
    };
  } catch (error) {
    console.error('Error extracting from URL:', error);
    throw error;
  }
}

/**
 * Convert metadata to RDF dataset
 * @param {Object} metadata - The metadata object
 * @returns {Dataset} - RDF dataset
 */
export function createDatasetFromMetadata(metadata) {
  const dataset = rdf.dataset();
  const subject = rdf.namedNode(generateNid(metadata.url));
  
  // Add type - default to "link" type
  dataset.add(rdf.quad(
    subject,
    rdf.namedNode(namespaces.rdf + 'type'),
    rdf.namedNode(namespaces.squirt + 'link')
  ));
  
  // Add URL
  if (metadata.url) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.squirt + 'url'),
      rdf.namedNode(metadata.url)
    ));
  }
  
  // Add title
  if (metadata.title) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.dc + 'title'),
      rdf.literal(metadata.title)
    ));
  }
  
  // Add description
  if (metadata.description) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.dc + 'description'),
      rdf.literal(metadata.description)
    ));
  }
  
  // Add image
  if (metadata.image) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.squirt + 'image'),
      rdf.namedNode(metadata.image)
    ));
  }
  
  // Add site name
  if (metadata.siteName) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.squirt + 'siteName'),
      rdf.literal(metadata.siteName)
    ));
  }
  
  // Add author
  if (metadata.author) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.dc + 'creator'),
      rdf.literal(metadata.author)
    ));
  }
  
  // Add date
  if (metadata.date) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.dc + 'date'),
      rdf.literal(metadata.date, rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
    ));
  }
  
  // Add tags
  if (metadata.tags && Array.isArray(metadata.tags)) {
    metadata.tags.forEach(tag => {
      dataset.add(rdf.quad(
        subject,
        rdf.namedNode(namespaces.squirt + 'tag'),
        rdf.literal(tag)
      ));
    });
  }
  
  // Add creation timestamp
  const now = new Date().toISOString();
  dataset.add(rdf.quad(
    subject,
    rdf.namedNode(namespaces.dc + 'created'),
    rdf.literal(now, rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
  ));
  
  return dataset;
}

/**
 * Extract metadata from a URL
 * @param {string} url - The URL to extract metadata from
 * @returns {Promise<Object>} - The extracted metadata
 */
export async function extractMetadataFromUrl(url) {
  try {
    // Basic validation
    if (!url) {
      throw new Error('URL is required');
    }
    
    // Use a proxy or CORS-enabled service if needed
    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
    
    const response = await fetch(proxyUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch URL: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    const html = data.contents;
    
    // Parse the HTML using DOMParser
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    // Extract metadata
    const metadata = {
      url: url,
      title: extractTitle(doc),
      description: extractDescription(doc),
      image: extractImage(doc, url),
      siteName: extractSiteName(doc),
      type: extractType(doc),
      date: extractDate(doc),
      author: extractAuthor(doc),
      tags: extractTags(doc)
    };
    
    return metadata;
  } catch (error) {
    console.error('Error extracting metadata:', error);
    // Return basic metadata with the URL only as fallback
    return {
      url: url,
      title: extractBasicTitleFromUrl(url),
      error: error.message
    };
  }
}

/**
 * Extract title from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted title
 */
function extractTitle(doc) {
  // Try Open Graph title first
  const ogTitle = doc.querySelector('meta[property="og:title"]');
  if (ogTitle) {
    return ogTitle.getAttribute('content');
  }
  
  // Try Twitter title
  const twitterTitle = doc.querySelector('meta[name="twitter:title"]');
  if (twitterTitle) {
    return twitterTitle.getAttribute('content');
  }
  
  // Fall back to document title
  const docTitle = doc.querySelector('title');
  if (docTitle && docTitle.textContent) {
    return docTitle.textContent.trim();
  }
  
  // Fall back to first h1
  const h1 = doc.querySelector('h1');
  if (h1 && h1.textContent) {
    return h1.textContent.trim();
  }
  
  return '';
}

/**
 * Extract description from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted description
 */
function extractDescription(doc) {
  // Try Open Graph description
  const ogDesc = doc.querySelector('meta[property="og:description"]');
  if (ogDesc) {
    return ogDesc.getAttribute('content');
  }
  
  // Try Twitter description
  const twitterDesc = doc.querySelector('meta[name="twitter:description"]');
  if (twitterDesc) {
    return twitterDesc.getAttribute('content');
  }
  
  // Try meta description
  const metaDesc = doc.querySelector('meta[name="description"]');
  if (metaDesc) {
    return metaDesc.getAttribute('content');
  }
  
  return '';
}

/**
 * Extract image from document
 * @param {Document} doc - The HTML document
 * @param {string} baseUrl - The base URL for resolving relative URLs
 * @returns {string} - The extracted image URL
 */
function extractImage(doc, baseUrl) {
  // Try Open Graph image
  const ogImage = doc.querySelector('meta[property="og:image"]');
  if (ogImage) {
    const imageSrc = ogImage.getAttribute('content');
    return resolveUrl(imageSrc, baseUrl);
  }
  
  // Try Twitter image
  const twitterImage = doc.querySelector('meta[name="twitter:image"]');
  if (twitterImage) {
    const imageSrc = twitterImage.getAttribute('content');
    return resolveUrl(imageSrc, baseUrl);
  }
  
  // Try to find a prominent image
  const articleImage = doc.querySelector('article img, .content img, .post img');
  if (articleImage) {
    const imageSrc = articleImage.getAttribute('src');
    return resolveUrl(imageSrc, baseUrl);
  }
  
  return '';
}

/**
 * Extract site name from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted site name
 */
function extractSiteName(doc) {
  // Try Open Graph site name
  const ogSite = doc.querySelector('meta[property="og:site_name"]');
  if (ogSite) {
    return ogSite.getAttribute('content');
  }
  
  // Try schema.org WebSite name
  const schemaWebsite = doc.querySelector('[itemtype="http://schema.org/WebSite"] [itemprop="name"]');
  if (schemaWebsite) {
    return schemaWebsite.textContent.trim();
  }
  
  return '';
}

/**
 * Extract content type from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted type
 */
function extractType(doc) {
  // Try Open Graph type
  const ogType = doc.querySelector('meta[property="og:type"]');
  if (ogType) {
    return ogType.getAttribute('content');
  }
  
  // Try schema.org type
  const schemaType = doc.querySelector('[itemtype]');
  if (schemaType) {
    const type = schemaType.getAttribute('itemtype');
    return type.replace('http://schema.org/', '');
  }
  
  return 'website';
}

/**
 * Extract published date from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted date
 */
function extractDate(doc) {
  // Try published date meta
  const metaDate = doc.querySelector('meta[property="article:published_time"]');
  if (metaDate) {
    return metaDate.getAttribute('content');
  }
  
  // Try schema.org date published
  const schemaDate = doc.querySelector('[itemprop="datePublished"]');
  if (schemaDate) {
    return schemaDate.getAttribute('content') || schemaDate.textContent.trim();
  }
  
  // Try looking for a time element
  const timeElement = doc.querySelector('time');
  if (timeElement) {
    return timeElement.getAttribute('datetime') || timeElement.textContent.trim();
  }
  
  return '';
}

/**
 * Extract author from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted author
 */
function extractAuthor(doc) {
  // Try meta author
  const metaAuthor = doc.querySelector('meta[name="author"]');
  if (metaAuthor) {
    return metaAuthor.getAttribute('content');
  }
  
  // Try Open Graph article author
  const ogAuthor = doc.querySelector('meta[property="article:author"]');
  if (ogAuthor) {
    return ogAuthor.getAttribute('content');
  }
  
  // Try schema.org author
  const schemaAuthor = doc.querySelector('[itemprop="author"] [itemprop="name"]');
  if (schemaAuthor) {
    return schemaAuthor.textContent.trim();
  }
  
  // Try basic byline patterns
  const byline = doc.querySelector('.byline, .author');
  if (byline) {
    return byline.textContent.trim().replace(/^By\s+/i, '');
  }
  
  return '';
}

/**
 * Extract tags/keywords from document
 * @param {Document} doc - The HTML document
 * @returns {string[]} - The extracted tags
 */
function extractTags(doc) {
  const tags = [];
  
  // Try meta keywords
  const metaKeywords = doc.querySelector('meta[name="keywords"]');
  if (metaKeywords) {
    const keywordsStr = metaKeywords.getAttribute('content');
    if (keywordsStr) {
      tags.push(...keywordsStr.split(',').map(tag => tag.trim()));
    }
  }
  
  // Try article:tag
  const articleTags = doc.querySelectorAll('meta[property="article:tag"]');
  articleTags.forEach(tag => {
    tags.push(tag.getAttribute('content'));
  });
  
  // Try looking for tag links
  const tagLinks = doc.querySelectorAll('.tags a, .categories a, .topics a');
  tagLinks.forEach(link => {
    tags.push(link.textContent.trim());
  });
  
  return [...new Set(tags)]; // Remove duplicates
}

/**
 * Helper function to resolve relative URLs
 * @param {string} url - The URL to resolve
 * @param {string} base - The base URL
 * @returns {string} - The resolved URL
 */
function resolveUrl(url, base) {
  if (!url) return '';
  try {
    return new URL(url, base).href;
  } catch (e) {
    return url;
  }
}

/**
 * Extract a basic title from the URL if nothing else is available
 * @param {string} url - The URL
 * @returns {string} - A title derived from the URL
 */
function extractBasicTitleFromUrl(url) {
  try {
    const urlObj = new URL(url);
    const path = urlObj.pathname;
    
    // Get the last part of the path
    const parts = path.split('/').filter(Boolean);
    
    if (parts.length > 0) {
      // Get the last part and clean it up
      const lastPart = parts[parts.length - 1]
        .replace(/\.html$|\.php$|\.aspx$/, '')
        .replace(/-|_/g, ' ');
      
      // Capitalize first letter of each word
      return lastPart
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }
    
    // Fall back to domain if no path
    return urlObj.hostname.replace('www.', '');
  } catch (e) {
    // If all fails, return a portion of the URL
    return url.substring(0, 50) + (url.length > 50 ? '...' : '');
  }
}

================
File: src/js/services/rdf/rdf-model.js
================
import rdf from 'rdf-ext';
import N3Parser from '@rdfjs/parser-n3';
import { namespaces, generateNid } from '../../utils/utils.js';
import { state } from '../../core/state.js';
import { querySparql, postToSparql } from '../sparql/sparql.js';

export class RDFModel {
  constructor() {
    this.parser = new N3Parser();
    this.ns = {};
    
    // Initialize namespaces
    Object.entries(namespaces).forEach(([prefix, uri]) => {
      this.ns[prefix] = rdf.namespace(uri);
    });

    // Load any cached data on initialization
    this.loadCachedData();
  }

  async loadCachedData() {
    try {
      const cachedData = localStorage.getItem('squirt_rdf_cache');
      if (cachedData) {
        const dataset = await this.parseFromString(cachedData);
        state.update('rdfDataset', dataset);
      } else {
        state.update('rdfDataset', rdf.dataset());
      }
    } catch (error) {
      console.error('Error loading cached RDF data:', error);
      state.update('rdfDataset', rdf.dataset());
    }
  }

  saveToCache(dataset) {
    try {
      localStorage.setItem('squirt_rdf_cache', dataset.toString());
    } catch (error) {
      console.error('Error caching RDF data:', error);
    }
  }

  async parseFromString(turtleString) {
    try {
      const quads = [];
      const parser = this.parser;
      
      return new Promise((resolve, reject) => {
        const stream = parser.import(rdf.stringToStream(turtleString));
        
        stream.on('data', quad => {
          quads.push(quad);
        });
        
        stream.on('error', error => {
          reject(error);
        });
        
        stream.on('end', () => {
          resolve(rdf.dataset(quads));
        });
      });
    } catch (error) {
      console.error('Error parsing RDF data:', error);
      throw error;
    }
  }

  /**
   * Create a new post in the RDF dataset
   * @param {Object} postData - The post data
   * @param {string} postData.type - The post type (e.g., 'link', 'entry', 'wiki')
   * @param {string} postData.content - The content of the post
   * @param {string} [postData.title] - Optional title
   * @param {string[]} [postData.tags] - Optional array of tags
   * @param {string} [postData.customId] - Optional custom ID (for updates)
   * @param {string} [postData.graph] - Optional named graph URI
   * @returns {string} The ID of the created post
   */
  createPost(postData) {
    const dataset = state.get('rdfDataset') || rdf.dataset();
    
    // Use custom ID if provided (useful for updates), otherwise generate one
    const postId = postData.customId || generateNid(postData.content);
    const subject = rdf.namedNode(postId);
    
    // Create a named graph for this post if specified
    const graph = postData.graph ? 
      rdf.namedNode(postData.graph) : 
      null;
    
    // Helper function to add quad with optional graph
    const addQuad = (s, p, o) => {
      if (graph) {
        dataset.add(rdf.quad(s, p, o, graph));
      } else {
        dataset.add(rdf.quad(s, p, o));
      }
    };
    
    // Add RDF type
    addQuad(
      subject,
      this.ns.rdf('type'),
      this.ns.squirt(postData.type)
    );
    
    // Add content
    addQuad(
      subject,
      this.ns.squirt('content'),
      rdf.literal(postData.content)
    );
    
    // Add creation date
    addQuad(
      subject,
      this.ns.dc('created'),
      rdf.literal(new Date().toISOString(), rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
    );
    
    // Add title if provided
    if (postData.title) {
      addQuad(
        subject,
        this.ns.dc('title'),
        rdf.literal(postData.title)
      );
    }
    
    // Add tags if provided
    if (postData.tags && Array.isArray(postData.tags)) {
      postData.tags.forEach(tag => {
        addQuad(
          subject,
          this.ns.squirt('tag'),
          rdf.literal(tag)
        );
      });
    }
    
    // Add URL if it's a link post and has a URL
    if (postData.type === 'link' && postData.url) {
      addQuad(
        subject,
        this.ns.squirt('url'),
        rdf.namedNode(postData.url)
      );
    }
    
    // Add wiki-specific fields
    if (postData.type === 'wiki') {
      // Add last modified date
      addQuad(
        subject,
        this.ns.dc('modified'),
        rdf.literal(new Date().toISOString(), rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
      );
    }
    
    // Update state with new dataset
    state.update('rdfDataset', dataset);
    
    // Save to cache
    this.saveToCache(dataset);
    
    return postId;
  }

  /**
   * Get posts from the dataset
   * @param {Object} [options] - Query options
   * @param {string} [options.type] - Filter by post type
   * @param {string} [options.tag] - Filter by tag
   * @param {number} [options.limit] - Max number of posts to return
   * @param {string} [options.graph] - Filter by named graph
   * @returns {Array} Array of post objects
   */
  getPosts(options = {}) {
    const dataset = state.get('rdfDataset');
    if (!dataset) return [];
    
    let posts = new Map();
    
    // Find all posts
    const postTypePattern = this.ns.rdf('type');
    
    // Create matching options for graph filtering
    const matchOptions = {};
    if (options.graph) {
      matchOptions.graph = rdf.namedNode(options.graph);
    }
    
    // Get all subjects that are posts
    dataset.match(null, postTypePattern, null, options.graph ? rdf.namedNode(options.graph) : null).forEach(quad => {
      const postType = quad.object.value.split('/').pop();
      
      // Skip if filtering by type and this doesn't match
      if (options.type && postType !== options.type) return;
      
      const postId = quad.subject.value;
      const graphId = quad.graph?.value || null;
      
      if (!posts.has(postId)) {
        posts.set(postId, {
          id: postId,
          type: postType,
          graph: graphId,
          tags: []
        });
      }
    });
    
    // Now populate post details for the matched posts
    posts.forEach((post, id) => {
      const subject = rdf.namedNode(id);
      const graph = post.graph ? rdf.namedNode(post.graph) : null;
      
      // Get content
      dataset.match(subject, this.ns.squirt('content'), null, graph).forEach(quad => {
        post.content = quad.object.value;
      });
      
      // Get title
      dataset.match(subject, this.ns.dc('title'), null, graph).forEach(quad => {
        post.title = quad.object.value;
      });
      
      // Get created date
      dataset.match(subject, this.ns.dc('created'), null, graph).forEach(quad => {
        post.created = quad.object.value;
      });
      
      // Get modified date (primarily for wiki entries)
      dataset.match(subject, this.ns.dc('modified'), null, graph).forEach(quad => {
        post.modified = quad.object.value;
      });
      
      // Get tags
      dataset.match(subject, this.ns.squirt('tag'), null, graph).forEach(quad => {
        post.tags.push(quad.object.value);
      });
      
      // Get URL for link posts
      dataset.match(subject, this.ns.squirt('url'), null, graph).forEach(quad => {
        post.url = quad.object.value;
      });
    });
    
    // Filter by tag if needed
    if (options.tag) {
      posts = new Map(
        Array.from(posts.entries()).filter(([_, post]) => 
          post.tags.includes(options.tag)
        )
      );
    }
    
    // Convert to array and sort by date (newest first)
    // Use modified date if available (for wiki entries), otherwise use created date
    let postsArray = Array.from(posts.values())
      .sort((a, b) => {
        const dateA = a.modified ? new Date(a.modified) : new Date(a.created);
        const dateB = b.modified ? new Date(b.modified) : new Date(b.created);
        return dateB - dateA;
      });
    
    // Apply limit if specified
    if (options.limit && options.limit > 0) {
      postsArray = postsArray.slice(0, options.limit);
    }
    
    return postsArray;
  }

  /**
   * Synchronize local RDF data with remote SPARQL endpoint
   */
  async syncWithEndpoint() {
    const dataset = state.get('rdfDataset');
    if (!dataset || dataset.size === 0) return;
    
    try {
      await postToSparql(dataset);
      console.log('Data synchronized with SPARQL endpoint');
    } catch (error) {
      console.error('Failed to sync with SPARQL endpoint:', error);
      throw error;
    }
  }

  /**
   * Load posts from the SPARQL endpoint
   */
  async loadFromEndpoint() {
    try {
      const query = `
        PREFIX rdf: <${namespaces.rdf}>
        PREFIX squirt: <${namespaces.squirt}>
        PREFIX dc: <${namespaces.dc}>
        
        CONSTRUCT {
          ?s ?p ?o .
        }
        WHERE {
          ?s rdf:type ?type .
          FILTER(STRSTARTS(STR(?type), "${namespaces.squirt}"))
          ?s ?p ?o .
        }
      `;
      
      const response = await querySparql(query);
      
      if (response && response.results) {
        const dataset = await this.parseFromString(response.results);
        state.update('rdfDataset', dataset);
        this.saveToCache(dataset);
        console.log('Loaded data from SPARQL endpoint');
      }
    } catch (error) {
      console.error('Failed to load data from SPARQL endpoint:', error);
      throw error;
    }
  }

  /**
   * Delete a post from the dataset
   * @param {string} postId - The ID of the post to delete
   * @returns {boolean} Success status
   */
  deletePost(postId) {
    const dataset = state.get('rdfDataset');
    if (!dataset) return false;
    
    const subject = rdf.namedNode(postId);
    
    // Find all quads with this subject and remove them
    const quadsToRemove = dataset.match(subject);
    
    if (quadsToRemove.size === 0) return false;
    
    quadsToRemove.forEach(quad => {
      dataset.delete(quad);
    });
    
    // Update state
    state.update('rdfDataset', dataset);
    
    // Save to cache
    this.saveToCache(dataset);
    
    return true;
  }
}

// Export a singleton instance
export const rdfModel = new RDFModel();

================
File: src/js/services/sparql/endpoints.js
================
// src/js/services/sparql/endpoints.js
import { state } from '../../core/state.js';
import { testEndpoint } from './sparql.js';
import { ErrorHandler } from '../../core/errors.js';

export class EndpointManager {
    constructor() {
        this.STORAGE_KEY = 'squirt_endpoints';
        this.statusCheckInterval = 60000; // 1 minute
    }

    async initialize() {
        try {
            console.log('Initializing endpoints manager...');
            
            // First try to load endpoints from the config file
            const endpointsFromFile = this.loadFromConfig();
            
            // Then try to load from localStorage (which may have user customizations)
            const storedEndpoints = this.loadFromStorage();
            
            // Merge the endpoints, giving preference to stored ones
            let endpoints = endpointsFromFile;
            
            if (storedEndpoints && storedEndpoints.length > 0) {
                // Keep existing endpoints from storage and add any new ones from file
                const storedUrls = new Set(storedEndpoints.map(e => e.url));
                const newEndpoints = endpointsFromFile.filter(e => !storedUrls.has(e.url));
                
                endpoints = [...storedEndpoints, ...newEndpoints];
            }
            
            if (!endpoints || endpoints.length === 0) {
                console.warn('No endpoints found in config or storage, using defaults');
                endpoints = this.getDefaultEndpoints();
            }
            
            console.log(`Loaded ${endpoints.length} endpoints`);
            
            // Update state with endpoints
            state.update('endpoints', endpoints);
            
            // Start status checks
            this.startStatusChecks();
            
            return endpoints;
        } catch (error) {
            console.error('Error initializing endpoints:', error);
            ErrorHandler.handle(error);
            const fallback = this.getDefaultEndpoints();
            state.update('endpoints', fallback);
            this.startStatusChecks();
            return fallback;
        }
    }

    loadFromStorage() {
        try {
            const stored = localStorage.getItem(this.STORAGE_KEY);
            return stored ? JSON.parse(stored) : null;
        } catch (error) {
            console.error('Error loading endpoints from storage:', error);
            return null;
        }
    }

    // Load endpoints from imported config
    loadFromConfig() {
        try {
            // Import config dynamically
            const config = require('../../../config.json');
            
            // If config exists and is an array, return it
            if (config && Array.isArray(config)) {
                console.log('Found endpoints in config.json:', config);
                return config.map(endpoint => ({
                    url: endpoint.url,
                    label: endpoint.name,
                    type: endpoint.type,
                    credentials: endpoint.credentials,
                    status: 'unknown'
                }));
            }
            throw new Error('Invalid config format in config.json');
        } catch (error) {
            console.error('Error loading endpoints from config.json:', error);
            return [];
        }
    }

    getDefaultEndpoints() {
        console.warn('Using default endpoints as fallback');
        return [
            { 
                url: 'http://localhost:4030/semem/query',
                label: 'Local Query Endpoint',
                type: 'query',
                status: 'unknown',
                credentials: {
                    user: 'admin',
                    password: 'admin123'
                }
            },
            {
                url: 'http://localhost:4030/semem/update',
                label: 'Local Update Endpoint',
                type: 'update',
                status: 'unknown',
                credentials: {
                    user: 'admin',
                    password: 'admin123'
                }
            }
        ];
    }

    async startStatusChecks() {
        const checkAll = async () => {
            const endpoints = state.get('endpoints');
            
            if (!endpoints || endpoints.length === 0) return;
            
            console.log(`Checking ${endpoints.length} endpoints...`);
            
            for (const endpoint of endpoints) {
                try {
                    const status = await testEndpoint(endpoint.url, endpoint.credentials);
                    endpoint.status = status ? 'active' : 'inactive';
                    endpoint.lastChecked = new Date().toISOString();
                    console.log(`Endpoint ${endpoint.url} status: ${endpoint.status}`);
                } catch (error) {
                    console.error(`Error checking endpoint ${endpoint.url}:`, error);
                    endpoint.status = 'inactive';
                }
            }
            
            state.update('endpoints', [...endpoints]);
            this.saveToStorage();
        };

        // Run immediately and then on interval
        await checkAll();
        setInterval(checkAll, this.statusCheckInterval);
    }

    saveToStorage() {
        try {
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(state.get('endpoints')));
        } catch (error) {
            console.error('Error saving endpoints to storage:', error);
        }
    }

    addEndpoint(url, label, type = 'query', credentials = null) {
        const endpoints = state.get('endpoints') || [];
        
        // Check if endpoint with same URL already exists
        if (endpoints.some(e => e.url === url)) {
            throw new Error(`Endpoint with URL ${url} already exists`);
        }
        
        endpoints.push({ 
            url, 
            label, 
            type, 
            credentials,
            status: 'unknown', 
            lastChecked: null 
        });
        
        state.update('endpoints', endpoints);
        this.saveToStorage();
        
        // Check the status immediately
        this.checkEndpoint(url, credentials).then(status => {
            this.updateEndpoint(url, { 
                status: status ? 'active' : 'inactive',
                lastChecked: new Date().toISOString()
            });
        });
    }

    async checkEndpoint(url, credentials = null) {
        return testEndpoint(url, credentials);
    }

    removeEndpoint(url) {
        const endpoints = state.get('endpoints').filter(e => e.url !== url);
        state.update('endpoints', endpoints);
        this.saveToStorage();
    }

    updateEndpoint(url, updates) {
        const endpoints = state.get('endpoints').map(e => 
            e.url === url ? { ...e, ...updates } : e
        );
        state.update('endpoints', endpoints);
        this.saveToStorage();
    }

    getActiveEndpoint(type) {
        const endpoints = state.get('endpoints') || [];
        return endpoints.find(e => e.type === type && e.status === 'active');
    }

    // Add to src/js/services/sparql/endpoints.js in the EndpointManager class

/**
 * Perform a non-blocking check of all endpoints
 * @returns {Promise<Object>} Object with check results and status
 */
async checkEndpointsHealth() {
    // Create a copy of the current endpoints to avoid mutation issues
    const endpoints = [...(state.get('endpoints') || [])];
    
    if (endpoints.length === 0) {
      console.log('No endpoints to check');
      return { success: false, message: 'No endpoints configured' };
    }
    
    console.log(`Checking health of ${endpoints.length} endpoints...`);
    
    // Set endpoints to checking state
    endpoints.forEach(endpoint => {
      endpoint.status = 'checking';
    });
    
    // Update state to show checking status in UI
    state.update('endpoints', endpoints);
    
    // Use Promise.all to run all checks in parallel
    try {
      const results = await Promise.all(
        endpoints.map(async (endpoint) => {
          try {
            // Use existing testEndpoint function
            const isActive = await this.checkEndpoint(endpoint.url, endpoint.credentials);
            return {
              url: endpoint.url,
              label: endpoint.label,
              type: endpoint.type,
              isActive,
              error: null
            };
          } catch (error) {
            console.error(`Error checking endpoint ${endpoint.url}:`, error);
            return {
              url: endpoint.url,
              label: endpoint.label,
              type: endpoint.type,
              isActive: false,
              error: error.message
            };
          }
        })
      );
      
      // Update endpoints with results
      const updatedEndpoints = endpoints.map(endpoint => {
        const result = results.find(r => r.url === endpoint.url);
        return {
          ...endpoint,
          status: result?.isActive ? 'active' : 'inactive',
          lastChecked: new Date().toISOString(),
          lastError: result?.error || null
        };
      });
      
      // Update state with final results
      state.update('endpoints', updatedEndpoints);
      
      // Dispatch an event with the results for any listeners
      try {
        const anyActive = results.some(r => r.isActive);
        const queryActive = results.some(r => r.isActive && r.type === 'query');
        const updateActive = results.some(r => r.isActive && r.type === 'update');
        
        const event = new CustomEvent('endpointsStatusChecked', {
          detail: {
            results,
            anyActive,
            queryActive,
            updateActive
          }
        });
        
        document.dispatchEvent(event);
      } catch (error) {
        console.error('Error dispatching endpoints status event:', error);
      }
      
      // Return summary of results
      return {
        success: true,
        anyActive: results.some(r => r.isActive),
        queryActive: results.some(r => r.isActive && r.type === 'query'),
        updateActive: results.some(r => r.isActive && r.type === 'update'),
        results
      };
    } catch (error) {
      console.error('Error checking endpoints health:', error);
      return { success: false, message: error.message };
    }
  }
}

// Create and export a singleton instance
export const endpointManager = new EndpointManager();

================
File: src/js/services/sparql/sparql.js
================
// src/js/services/sparql/sparql.js
import { state } from '../../core/state.js';
import { ErrorHandler } from '../../core/errors.js';

/**
 * Get the active endpoint URL for a specific type (query or update)
 * @param {string} type - The endpoint type: 'query' or 'update'
 * @returns {Object|null} The endpoint object or null if not found
 */
export function getEndpoint(type) {
  const endpoints = state.get('endpoints') || [];
  const endpoint = endpoints.find(e => e.type === type && e.status === 'active');
  
  if (!endpoint) {
    throw new Error(`No active ${type} endpoint available. Please check your SPARQL configuration.`);
  }
  
  return endpoint;
}

/**
 * Post RDF data to the SPARQL update endpoint
 * @param {Dataset} dataset - The RDF dataset to post
 * @returns {Promise<boolean>} Success status
 */
export async function postToSparql(dataset) {
  if (!dataset) {
    throw new Error('Dataset is required');
  }

  const endpoint = getEndpoint('update');
  const insertQuery = `
    INSERT DATA {
      ${dataset.toString()}
    }
  `;

  try {
    const headers = {
      'Content-Type': 'application/sparql-update',
      'Accept': 'application/json, */*'
    };
    
    // Add basic auth if credentials exist
    if (endpoint.credentials) {
      const { user, password } = endpoint.credentials;
      const auth = btoa(`${user}:${password}`);
      headers['Authorization'] = `Basic ${auth}`;
    }

    const response = await fetch(endpoint.url, {
      method: 'POST',
      headers,
      body: insertQuery
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`SPARQL update failed for endpoint ${endpoint.url}: ${response.status} ${errorText}`);
    }
    return true;
  } catch (error) {
    ErrorHandler.handle(error);
    throw error;
  }
}

/**
 * Query the SPARQL endpoint
 * @param {string} query - The SPARQL query string
 * @returns {Promise<Object>} Query results
 */
export async function querySparql(query) {
  if (!query) {
    throw new Error('Query is required');
  }

  const endpoint = getEndpoint('query');

  try {
    const headers = {
      'Content-Type': 'application/sparql-query',
      'Accept': 'application/sparql-results+json, application/json'
    };
    
    // Add basic auth if credentials exist
    if (endpoint.credentials) {
      const { user, password } = endpoint.credentials;
      const auth = btoa(`${user}:${password}`);
      headers['Authorization'] = `Basic ${auth}`;
    }

    const response = await fetch(endpoint.url, {
      method: 'POST',
      headers,
      body: query
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`SPARQL query failed for endpoint ${endpoint.url}: ${response.status} ${errorText}\n${query}`);
    }

    return response.json();
  } catch (error) {
    ErrorHandler.handle(error);
    throw error;
  }
}

/**
 * Test if a SPARQL endpoint is alive and responding
 * @param {string} url - The endpoint URL to test
 * @param {Object} [credentials] - Optional credentials for basic auth
 * @returns {Promise<boolean>} True if endpoint is alive
 */
export async function testEndpoint(url, credentials) {
  try {
    const headers = {
      'Content-Type': 'application/sparql-query',
      'Accept': 'application/sparql-results+json, application/json'
    };
    
    if (credentials) {
      const { user, password } = credentials;
      const auth = btoa(`${user}:${password}`);
      headers['Authorization'] = `Basic ${auth}`;
    }

    // Use a minimal ASK query to test if the endpoint is alive
    const query = 'ASK { ?s ?p ?o } LIMIT 1';
    
    const response = await fetch(url, {
      method: 'POST',
      headers,
      body: query
    });

    return response.ok;
  } catch (error) {
    console.error(`Endpoint test failed for ${url}:`, error);
    return false;
  }
}

================
File: src/js/services/templates/post-article.njk
================
PREFIX schema: <http://schema.org/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX : <http://purl.org/stuff/transmissions/>

INSERT DATA {
    GRAPH <http://purl.org/stuff/squirt/> {
        <{{uri}}> a schema:Article ;
            schema:headline "{{title}}" ;
            schema:dateCreated "{{dates.created}}"^^xsd:dateTime ;
            schema:dateModified "{{dates.modified}}"^^xsd:dateTime ;
            schema:articleBody """{{content}}""" ;
            schema:creator <{{creator.uri}}> ;
            :tag "tag1" ;
            :tag "tag2" .
        <{{creator.uri}}> a schema:Person ;
            schema:name "{{creator.name}}" .
    }
}

================
File: src/js/ui/components/endpoint-indicator.js
================
// src/js/ui/components/endpoint-indicator.js - Fixed version
import { state } from '../../core/state.js';

/**
 * Manages the endpoint status indicator in the header
 */
export class EndpointStatusIndicator {
  constructor() {
    // Bind methods to preserve 'this' context
    this.handleEndpointChange = this.handleEndpointChange.bind(this);
    this.handleStatusChangeEvent = this.handleStatusChangeEvent.bind(this);
    this.handleStatusCheckedEvent = this.handleStatusCheckedEvent.bind(this);
    
    this.indicator = document.getElementById('endpoint-status-indicator');
    
    if (!this.indicator) {
      console.error('Endpoint status indicator element not found');
      return;
    }
    
    // Initialize the indicator content
    this.indicator.innerHTML = `
      <div class="status-light"></div>
      <span class="status-tooltip-icon">?</span>
    `;
    
    this.statusLight = this.indicator.querySelector('.status-light');
    
    // Initialize status
    this.updateStatus('checking', 'Checking endpoint status...');
    
    // Subscribe to endpoint changes
    state.subscribe('endpoints', this.handleEndpointChange);
    
    // Listen for endpoint status events
    document.addEventListener('endpointStatusChanged', this.handleStatusChangeEvent);
    document.addEventListener('endpointsStatusChecked', this.handleStatusCheckedEvent);
    
    // Add click handler to force endpoint check
    this.indicator.addEventListener('click', () => {
      this.updateStatus('checking', 'Checking endpoints...');
      
      // Dispatch an event to request endpoint check
      try {
        const event = new CustomEvent('checkEndpointsRequest');
        document.dispatchEvent(event);
      } catch (error) {
        console.error('Error dispatching endpoint check request:', error);
      }
    });
  }
  
  /**
   * Handle endpoint state changes
   */
  handleEndpointChange(endpoints) {
    try {
      if (!endpoints || endpoints.length === 0) {
        this.updateStatus('inactive', 'No endpoints configured');
        return;
      }
      
      const activeEndpoint = endpoints.find(e => e.status === 'active');
      if (activeEndpoint) {
        this.updateStatus('active', `SPARQL endpoint available: ${activeEndpoint.url}`);
      } else if (endpoints.some(e => e.status === 'checking')) {
        this.updateStatus('checking', 'Checking endpoints...');
      } else {
        this.updateStatus('inactive', 'No available endpoints');
      }
    } catch (error) {
      console.error('Error handling endpoint change:', error);
    }
  }
  
  /**
   * Handle endpoint status change event
   */
  handleStatusChangeEvent(e) {
    try {
      if (e.detail) {
        const { status, url, label } = e.detail;
        
        if (status === 'active') {
          this.updateStatus('active', `SPARQL endpoint available: ${url}`);
        }
      }
    } catch (error) {
      console.error('Error handling status change event:', error);
    }
  }
  
  /**
   * Handle endpoints status checked event
   */
  handleStatusCheckedEvent(e) {
    try {
      if (e.detail && e.detail.anyActive) {
        // Find which endpoint is active
        const endpoints = state.get('endpoints') || [];
        const activeEndpoint = endpoints.find(e => e.status === 'active');
        
        if (activeEndpoint) {
          this.updateStatus('active', `SPARQL endpoint available: ${activeEndpoint.url}`);
        } else {
          this.updateStatus('active', 'SPARQL endpoint is available');
        }
      } else {
        this.updateStatus('inactive', 'No available endpoints');
      }
    } catch (error) {
      console.error('Error handling status checked event:', error);
    }
  }
  
  /**
   * Update the visual status of the indicator
   * @param {string} status - The status: 'active', 'inactive', or 'checking'
   * @param {string} [message] - Optional tooltip message
   */
  updateStatus(status, message = '') {
    try {
      if (!this.statusLight) return;
      
      // Remove all status classes
      this.statusLight.classList.remove('active', 'inactive', 'checking');
      
      // Add the appropriate class
      this.statusLight.classList.add(status);
      
      // Update tooltip
      this.indicator.title = message || status;
    } catch (error) {
      console.error('Error updating status:', error);
    }
  }
}

/**
 * Initialize the endpoint status indicator
 */
export function initializeEndpointIndicator() {
  try {
    return new EndpointStatusIndicator();
  } catch (error) {
    console.error('Error initializing endpoint indicator:', error);
    return null;
  }
}

================
File: src/js/ui/components/endpoints-list.js
================
import { state } from '../../core/state.js';
import { ErrorHandler } from '../../core/errors.js';

// Simple non-custom element implementation for better compatibility
export function setupEndpointsList() {
    const container = document.getElementById('endpoints-list');
    if (!container) return;
    
    // Initial render
    renderEndpointsList(container);
    
    // Subscribe to state changes
    state.subscribe('endpoints', () => renderEndpointsList(container));
    
    // Set up event delegation
    container.addEventListener('click', async (e) => {
        // Find the closest endpoint item
        const item = e.target.closest('.endpoint-item');
        if (!item) return;
        
        const url = item.dataset.url;
        
        try {
            // Handle check button
            if (e.target.matches('.check-endpoint')) {
                await checkEndpoint(url, item);
            }
            // Handle remove button
            else if (e.target.matches('.remove-endpoint')) {
                if (confirm('Are you sure you want to remove this endpoint?')) {
                    removeEndpoint(url);
                    // Show temporary notification
                    showNotification('Endpoint removed', 'info');
                }
            }
            // Handle edit button
            else if (e.target.matches('.edit-endpoint')) {
                toggleEditMode(item);
            }
            // Handle save button
            else if (e.target.matches('.save-endpoint')) {
                saveEndpointChanges(item);
            }
        } catch (error) {
            ErrorHandler.handle(error);
            showNotification('Operation failed: ' + error.message, 'error');
        }
    });
}

function renderEndpointsList(container) {
    const endpoints = state.get('endpoints') || [];
    
    if (endpoints.length === 0) {
        container.innerHTML = '<p>No endpoints configured yet.</p>';
        return;
    }
    
    container.innerHTML = endpoints.map(endpoint => `
        <div class="endpoint-item" data-url="${endpoint.url}">
            <div class="endpoint-info">
                <div class="endpoint-header">
                    <div class="endpoint-status ${endpoint.status || 'unknown'}"></div>
                    <div class="endpoint-details">
                        <span class="endpoint-label">${endpoint.label}</span>
                        <span class="endpoint-type">(${endpoint.type})</span>
                    </div>
                </div>
                <div class="endpoint-url">${endpoint.url}</div>
                <div class="endpoint-edit-form" style="display: none;">
                    <div class="form-field">
                        <label for="edit-label-${encodeURIComponent(endpoint.url)}">Label</label>
                        <input type="text" class="edit-label" id="edit-label-${encodeURIComponent(endpoint.url)}" value="${endpoint.label}">
                    </div>
                    <div class="form-field">
                        <label for="edit-type-${encodeURIComponent(endpoint.url)}">Type</label>
                        <select class="edit-type" id="edit-type-${encodeURIComponent(endpoint.url)}">
                            <option value="query" ${endpoint.type === 'query' ? 'selected' : ''}>Query</option>
                            <option value="update" ${endpoint.type === 'update' ? 'selected' : ''}>Update</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="endpoint-actions">
                <button class="check-endpoint">Check</button>
                <button class="edit-endpoint">Edit</button>
                <button class="save-endpoint" style="display: none;">Save</button>
                <button class="remove-endpoint">Remove</button>
            </div>
        </div>
    `).join('');
}

async function checkEndpoint(url, item) {
    const statusIndicator = item.querySelector('.endpoint-status');
    
    // Set checking status
    statusIndicator.className = 'endpoint-status checking';
    
    try {
        // Import endpointManager here to avoid circular dependencies
        const { EndpointManager } = await import('../../services/sparql/endpoints.js');
        const endpointManager = new EndpointManager();
        
        // Find the endpoint in the state
        const endpoints = state.get('endpoints');
        const endpoint = endpoints.find(e => e.url === url);
        
        if (!endpoint) {
            throw new Error('Endpoint not found');
        }
        
        // Check the endpoint
        const status = await endpointManager.checkEndpoint(url, endpoint.credentials);
        
        // Update the endpoint status
        endpointManager.updateEndpoint(url, { 
            status: status ? 'active' : 'inactive',
            lastChecked: new Date().toISOString()
        });
        
        // Show notification
        showNotification(
            `Endpoint is ${status ? 'active' : 'inactive'}`, 
            status ? 'success' : 'error'
        );
    } catch (error) {
        console.error('Error checking endpoint:', error);
        statusIndicator.className = 'endpoint-status error';
        throw error;
    }
}

function removeEndpoint(url) {
    // Import endpointManager here to avoid circular dependencies
    import('../../services/sparql/endpoints.js').then(({ EndpointManager }) => {
        const endpointManager = new EndpointManager();
        endpointManager.removeEndpoint(url);
    });
}

function toggleEditMode(item) {
    const editForm = item.querySelector('.endpoint-edit-form');
    const saveButton = item.querySelector('.save-endpoint');
    const editButton = item.querySelector('.edit-endpoint');
    
    if (editForm.style.display === 'none') {
        // Show edit form
        editForm.style.display = 'block';
        saveButton.style.display = 'inline-block';
        editButton.style.display = 'none';
    } else {
        // Hide edit form
        editForm.style.display = 'none';
        saveButton.style.display = 'none';
        editButton.style.display = 'inline-block';
    }
}

function saveEndpointChanges(item) {
    const url = item.dataset.url;
    const label = item.querySelector('.edit-label').value;
    const type = item.querySelector('.edit-type').value;
    
    // Import endpointManager here to avoid circular dependencies
    import('../../services/sparql/endpoints.js').then(({ EndpointManager }) => {
        const endpointManager = new EndpointManager();
        endpointManager.updateEndpoint(url, { label, type });
        
        // Hide edit form
        toggleEditMode(item);
        
        // Show notification
        showNotification('Endpoint updated successfully', 'success');
    });
}

// Make this available globally for other components to use
window.updateEndpointsList = function() {
    const container = document.getElementById('endpoints-list');
    if (container) {
        renderEndpointsList(container);
    }
};

function showNotification(message, type = 'info') {
    // Use global notification function if available
    if (typeof window.showNotification === 'function') {
        window.showNotification(message, type);
        return;
    }
    
    // Fallback to console
    console.log(`${type.toUpperCase()}: ${message}`);
}

================
File: src/js/ui/components/forms.js
================
import { state } from '../../core/state.js';
import { ErrorHandler } from '../../core/errors.js';
import { rdfModel } from '../../services/rdf/rdf-model.js';
import { extractMetadataFromUrl, createDatasetFromMetadata } from '../../services/rdf/rdf-extractor.js';
import { showNotification } from './notifications.js';

export function setupForms() {
  setupPostForm();
  setupEndpointForm();
}

function setupPostForm() {
  console.log('Setting up post form...');
  const form = document.getElementById('post-form');
  if (!form) {
    console.warn('Post form not found, it may be loaded dynamically');
    return;
  }
  
  console.log('Post form found, setting up extract button...');
  
  // Set up the extract button
  const extractButton = document.getElementById('extract-metadata');
  const urlInput = document.getElementById('url');
  
  if (extractButton && urlInput) {
    console.log('Extract button found, adding listener');
    extractButton.addEventListener('click', async () => {
      if (urlInput.value) {
        try {
          extractButton.disabled = true;
          extractButton.textContent = 'Extracting...';
          
          showNotification('Extracting metadata, please wait...', 'info');
          
          const metadata = await extractMetadataFromUrl(urlInput.value);
          
          // Fill in form fields with extracted metadata
          if (metadata.title) {
            const titleInput = document.getElementById('title');
            if (titleInput && !titleInput.value) {
              titleInput.value = metadata.title;
            }
          }
          
          if (metadata.description) {
            const contentInput = document.getElementById('content');
            if (contentInput && !contentInput.value) {
              contentInput.value = metadata.description;
            }
          }
          
          if (metadata.tags && metadata.tags.length > 0) {
            const tagsInput = document.getElementById('tags');
            if (tagsInput && !tagsInput.value) {
              tagsInput.value = metadata.tags.join(', ');
            }
          }
          
          // Update preview
          const previewElement = document.getElementById('post-preview');
          if (previewElement) {
            previewElement.innerHTML = `
              <h3>Link Preview</h3>
              <div class="link-preview">
                <div class="preview-card">
                  ${metadata.image ? `<div class="preview-image"><img src="${metadata.image}" alt="${metadata.title || 'Preview'}"></div>` : ''}
                  <div class="preview-content">
                    <h3 class="preview-title">${metadata.title || 'No title'}</h3>
                    <p class="preview-description">${metadata.description || ''}</p>
                    ${metadata.siteName ? `<span class="preview-site">${metadata.siteName}</span>` : ''}
                  </div>
                </div>
              </div>
            `;
          }
          
          showNotification('Metadata extracted successfully', 'success');
          
        } catch (error) {
          console.error('Error extracting metadata:', error);
          showNotification(`Failed to extract metadata: ${error.message}`, 'error');
        } finally {
          extractButton.disabled = false;
          extractButton.textContent = 'Extract';
        }
      } else {
        showNotification('Please enter a valid URL first', 'warning');
      }
    });
  } else {
    console.warn('Extract button or URL input not found!');
  }

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    try {
      state.update('postSubmitting', true);
      const formData = new FormData(form);
      
      // Extract form data
      const postData = {
        type: formData.get('post-type'),
        content: formData.get('content'),
        tags: formData.get('tags') ? formData.get('tags').split(',').map(tag => tag.trim()) : []
      };
      
      // If it's a link post, extract the URL
      if (postData.type === 'link' && formData.get('url')) {
        postData.url = formData.get('url');
      }
      
      // If title is provided, add it
      if (formData.get('title')) {
        postData.title = formData.get('title');
      }
      
      // Create post in the RDF model
      const postId = rdfModel.createPost(postData);
      
      // Try to sync with endpoint, but continue even if it fails
      try {
        await rdfModel.syncWithEndpoint();
      } catch (syncError) {
        console.warn('Post created locally but failed to sync with endpoint', syncError);
      }
      
      // Update UI state
      state.update('lastPost', {
        id: postId,
        ...postData,
        timestamp: new Date().toISOString()
      });
      
      state.update('lastPostStatus', 'success');
      
      // Reset form
      form.reset();
      
      // Show success notification
      showNotification('Post created successfully', 'success');
      
    } catch (error) {
      ErrorHandler.handle(error);
      state.update('lastPostStatus', 'error');
      showNotification('Failed to create post: ' + error.message, 'error');
    } finally {
      state.update('postSubmitting', false);
    }
  });
}

// Listen for post type changes 
const typeSelector = document.getElementById('post-type');
if (typeSelector) {
  typeSelector.addEventListener('change', (e) => {
    console.log('Post type changed to:', e.target.value);
    // In a real implementation, we would toggle between different form types
    alert('Changing post type is not implemented in this demo. Please refresh the page.');
  });
}

function setupEndpointForm() {
  const form = document.getElementById('endpoint-form');
  if (!form) return;
  
  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    
    try {
      const url = document.getElementById('endpoint-url').value;
      const label = document.getElementById('endpoint-label').value;
      const type = 'query'; // Default to query, can be extended with dropdown
      
      // Import required here to avoid circular dependencies
      const { EndpointManager } = await import('../../services/sparql/endpoints.js');
      const endpointManager = new EndpointManager();
      
      endpointManager.addEndpoint(url, label, type);
      form.reset();
      
      showNotification('Endpoint added successfully', 'success');
      
      // Refresh the endpoint list if the component exists
      if (typeof updateEndpointsList === 'function') {
        updateEndpointsList();
      }
    } catch (error) {
      ErrorHandler.handle(error);
      showNotification('Failed to add endpoint: ' + error.message, 'error');
    }
  });
}

function addFormField(container, field) {
  const wrapper = document.createElement('div');
  wrapper.className = 'form-field';
  
  // Create label
  const label = document.createElement('label');
  label.setAttribute('for', field.name);
  label.textContent = field.label;
  wrapper.appendChild(label);
  
  // Create input
  let input;
  if (field.type === 'textarea') {
    input = document.createElement('textarea');
  } else {
    input = document.createElement('input');
    input.type = field.type;
  }
  
  input.name = field.name;
  input.id = field.name;
  
  if (field.placeholder) {
    input.placeholder = field.placeholder;
  }
  
  if (field.required) {
    input.required = true;
  }
  
  wrapper.appendChild(input);
  container.appendChild(wrapper);
}

// REMOVED: Duplicate showNotification function was here
// Using the imported showNotification from notifications.js instead

================
File: src/js/ui/components/notifications.js
================
/**
 * Notifications system for the application
 */

let notificationsContainer;

/**
 * Initialize the notifications system
 */
export function initializeNotifications() {
    console.log('Initializing notifications system');
    
    // Create container if it doesn't exist
    if (!notificationsContainer) {
        notificationsContainer = document.createElement('div');
        notificationsContainer.className = 'notifications-container';
        document.body.appendChild(notificationsContainer);
        
        // Add styles if not already in the document
        if (!document.getElementById('notification-styles')) {
            const style = document.createElement('style');
            style.id = 'notification-styles';
            style.textContent = `
                .notifications-container {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 1000;
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                    max-width: 300px;
                }
                
                .notification {
                    padding: 10px 15px;
                    border-radius: 4px;
                    color: white;
                    animation: notification-slide-in 0.3s ease-out;
                    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
                    position: relative;
                    overflow: hidden;
                }
                
                .notification::before {
                    content: '';
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    width: 100%;
                    height: 3px;
                    background: rgba(255, 255, 255, 0.5);
                    animation: notification-timer 5s linear forwards;
                }
                
                .notification.success {
                    background-color: var(--success-color, #48bb78);
                }
                
                .notification.error {
                    background-color: var(--error-color, #f56565);
                }
                
                .notification.info {
                    background-color: var(--primary-color, #4299e1);
                }
                
                .notification.warning {
                    background-color: #ed8936;
                }
                
                .notification.fade-out {
                    opacity: 0;
                    transform: translateX(100%);
                    transition: opacity 0.3s, transform 0.3s;
                }
                
                @keyframes notification-slide-in {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                
                @keyframes notification-timer {
                    from {
                        width: 100%;
                    }
                    to {
                        width: 0%;
                    }
                }
            `;
            document.head.appendChild(style);
        }
    }
    
    // Make showNotification globally available
    window.showNotification = showNotification;
}

/**
 * Show a notification message
 * @param {string} message - The message to display
 * @param {string} type - The type of notification (success, error, info, warning)
 * @param {number} duration - How long to show the notification in ms
 */
export function showNotification(message, type = 'info', duration = 5000) {
    // Create the notification container if it doesn't exist
    if (!notificationsContainer) {
        initializeNotifications();
    }
    
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    // Add to container
    notificationsContainer.appendChild(notification);
    
    // Set up removal after duration
    setTimeout(() => {
        notification.classList.add('fade-out');
        setTimeout(() => notification.remove(), 300);
    }, duration);
    
    return notification;
}

/**
 * Show an error notification
 * @param {string} message - The error message
 * @param {number} duration - How long to show the notification in ms
 */
export function showError(message, duration = 5000) {
    return showNotification(message, 'error', duration);
}

/**
 * Show a success notification
 * @param {string} message - The success message
 * @param {number} duration - How long to show the notification in ms
 */
export function showSuccess(message, duration = 5000) {
    return showNotification(message, 'success', duration);
}

/**
 * Show an info notification
 * @param {string} message - The info message
 * @param {number} duration - How long to show the notification in ms
 */
export function showInfo(message, duration = 5000) {
    return showNotification(message, 'info', duration);
}

/**
 * Show a warning notification
 * @param {string} message - The warning message
 * @param {number} duration - How long to show the notification in ms
 */
export function showWarning(message, duration = 5000) {
    return showNotification(message, 'warning', duration);
}

================
File: src/js/ui/views/settings.js
================
import { state } from '../../core/state.js';
import { setupEndpointsList } from '../components/endpoints-list.js';
import { showNotification, initializeNotifications } from '../components/notifications.js';
import { rdfModel } from '../../services/rdf/rdf-model.js';

/**
 * Initialize the settings view
 */
export function initializeSettingsView() {
    const view = document.getElementById('settings-view');
    if (!view) {
        console.warn('Settings view not found');
        return;
    }
    
    // Setup components
    setupEndpointsList();
    initializeNotifications();
    
    // Setup theme selector if it exists
    setupThemeSelector();
    
    // Setup storage management
    setupStorageManagement();
}

/**
 * Setup theme selector component
 */
function setupThemeSelector() {
    const themeSelector = document.getElementById('theme-selector');
    if (!themeSelector) return;
    
    // Get current theme from localStorage or use default
    const currentTheme = localStorage.getItem('squirt_theme') || 'light';
    
    // Set initial value
    themeSelector.value = currentTheme;
    
    // Apply theme to document
    document.documentElement.setAttribute('data-theme', currentTheme);
    
    // Listen for changes
    themeSelector.addEventListener('change', () => {
        const theme = themeSelector.value;
        localStorage.setItem('squirt_theme', theme);
        document.documentElement.setAttribute('data-theme', theme);
        showNotification(`Theme changed to ${theme}`, 'info');
    });
}

/**
 * Setup storage management section
 */
function setupStorageManagement() {
    const storageSection = document.querySelector('.storage-section');
    if (!storageSection) return;
    
    // Create export button if it doesn't exist
    if (!document.getElementById('export-data')) {
        const exportBtn = document.createElement('button');
        exportBtn.id = 'export-data';
        exportBtn.textContent = 'Export Data';
        exportBtn.addEventListener('click', exportData);
        storageSection.appendChild(exportBtn);
    }
    
    // Create import button if it doesn't exist
    if (!document.getElementById('import-data')) {
        const importBtn = document.createElement('button');
        importBtn.id = 'import-data';
        importBtn.textContent = 'Import Data';
        importBtn.addEventListener('click', () => {
            // Create a hidden file input
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.ttl,.json';
            fileInput.style.display = 'none';
            document.body.appendChild(fileInput);
            
            // Listen for file selection
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    importData(file);
                }
                document.body.removeChild(fileInput);
            });
            
            // Trigger file dialog
            fileInput.click();
        });
        storageSection.appendChild(importBtn);
    }
    
    // Create clear data button if it doesn't exist
    if (!document.getElementById('clear-data')) {
        const clearBtn = document.createElement('button');
        clearBtn.id = 'clear-data';
        clearBtn.className = 'danger';
        clearBtn.textContent = 'Clear All Data';
        clearBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                clearAllData();
            }
        });
        storageSection.appendChild(clearBtn);
    }
    
    // Add storage usage info
    updateStorageUsage();
}

/**
 * Export all application data
 */
async function exportData() {
    try {
        // Get RDF dataset
        const dataset = state.get('rdfDataset');
        
        if (!dataset || dataset.size === 0) {
            showNotification('No data to export', 'warning');
            return;
        }
        
        // Convert to Turtle format
        const turtle = dataset.toString();
        
        // Create a download link
        const blob = new Blob([turtle], { type: 'text/turtle' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const date = new Date().toISOString().split('T')[0];
        a.href = url;
        a.download = `squirt_export_${date}.ttl`;
        a.style.display = 'none';
        
        // Trigger download
        document.body.appendChild(a);
        a.click();
        
        // Clean up
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
        
        showNotification('Data exported successfully', 'success');
    } catch (error) {
        console.error('Error exporting data:', error);
        showNotification('Failed to export data', 'error');
    }
}

/**
 * Import data from file
 * @param {File} file - The file to import
 */
async function importData(file) {
    try {
        const reader = new FileReader();
        
        reader.onload = async (e) => {
            try {
                const content = e.target.result;
                
                // Try to parse as Turtle
                try {
                    const dataset = await rdfModel.parseFromString(content);
                    
                    // Merge with existing dataset
                    const currentDataset = state.get('rdfDataset');
                    dataset.forEach(quad => {
                        currentDataset.add(quad);
                    });
                    
                    // Update state
                    state.update('rdfDataset', currentDataset);
                    
                    // Save to cache
                    rdfModel.saveToCache(currentDataset);
                    
                    showNotification('Data imported successfully', 'success');
                } catch (parseError) {
                    console.error('Error parsing imported data:', parseError);
                    showNotification('Invalid data format', 'error');
                }
            } catch (processError) {
                console.error('Error processing imported data:', processError);
                showNotification('Failed to import data', 'error');
            }
        };
        
        reader.onerror = () => {
            showNotification('Failed to read file', 'error');
        };
        
        reader.readAsText(file);
    } catch (error) {
        console.error('Error importing data:', error);
        showNotification('Failed to import data', 'error');
    }
}

/**
 * Clear all application data
 */
function clearAllData() {
    try {
        // Clear RDF dataset
        state.update('rdfDataset', rdfModel.createEmptyDataset());
        
        // Clear localStorage except for settings
        const themeSettings = localStorage.getItem('squirt_theme');
        const endpointSettings = localStorage.getItem('squirt_endpoints');
        
        localStorage.clear();
        
        // Restore settings
        if (themeSettings) {
            localStorage.setItem('squirt_theme', themeSettings);
        }
        
        if (endpointSettings) {
            localStorage.setItem('squirt_endpoints', endpointSettings);
        }
        
        showNotification('All data has been cleared', 'success');
        
        // Update storage usage display
        updateStorageUsage();
    } catch (error) {
        console.error('Error clearing data:', error);
        showNotification('Failed to clear data', 'error');
    }
}

/**
 * Update the storage usage display
 */
function updateStorageUsage() {
    // Create or get storage usage element
    let usageElement = document.getElementById('storage-usage');
    if (!usageElement) {
        usageElement = document.createElement('div');
        usageElement.id = 'storage-usage';
        document.querySelector('.storage-section')?.appendChild(usageElement);
    }
    
    // Calculate localStorage usage
    let total = 0;
    for (const key in localStorage) {
        if (localStorage.hasOwnProperty(key)) {
            total += localStorage[key].length * 2; // Approximate size in bytes
        }
    }
    
    // Format size
    let size;
    if (total < 1024) {
        size = `${total} bytes`;
    } else if (total < 1024 * 1024) {
        size = `${(total / 1024).toFixed(2)} KB`;
    } else {
        size = `${(total / (1024 * 1024)).toFixed(2)} MB`;
    }
    
    // Update display
    usageElement.textContent = `Storage used: ${size}`;
}

================
File: src/js/ui/views/wiki-editor.js
================
/**
 * Wiki Editor component using CodeMirror
 */
import CodeMirror from 'codemirror';
import 'codemirror/lib/codemirror.css';
import 'codemirror/mode/markdown/markdown';
import 'codemirror/theme/monokai.css';
import 'codemirror/addon/edit/continuelist';
import 'codemirror/addon/display/placeholder';
import { marked } from 'marked';
import { rdfModel } from '../../services/rdf/rdf-model.js';
import { showNotification } from '../components/notifications.js';

let editor = null;
let preview = null;

/**
 * Initialize the Wiki editor component
 */
export function initializeWikiEditor() {
  const wikiContent = document.getElementById('wiki-content');
  const previewContainer = document.querySelector('.wiki-preview');
  const saveButton = document.getElementById('save-wiki');
  
  if (!wikiContent) {
    console.warn('Wiki content element not found');
    return;
  }
  
  // Create preview container if it doesn't exist
  if (!previewContainer) {
    preview = document.createElement('div');
    preview.className = 'wiki-preview';
    preview.innerHTML = '<h3>Preview</h3><div class="preview-content"></div>';
    
    const wikiEditor = document.querySelector('.wiki-editor');
    if (wikiEditor) {
      wikiEditor.appendChild(preview);
    }
  } else {
    preview = previewContainer;
  }
  
  // Initialize CodeMirror editor
  editor = CodeMirror.fromTextArea(wikiContent, {
    mode: 'markdown',
    theme: 'monokai',
    lineNumbers: true,
    lineWrapping: true,
    viewportMargin: Infinity,
    placeholder: 'Enter markdown content here...',
    extraKeys: {
      'Enter': 'newlineAndIndentContinueMarkdownList'
    }
  });
  
  // Add change event listener for live preview
  editor.on('change', updatePreview);
  
  // Add event listener for save button
  if (saveButton) {
    saveButton.addEventListener('click', saveWikiEntry);
  }
  
  // Add custom toolbar
  addToolbar();
  
  // Initial preview update
  updatePreview();
}

/**
 * Update the preview with the current content
 */
function updatePreview() {
  const content = editor.getValue();
  const previewContent = preview.querySelector('.preview-content');
  
  if (previewContent) {
    // Render Markdown to HTML using marked
    previewContent.innerHTML = marked(content);
    
    // Syntax highlighting for code blocks
    previewContent.querySelectorAll('pre code').forEach(block => {
      if (window.hljs) {
        window.hljs.highlightBlock(block);
      }
    });
  }
}

/**
 * Add a toolbar with common markdown formatting buttons
 */
function addToolbar() {
  const toolbar = document.createElement('div');
  toolbar.className = 'editor-toolbar';
  
  // Define toolbar buttons
  const buttons = [
    { icon: 'format_bold', title: 'Bold', action: () => wrapText('**', '**') },
    { icon: 'format_italic', title: 'Italic', action: () => wrapText('*', '*') },
    { icon: 'format_quote', title: 'Quote', action: () => prependLine('> ') },
    { icon: 'format_list_bulleted', title: 'Bullet List', action: () => prependLine('- ') },
    { icon: 'format_list_numbered', title: 'Numbered List', action: () => prependLine('1. ') },
    { icon: 'insert_link', title: 'Link', action: insertLink },
    { icon: 'insert_photo', title: 'Image', action: insertImage },
    { icon: 'code', title: 'Code', action: () => wrapText('`', '`') },
    { icon: 'view_headline', title: 'Heading', action: () => prependLine('## ') }
  ];
  
  // Add Material Icons stylesheet if not already present
  if (!document.querySelector('link[href*="material-icons"]')) {
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = 'https://fonts.googleapis.com/icon?family=Material+Icons';
    document.head.appendChild(link);
  }
  
  // Create buttons
  buttons.forEach(button => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'toolbar-button';
    btn.title = button.title;
    btn.innerHTML = `<i class="material-icons">${button.icon}</i>`;
    btn.addEventListener('click', button.action);
    toolbar.appendChild(btn);
  });
  
  // Add toolbar before the editor
  const editorContainer = editor.getWrapperElement().parentNode;
  editorContainer.insertBefore(toolbar, editor.getWrapperElement());
  
  // Add toolbar styles
  if (!document.getElementById('editor-toolbar-styles')) {
    const style = document.createElement('style');
    style.id = 'editor-toolbar-styles';
    style.textContent = `
      .editor-toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-bottom: 10px;
        padding: 5px;
        background: #f5f5f5;
        border-radius: 4px;
      }
      
      .toolbar-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 36px;
        height: 36px;
        padding: 0;
        border: none;
        background: transparent;
        border-radius: 4px;
        cursor: pointer;
      }
      
      .toolbar-button:hover {
        background: #e0e0e0;
      }
      
      .toolbar-button i {
        font-size: 20px;
        color: #555;
      }
      
      .wiki-preview {
        margin-top: 20px;
        padding: 20px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
      }
      
      .preview-content {
        font-family: system-ui, -apple-system, sans-serif;
        line-height: 1.6;
      }
      
      .preview-content h1, 
      .preview-content h2, 
      .preview-content h3 {
        margin-top: 1.5em;
        margin-bottom: 0.5em;
      }
      
      .preview-content p {
        margin-bottom: 1em;
      }
      
      .preview-content ul, 
      .preview-content ol {
        padding-left: 2em;
        margin-bottom: 1em;
      }
      
      .preview-content blockquote {
        border-left: 3px solid #ddd;
        margin-left: 0;
        padding-left: 1em;
        color: #777;
      }
      
      .preview-content code {
        font-family: monospace;
        background: #f0f0f0;
        padding: 2px 4px;
        border-radius: 3px;
      }
      
      .preview-content pre {
        background: #f0f0f0;
        padding: 1em;
        border-radius: 4px;
        overflow-x: auto;
      }
      
      .preview-content img {
        max-width: 100%;
      }
    `;
    document.head.appendChild(style);
  }
}

/**
 * Wrap selected text with prefix and suffix
 */
function wrapText(prefix, suffix) {
  const selection = editor.getSelection();
  if (selection) {
    editor.replaceSelection(prefix + selection + suffix);
  } else {
    const cursor = editor.getCursor();
    editor.replaceRange(prefix + suffix, cursor);
    editor.setCursor({
      line: cursor.line,
      ch: cursor.ch + prefix.length
    });
  }
  editor.focus();
}

/**
 * Prepend each line in selection with text
 */
function prependLine(text) {
  const selection = editor.getSelection();
  const cursor = editor.getCursor();
  
  if (selection) {
    const lines = selection.split('\n');
    const newText = lines.map(line => text + line).join('\n');
    editor.replaceSelection(newText);
  } else {
    const line = editor.getLine(cursor.line);
    editor.replaceRange(text + line, { line: cursor.line, ch: 0 }, { line: cursor.line, ch: line.length });
    editor.setCursor({ line: cursor.line, ch: text.length + cursor.ch });
  }
  editor.focus();
}

/**
 * Insert a link at cursor position
 */
function insertLink() {
  const selection = editor.getSelection();
  const url = prompt('Enter URL:', 'https://');
  
  if (url) {
    if (selection) {
      editor.replaceSelection(`[${selection}](${url})`);
    } else {
      const text = prompt('Enter link text:', 'Link text');
      if (text) {
        editor.replaceSelection(`[${text}](${url})`);
      }
    }
  }
  editor.focus();
}

/**
 * Insert an image at cursor position
 */
function insertImage() {
  const url = prompt('Enter image URL:', 'https://');
  
  if (url) {
    const alt = prompt('Enter image description:', 'Image');
    if (alt) {
      editor.replaceSelection(`![${alt}](${url})`);
    }
  }
  editor.focus();
}

/**
 * Save the current wiki entry
 */
function saveWikiEntry() {
  const titleInput = document.getElementById('wiki-title');
  const tagsInput = document.getElementById('wiki-tags');
  
  if (!titleInput || !titleInput.value.trim()) {
    showNotification('Please enter a title for your wiki entry', 'error');
    return;
  }
  
  const content = editor.getValue();
  if (!content.trim()) {
    showNotification('Please enter some content for your wiki entry', 'error');
    return;
  }
  
  const tags = tagsInput && tagsInput.value 
    ? tagsInput.value.split(',').map(tag => tag.trim())
    : [];
  
  try {
    // Create wiki post in RDF model
    const postId = rdfModel.createPost({
      type: 'wiki',
      title: titleInput.value.trim(),
      content: content,
      tags: tags
    });
    
    // Try to sync with endpoint
    rdfModel.syncWithEndpoint()
      .catch(error => {
        console.warn('Wiki entry saved locally but failed to sync with endpoint', error);
      });
    
    // Reset form
    titleInput.value = '';
    editor.setValue('');
    if (tagsInput) tagsInput.value = '';
    
    showNotification('Wiki entry saved successfully', 'success');
    
    // Refresh wiki entries list
    loadWikiEntries();
  } catch (error) {
    console.error('Error saving wiki entry:', error);
    showNotification('Failed to save wiki entry: ' + error.message, 'error');
  }
}

/**
 * Load and display wiki entries
 */
function loadWikiEntries() {
  const entriesList = document.querySelector('.wiki-entries');
  if (!entriesList) return;
  
  // Clear existing entries
  entriesList.innerHTML = '<h3>Recent Entries</h3>';
  
  try {
    // Get wiki posts from RDF model
    const entries = rdfModel.getPosts({
      type: 'wiki',
      limit: 10 // Show only the 10 most recent entries
    });
    
    if (entries.length === 0) {
      entriesList.innerHTML += '<p>No wiki entries found.</p>';
      return;
    }
    
    // Create entries list
    const list = document.createElement('ul');
    list.className = 'entries-list';
    
    entries.forEach(entry => {
      const item = document.createElement('li');
      item.className = 'entry-item';
      
      item.innerHTML = `
        <h4 class="entry-title">${entry.title || 'Untitled'}</h4>
        <p class="entry-preview">${entry.content.substring(0, 100)}${entry.content.length > 100 ? '...' : ''}</p>
        <div class="entry-meta">
          <span class="entry-date">${new Date(entry.created).toLocaleString()}</span>
          ${entry.tags.length > 0 ? `<span class="entry-tags">${entry.tags.join(', ')}</span>` : ''}
        </div>
        <button class="view-entry" data-id="${entry.id}">View</button>
        <button class="edit-entry" data-id="${entry.id}">Edit</button>
      `;
      
      // Add click handlers for buttons
      item.querySelector('.view-entry').addEventListener('click', () => viewEntry(entry.id));
      item.querySelector('.edit-entry').addEventListener('click', () => editEntry(entry.id));
      
      list.appendChild(item);
    });
    
    entriesList.appendChild(list);
    
    // Add entries list styles
    if (!document.getElementById('entries-list-styles')) {
      const style = document.createElement('style');
      style.id = 'entries-list-styles';
      style.textContent = `
        .entries-list {
          list-style: none;
          padding: 0;
          margin: 0;
        }
        
        .entry-item {
          padding: 15px;
          margin-bottom: 15px;
          border: 1px solid #eee;
          border-radius: 4px;
          background: white;
        }
        
        .entry-title {
          margin: 0 0 10px 0;
          color: var(--primary-color, #3498db);
        }
        
        .entry-preview {
          margin: 0 0 10px 0;
          color: #666;
        }
        
        .entry-meta {
          display: flex;
          flex-wrap: wrap;
          gap: 10px;
          margin-bottom: 10px;
          font-size: 0.875rem;
          color: #999;
        }
        
        .entry-item button {
          padding: 5px 10px;
          margin-right: 5px;
          background: var(--primary-color, #3498db);
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        }
        
        .entry-item button:hover {
          opacity: 0.9;
        }
      `;
      document.head.appendChild(style);
    }
  } catch (error) {
    console.error('Error loading wiki entries:', error);
    entriesList.innerHTML += `<p class="error">Error loading entries: ${error.message}</p>`;
  }
}

/**
 * View a wiki entry in detail
 */
function viewEntry(id) {
  try {
    // Get wiki entries container
    const entriesContainer = document.querySelector('.wiki-entries');
    if (!entriesContainer) return;
    
    // Get post from RDF model
    const posts = rdfModel.getPosts();
    const post = posts.find(p => p.id === id);
    
    if (!post) {
      showNotification('Entry not found', 'error');
      return;
    }
    
    // Create entry view
    const entryView = document.createElement('div');
    entryView.className = 'entry-detail';
    
    entryView.innerHTML = `
      <div class="entry-toolbar">
        <button class="back-button">Back to list</button>
        <button class="edit-entry" data-id="${post.id}">Edit</button>
      </div>
      <h3 class="entry-title">${post.title || 'Untitled'}</h3>
      <div class="entry-meta">
        <span class="entry-date">${new Date(post.created).toLocaleString()}</span>
        ${post.tags.length > 0 ? `<span class="entry-tags">Tags: ${post.tags.join(', ')}</span>` : ''}
      </div>
      <div class="entry-content">${marked(post.content)}</div>
    `;
    
    // Replace entries list with entry view
    entriesContainer.innerHTML = '';
    entriesContainer.appendChild(entryView);
    
    // Add back button handler
    entryView.querySelector('.back-button').addEventListener('click', loadWikiEntries);
    
    // Add edit button handler
    entryView.querySelector('.edit-entry').addEventListener('click', () => editEntry(post.id));
    
    // Syntax highlighting for code blocks
    entryView.querySelectorAll('pre code').forEach(block => {
      if (window.hljs) {
        window.hljs.highlightBlock(block);
      }
    });
    
    // Add entry detail styles
    if (!document.getElementById('entry-detail-styles')) {
      const style = document.createElement('style');
      style.id = 'entry-detail-styles';
      style.textContent = `
        .entry-detail {
          padding: 20px;
          background: white;
          border-radius: 4px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .entry-toolbar {
          display: flex;
          gap: 10px;
          margin-bottom: 20px;
        }
        
        .entry-toolbar button {
          padding: 5px 10px;
          background: var(--primary-color, #3498db);
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        }
        
        .entry-detail .entry-title {
          margin: 0 0 10px 0;
          font-size: 2rem;
          color: var(--text-color, #2c3e50);
        }
        
        .entry-detail .entry-meta {
          display: flex;
          flex-wrap: wrap;
          gap: 15px;
          margin-bottom: 20px;
          color: #777;
        }
        
        .entry-detail .entry-content {
          line-height: 1.6;
          font-size: 1.1rem;
        }
        
        .entry-detail .entry-content h1,
        .entry-detail .entry-content h2,
        .entry-detail .entry-content h3 {
          margin-top: 1.5em;
          margin-bottom: 0.5em;
        }
        
        .entry-detail .entry-content p {
          margin-bottom: 1em;
        }
        
        .entry-detail .entry-content img {
          max-width: 100%;
        }
        
        .entry-detail .entry-content blockquote {
          border-left: 3px solid #ddd;
          margin-left: 0;
          padding-left: 1em;
          color: #777;
        }
      `;
      document.head.appendChild(style);
    }
  } catch (error) {
    console.error('Error viewing wiki entry:', error);
    showNotification('Error viewing entry: ' + error.message, 'error');
  }
}

/**
 * Edit an existing wiki entry
 */
function editEntry(id) {
  try {
    // Get post from RDF model
    const posts = rdfModel.getPosts();
    const post = posts.find(p => p.id === id);
    
    if (!post) {
      showNotification('Entry not found', 'error');
      return;
    }
    
    // Get form elements
    const titleInput = document.getElementById('wiki-title');
    const tagsInput = document.getElementById('wiki-tags');
    
    if (!titleInput) {
      showNotification('Editor not found', 'error');
      return;
    }
    
    // Populate form with post data
    titleInput.value = post.title || '';
    if (tagsInput) {
      tagsInput.value = post.tags.join(', ');
    }
    
    // Set editor content
    editor.setValue(post.content || '');
    
    // Scroll to editor
    document.querySelector('.wiki-editor').scrollIntoView({
      behavior: 'smooth',
      block: 'start'
    });
    
    // Update save button to handle updates
    const saveButton = document.getElementById('save-wiki');
    if (saveButton) {
      // Remove existing click listeners
      const newSaveButton = saveButton.cloneNode(true);
      saveButton.parentNode.replaceChild(newSaveButton, saveButton);
      
      // Add new click listener for updating
      newSaveButton.addEventListener('click', () => updateWikiEntry(id));
    }
    
    showNotification('Editing entry: ' + post.title, 'info');
  } catch (error) {
    console.error('Error editing wiki entry:', error);
    showNotification('Error editing entry: ' + error.message, 'error');
  }
}

/**
 * Update an existing wiki entry
 */
function updateWikiEntry(id) {
  const titleInput = document.getElementById('wiki-title');
  const tagsInput = document.getElementById('wiki-tags');
  
  if (!titleInput || !titleInput.value.trim()) {
    showNotification('Please enter a title for your wiki entry', 'error');
    return;
  }
  
  const content = editor.getValue();
  if (!content.trim()) {
    showNotification('Please enter some content for your wiki entry', 'error');
    return;
  }
  
  const tags = tagsInput && tagsInput.value 
    ? tagsInput.value.split(',').map(tag => tag.trim())
    : [];
  
  try {
    // First delete the existing post
    rdfModel.deletePost(id);
    
    // Then create a new post with the same ID (simulating an update)
    const postData = {
      type: 'wiki',
      title: titleInput.value.trim(),
      content: content,
      tags: tags
    };
    
    // Add custom ID field for the RDF model to use
    postData.customId = id;
    
    // Create updated wiki post
    rdfModel.createPost(postData);
    
    // Try to sync with endpoint
    rdfModel.syncWithEndpoint()
      .catch(error => {
        console.warn('Wiki entry updated locally but failed to sync with endpoint', error);
      });
    
    // Reset form
    titleInput.value = '';
    editor.setValue('');
    if (tagsInput) tagsInput.value = '';
    
    // Reset save button to handle new entries
    const saveButton = document.getElementById('save-wiki');
    if (saveButton) {
      // Remove existing click listeners
      const newSaveButton = saveButton.cloneNode(true);
      saveButton.parentNode.replaceChild(newSaveButton, saveButton);
      
      // Add new click listener for saving
      newSaveButton.addEventListener('click', saveWikiEntry);
    }
    
    showNotification('Wiki entry updated successfully', 'success');
    
    // Refresh wiki entries list
    loadWikiEntries();
  } catch (error) {
    console.error('Error updating wiki entry:', error);
    showNotification('Failed to update wiki entry: ' + error.message, 'error');
  }
}

// Initialize wiki editor when the view is shown
document.addEventListener('routeChange', (e) => {
  if (e.detail.to === 'wiki-view') {
    setTimeout(() => {
      initializeWikiEditor();
      loadWikiEntries();
    }, 100);
  }
});

================
File: src/js/ui/views/yasgui-view.js
================
// src/js/ui/views/yasgui-view.js
import Yasgui from '@triply/yasgui';
import '@triply/yasgui/build/yasgui.min.css';
import { state } from '../../core/state.js';
import { ErrorHandler } from '../../core/errors.js';

// Global instance reference
let yasguiInstance = null;

/**
 * Initialize the YASGUI component
 */
function initializeYasguiComponent() {
  const container = document.getElementById('yasgui-container');
  if (!container) {
    console.error('YASGUI container not found');
    return;
  }

  try {
    // Skip if already initialized
    if (yasguiInstance) {
      console.log('YASGUI already initialized');
      return;
    }

    // Clear container
    container.innerHTML = '';

    // Get endpoint configuration
    const endpoints = state.get('endpoints') || [];
    const activeEndpoint = endpoints.find(e => e.type === 'query' && e.status === 'active');

    // Create minimal configuration
    const config = {
      requestConfig: {
        endpoint: activeEndpoint ? activeEndpoint.url : 'http://localhost:4030/semem/query',
        method: 'POST'
      }
    };

    // Add authentication if needed
    if (activeEndpoint && activeEndpoint.credentials) {
      const authString = btoa(activeEndpoint.credentials.user + ':' + activeEndpoint.credentials.password);
      config.requestConfig.headers = {
        'Authorization': 'Basic ' + authString
      };
    }

    // Create the YASGUI instance
    yasguiInstance = new Yasgui(container, config);

    // Set default query
    const defaultQuery = `PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX squirt: <http://purl.org/stuff/squirt/>

SELECT ?subject ?predicate ?object 
WHERE {
  ?subject ?predicate ?object
} 
LIMIT 10`;

    // Set the query for the first tab
    const tab = yasguiInstance.getTab();
    if (tab && tab.yasqe) {
      tab.yasqe.setValue(defaultQuery);
    }

    console.log('YASGUI initialized successfully');
  } catch (error) {
    ErrorHandler.handle(error);
    console.error('Failed to initialize YASGUI:', error);
    container.innerHTML = '<div class="error-message">Failed to initialize SPARQL editor: ' + error.message + '</div>';
  }
}

// Make function available globally
window.initializeYasguiComponent = initializeYasguiComponent;

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  // Add a button to initialize YASGUI for explicit user action
  const container = document.getElementById('yasgui-container');
  if (container) {
    container.innerHTML = `
      <div class="yasgui-init">
        <button type="button" onclick="window.initializeYasguiComponent()" class="button-primary">
          Load SPARQL Query Editor
        </button>
      </div>
    `;
  }
});

// Export for module usage
export { initializeYasguiComponent as initializeYasguiView };

================
File: src/js/utils/utils.js
================
export const namespaces = {
  rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
  rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
  dc: 'http://purl.org/dc/terms/',
  foaf: 'http://xmlns.com/foaf/0.1/',
  squirt: 'http://purl.org/stuff/squirt/'
};

export function generateNid(content) {
  const date = new Date().toISOString().split('T')[0];
  const hash = hashContent(content);
  return `http://purl.org/stuff/squirt/nid_${date}_${hash}`;
}

function hashContent(content) {
  return Array.from(content)
    .reduce((hash, char) => {
      return ((hash << 5) - hash) + char.charCodeAt(0) | 0;
    }, 0)
    .toString(16)
    .slice(0, 4);
}

================
File: src/js/app.js
================
// Import dependencies with ES module syntax
import { setupForms } from './ui/components/forms.js';
import { initializeRouter } from './router.js';
import { endpointManager } from './services/sparql/endpoints.js'; // Import singleton
import { state } from './core/state.js';
import { ErrorHandler } from './core/errors.js';
import { rdfModel } from './services/rdf/rdf-model.js';
import { initializeNotifications } from './ui/components/notifications.js';
import { initializeSettingsView } from './ui/views/settings.js';
import { VIEWS } from './core/views.js';

// Import CSS
import '../css/styles.css';
import '../css/form-styles.css';
import '../css/yasgui-styles.css';
import '../css/layout-fixes.css';
import '../css/mobile-fixes.css';

// Import view components
import './ui/views/wiki-editor.js';
import './ui/views/yasgui-view.js';

// Initialize the application when DOM is loaded
document.addEventListener('DOMContentLoaded', async () => {
  try {
    await initializeApp();
  } catch (error) {
    ErrorHandler.handle(error);
  }
});

// Also reinitialize endpoints when visibility changes (for page revisits)
document.addEventListener('visibilitychange', async () => {
  if (document.visibilityState === 'visible') {
    console.log('Page visibility changed to visible, reinitializing endpoints');
    try {
      // Reinitialize endpoints to force reload from config
      await endpointManager.initialize();
    } catch (error) {
      ErrorHandler.handle(error);
    }
  }
});

/**
 * Initialize the application
 */
async function initializeApp() {
  console.log('Initializing application...');
  
  try {
    // Set up the application structure
    setupViews();
    setupNavigation();
    setupHamburgerMenu();
    setupResponsiveNavigation();
    
    // Initialize notifications system
    initializeNotifications();
    
    // Initialize UI components
    setupForms();
    
    // Initialize view-specific components
    initializeSettingsView();
    
    // Initialize routing
    initializeRouter();
    
    // Initialize services - use the singleton instance
    await endpointManager.initialize();
    
    // Register service worker for PWA support
    registerServiceWorker();
    
    // Check for share target (for mobile devices)
    checkForShareTarget();
    
    console.log('Application initialized successfully');
  } catch (error) {
    console.error('Error initializing application:', error);
    ErrorHandler.handle(error);
  }
}

/**
 * Set up application views
 */
function setupViews() {
  const main = document.querySelector('main');
  if (!main) {
    throw new Error('Main element not found');
  }

  // Create any missing view containers
  Object.values(VIEWS).forEach(viewId => {
    if (typeof viewId !== 'string' || !viewId.endsWith('-view')) {
      throw new Error(`Invalid view ID format: ${viewId}`);
    }

    if (!document.getElementById(viewId)) {
      const view = document.createElement('div');
      view.id = viewId;
      view.classList.add('view', 'hidden');
      main.appendChild(view);
    }
  });
  
  // Add wiki view content if it doesn't exist
  const wikiView = document.getElementById(VIEWS.WIKI);
  if (wikiView && wikiView.children.length === 0) {
    wikiView.innerHTML = `
      <h2>Wiki</h2>
      <div class="wiki-editor">
        <div class="form-field">
          <label for="wiki-title">Title</label>
          <input type="text" id="wiki-title" name="title" required>
        </div>
        <div class="form-field">
          <label for="wiki-content">Content (Markdown supported)</label>
          <textarea id="wiki-content" name="content" rows="10" required></textarea>
        </div>
        <div class="form-field">
          <label for="wiki-tags">Tags (comma separated)</label>
          <input type="text" id="wiki-tags" name="tags" placeholder="tag1, tag2, tag3">
        </div>
        <button type="button" id="save-wiki">Save</button>
      </div>
      <div class="wiki-entries"></div>
    `;
  }
  
  // Add yasgui view content if it doesn't exist
  const yasguiView = document.getElementById(VIEWS.YASGUI);
  if (yasguiView && yasguiView.children.length === 0) {
    yasguiView.innerHTML = `
      <h2>SPARQL Query Editor</h2>
      <div id="yasgui-container" class="yasgui-container"></div>
    `;
  }
  
  // Add profile view content if it doesn't exist
  const profileView = document.getElementById(VIEWS.PROFILE);
  if (profileView && profileView.children.length === 0) {
    profileView.innerHTML = `
      <h2>Profile</h2>
      <form id="profile-form" class="form-group">
        <div class="form-field">
          <label for="profile-name">Name</label>
          <input type="text" id="profile-name" name="name">
        </div>
        <div class="form-field">
          <label for="profile-email">Email</label>
          <input type="email" id="profile-email" name="email">
        </div>
        <div class="form-field">
          <label for="profile-bio">Bio</label>
          <textarea id="profile-bio" name="bio"></textarea>
        </div>
        <button type="submit">Save Profile</button>
      </form>
    `;
  }
  
  // Add storage section to settings view if it doesn't exist
  const settingsView = document.getElementById(VIEWS.SETTINGS);
  if (settingsView && !settingsView.querySelector('.storage-section')) {
    const storageSection = document.createElement('div');
    storageSection.className = 'settings-section storage-section';
    storageSection.innerHTML = `
      <h3>Storage</h3>
      <div id="storage-usage">Calculating storage usage...</div>
    `;
    settingsView.appendChild(storageSection);
  }
}

/**
 * Set up navigation links
 */
function setupNavigation() {
  document.querySelectorAll('nav a').forEach(link => {
    link.addEventListener('click', (e) => {
      e.preventDefault();
      const viewId = e.target.getAttribute('data-view');
      if (viewId) {
        window.location.hash = viewId.replace('-view', '');
        
        // If we have a hamburger menu, close it when navigating
        const menu = document.querySelector('.hamburger-menu');
        if (menu && menu.classList.contains('active')) {
          menu.classList.remove('active');
          document.querySelector('nav').classList.remove('visible');
        }
      }
    });
  });
}

/**
 * Setup responsive navigation for mobile and desktop
 */
function setupResponsiveNavigation() {
  // Setup hamburger menu toggle
  const hamburgerButton = document.querySelector('.hamburger-button');
  const hamburgerMenu = document.querySelector('.hamburger-menu');
  const nav = document.querySelector('nav');
  
  if (hamburgerButton && hamburgerMenu && nav) {
    hamburgerButton.addEventListener('click', () => {
      hamburgerMenu.classList.toggle('active');
      nav.classList.toggle('visible');
    });
    
    // Close menu when clicking on a link
    nav.querySelectorAll('a').forEach(link => {
      link.addEventListener('click', () => {
        hamburgerMenu.classList.remove('active');
        nav.classList.remove('visible');
      });
    });
    
    // Close menu when clicking outside
    document.addEventListener('click', (event) => {
      if (!hamburgerMenu.contains(event.target) && !nav.contains(event.target)) {
        hamburgerMenu.classList.remove('active');
        nav.classList.remove('visible');
      }
    });
  }
  
  // Active nav highlighting
  function setActiveNavItem(viewId) {
    const navLinks = document.querySelectorAll('nav a');
    navLinks.forEach(link => {
      if (link.getAttribute('data-view') === viewId) {
        link.classList.add('active');
      } else {
        link.classList.remove('active');
      }
    });
  }
  
  // Add setActiveNavItem when route changes
  document.addEventListener('routeChange', (e) => {
    if (e.detail && e.detail.to) {
      setActiveNavItem(e.detail.to);
    }
  });
  
  // Initial active state based on current view
  const currentView = window.location.hash.slice(1) || 'post';
  setActiveNavItem(`${currentView}-view`);
  
  // Add theme detection code
  function setThemeBasedOnPreference() {
    const savedTheme = localStorage.getItem('squirt_theme');
    if (savedTheme === 'dark') {
      document.documentElement.setAttribute('data-theme', 'dark');
    } else if (savedTheme === 'light') {
      document.documentElement.setAttribute('data-theme', 'light');
    } else if (savedTheme === 'system' || !savedTheme) {
      // Check system preference
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.documentElement.setAttribute('data-theme', 'dark');
      } else {
        document.documentElement.setAttribute('data-theme', 'light');
      }
      
      // Listen for system preference changes
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        const theme = e.matches ? 'dark' : 'light';
        document.documentElement.setAttribute('data-theme', theme);
      });
    }
  }
  
  // Initialize theme
  setThemeBasedOnPreference();
  
  // Add theme selector functionality
  const themeSelector = document.getElementById('theme-selector');
  if (themeSelector) {
    themeSelector.addEventListener('change', (e) => {
      const selectedTheme = e.target.value;
      localStorage.setItem('squirt_theme', selectedTheme);
      
      if (selectedTheme === 'system') {
        setThemeBasedOnPreference();
      } else {
        document.documentElement.setAttribute('data-theme', selectedTheme);
      }
    });
  }
}

/**
 * Set up hamburger menu for mobile devices
 */
function setupHamburgerMenu() {
  // Check if hamburger button already exists
  if (document.querySelector('.hamburger-button')) return;
  
  // Create hamburger button
  const hamburgerButton = document.createElement('button');
  hamburgerButton.className = 'hamburger-button';
  hamburgerButton.setAttribute('aria-label', 'Menu');
  hamburgerButton.innerHTML = `
    <span></span>
    <span></span>
    <span></span>
  `;
  
  // Add button to header
  const header = document.querySelector('header');
  if (header) {
    // Add menu wrapper with class for styling
    const menuWrapper = document.createElement('div');
    menuWrapper.className = 'hamburger-menu';
    menuWrapper.appendChild(hamburgerButton);
    header.appendChild(menuWrapper);
    
    // Add toggle functionality
    hamburgerButton.addEventListener('click', () => {
      menuWrapper.classList.toggle('active');
      document.querySelector('nav').classList.toggle('visible');
    });
    
    // Add CSS if not already present
    if (!document.getElementById('hamburger-style')) {
      const style = document.createElement('style');
      style.id = 'hamburger-style';
      style.textContent = `
        .hamburger-menu {
          display: none;
        }
        
        /* Mobile styles */
        @media (max-width: 768px) {
          .hamburger-menu {
            display: block;
            position: relative;
            z-index: 100;
          }
          
          .hamburger-button {
            background: none;
            border: none;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 24px;
            padding: 0;
            width: 30px;
          }
          
          .hamburger-button span {
            background-color: var(--text-color);
            border-radius: 3px;
            display: block;
            height: 3px;
            transition: all 0.3s ease;
            width: 100%;
          }
          
          .hamburger-menu.active .hamburger-button span:nth-child(1) {
            transform: translateY(10px) rotate(45deg);
          }
          
          .hamburger-menu.active .hamburger-button span:nth-child(2) {
            opacity: 0;
          }
          
          .hamburger-menu.active .hamburger-button span:nth-child(3) {
            transform: translateY(-10px) rotate(-45deg);
          }
          
          nav {
            background: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: none;
            flex-direction: column;
            gap: 0;
            left: 0;
            position: absolute;
            top: 100%;
            width: 100%;
          }
          
          nav.visible {
            display: flex;
          }
          
          nav a {
            border-bottom: 1px solid #eee;
            padding: 1rem;
            text-align: center;
          }
        }
      `;
      document.head.appendChild(style);
    }
  }
}

/**
 * Register service worker for PWA support
 */
function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/service-worker.js')
        .then(registration => {
          console.log('Service Worker registered with scope:', registration.scope);
        })
        .catch(error => {
          console.error('Service Worker registration failed:', error);
        });
    });
  }
}

/**
 * Check if the app was launched from a share target
 */
function checkForShareTarget() {
  // Check if this is a PWA launch with share data
  if (window.launchQueue) {
    window.launchQueue.setConsumer(async params => {
      if (params.files && params.files.length) {
        // Handle shared files
        const file = params.files[0];
        // Depending on the file type, process accordingly
        if (file.type.includes('text')) {
          const text = await file.text();
          // Pre-fill the post form
          const contentField = document.getElementById('content-field');
          if (contentField) {
            contentField.value = text;
          }
        }
      } else if (params.data && params.data.url) {
        // Handle shared URL
        const form = document.getElementById('post-form');
        const typeSelector = form.querySelector('[name="post-type"]');
        if (typeSelector) {
          typeSelector.value = 'link';
          updateFormFields(form, 'link');
          
          const urlField = form.querySelector('[name="url"]');
          if (urlField) {
            urlField.value = params.data.url;
          }
          
          if (params.data.title) {
            const titleField = form.querySelector('[name="title"]');
            if (titleField) {
              titleField.value = params.data.title;
            }
          }
          
          if (params.data.text) {
            const contentField = form.querySelector('[name="content"]');
            if (contentField) {
              contentField.value = params.data.text;
            }
          }
        }
      }
      
      // Switch to post view
      window.location.hash = 'post';
    });
  }
  
  // Check URL parameters for shared content
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.has('text') || urlParams.has('url') || urlParams.has('title')) {
    const form = document.getElementById('post-form');
    if (form) {
      // If there's a URL, use the link post type
      if (urlParams.has('url')) {
        const typeSelector = form.querySelector('[name="post-type"]');
        if (typeSelector) {
          typeSelector.value = 'link';
          // Make sure form fields are updated for link type
          if (typeof updateFormFields === 'function') {
            updateFormFields(form, 'link');
          }
          
          // Set the URL field
          setTimeout(() => {
            const urlField = form.querySelector('[name="url"]');
            if (urlField) {
              urlField.value = urlParams.get('url');
            }
          }, 100);
        }
      }
      
      // Set the title if provided
      if (urlParams.has('title')) {
        setTimeout(() => {
          const titleField = form.querySelector('[name="title"]');
          if (titleField) {
            titleField.value = urlParams.get('title');
          }
        }, 100);
      }
      
      // Set the content field if provided
      if (urlParams.has('text')) {
        setTimeout(() => {
          const contentField = form.querySelector('[name="content"]');
          if (contentField) {
            contentField.value = urlParams.get('text');
          }
        }, 100);
      }
      
      // Switch to post view
      window.location.hash = 'post';
    }
  }
}

================
File: src/js/router.js
================
// src/js/router.js
import { state } from './core/state.js';
import { ErrorHandler } from './core/errors.js';
import { VIEWS } from './core/views.js';

/**
 * Initialize the router
 */
export function initializeRouter() {
    const VALID_ROUTES = Object.values(VIEWS).map(view => view.replace('-view', ''));

    window.addEventListener('hashchange', () => {
        handleRoute(window.location.hash, VALID_ROUTES);
    });

    handleRoute(window.location.hash, VALID_ROUTES);
}

/**
 * Handle route changes
 */
function handleRoute(hash, validRoutes) {
    try {
        const route = hash.slice(1) || 'post';
        
        if (!validRoutes.includes(route)) {
            throw new Error(`Invalid route: ${route}`);
        }

        const viewId = `${route}-view`;
        const view = document.getElementById(viewId);
        
        if (!view) {
            throw new Error(`View not found: ${viewId}`);
        }

        const currentView = state.get('currentView');
        
        // Fire route change event
        const event = new CustomEvent('routeChange', {
            detail: {
                from: currentView,
                to: viewId
            },
            cancelable: true
        });

        if (!document.dispatchEvent(event)) {
            if (currentView) {
                window.location.hash = currentView.replace('-view', '');
            }
            return;
        }

        state.update('previousView', currentView);
        state.update('currentView', viewId);

        // Hide all views
        Object.values(VIEWS).forEach(id => {
            const viewElement = document.getElementById(id);
            if (viewElement) {
                viewElement.classList.add('hidden');
            }
        });
        
        // Show requested view
        view.classList.remove('hidden');
        
        // Special handling for YASGUI
        if (viewId === VIEWS.YASGUI) {
            // Import the YASGUI view module and initialize it
            import('./ui/views/yasgui-view.js')
                .then(module => {
                    if (typeof module.initializeYasguiView === 'function') {
                        // Delay to ensure view is visible
                        setTimeout(() => module.initializeYasguiView(), 100);
                    }
                })
                .catch(error => {
                    console.error('Error loading YASGUI module:', error);
                });
        }

    } catch (error) {
        ErrorHandler.handle(error);
        if (hash !== '#post') {
            window.location.hash = '#post';
        }
    }
}

================
File: src/config.json
================
[
    {
        "name": "local query",
        "type": "query",
        "url": "http://localhost:4030/semem/query",
        "credentials": {
            "user": "admin",
            "password": "admin123"
        }
    },
    {
        "name": "local update",
        "type": "update",
        "url": "http://localhost:4030/semem/update",
        "credentials": {
            "user": "admin",
            "password": "admin123"
        }
    }
]

================
File: test/spec/about.md
================
npm test -- tests/unit/RunCommand.spec.js

================
File: test/spec/sparql.spec.js
================
import { postToSparql, querySparql } from '../../src/js/services/sparql/sparql.js';
import rdf from 'rdf-ext';

describe('SPARQL Operations', () => {
  const testDataset = rdf.dataset();
  const testSubject = rdf.namedNode('http://example.org/test');
  const testPredicate = rdf.namedNode('http://example.org/name');
  const testObject = rdf.literal('Test Entry');

  beforeEach(() => {
    testDataset.add(rdf.quad(testSubject, testPredicate, testObject));
  });

  it('should successfully post data to SPARQL endpoint', async () => {
    try {
      const result = await postToSparql(testDataset);
      expect(result).toBe(true);
    } catch (error) {
      fail('Should not throw error: ' + error.message);
    }
  });

  it('should verify posted data with query', async () => {
    const query = `
      SELECT ?o 
      WHERE { 
        <http://example.org/test> <http://example.org/name> ?o .
      }
    `;

    try {
      const result = await querySparql(query);
      expect(result.results.bindings.length).toBeGreaterThan(0);
      expect(result.results.bindings[0].o.value).toBe('Test Entry');
    } catch (error) {
      fail('Should not throw error: ' + error.message);
    }
  });

  it('should handle SPARQL syntax errors gracefully', async () => {
    const badQuery = 'SELECT * WHERE { INVALID SYNTAX }';
    
    try {
      await querySparql(badQuery);
      fail('Should throw error for invalid query');
    } catch (error) {
      expect(error).toBeDefined();
      expect(error.message).toMatch(/SPARQL query failed: 400 Parse error:/);
      expect(error.message).toContain('SELECT * WHERE { INVALID SYNTAX }');
      expect(error.message).toMatch(/Encountered " "in" "IN "" at line 1, column \d+/);
    }
  });

  it('should handle network errors gracefully', async () => {
    const badEndpoint = 'http://nonexistent-endpoint:3030/sparql';
    
    try {
      await fetch(badEndpoint);
      fail('Should throw error for network failure');
    } catch (error) {
      expect(error).toBeDefined();
      expect(error.message).toContain('fetch failed');
    }
  });

  it('should handle empty dataset gracefully', async () => {
    const emptyDataset = rdf.dataset();
    try {
      const result = await postToSparql(emptyDataset);
      expect(result).toBe(true);
    } catch (error) {
      fail('Should not throw error for empty dataset: ' + error.message);
    }
  });
});

================
File: test/spec/sparql1.spec.js
================
import { postToSparql, querySparql, getEndpoint } from '../../src/js/services/sparql/sparql.js';
import { state } from '../../src/js/core/state.js';
import rdf from 'rdf-ext';

// Mock the fetch function
global.fetch = jest.fn();

describe('SPARQL Operations', () => {
  const testDataset = rdf.dataset();
  const testSubject = rdf.namedNode('http://example.org/test');
  const testPredicate = rdf.namedNode('http://example.org/name');
  const testObject = rdf.literal('Test Entry');

  // Setup mock endpoints in state
  beforeEach(() => {
    testDataset.add(rdf.quad(testSubject, testPredicate, testObject));
    
    // Set up mock endpoints in state
    state.update('endpoints', [
      {
        url: 'http://test-query-endpoint:3030/sparql',
        label: 'Test Query Endpoint',
        type: 'query',
        status: 'active'
      },
      {
        url: 'http://test-update-endpoint:3030/sparql',
        label: 'Test Update Endpoint',
        type: 'update',
        status: 'active'
      }
    ]);
    
    // Reset mock fetch
    global.fetch.mockReset();
  });

  it('should successfully post data to SPARQL endpoint', async () => {
    // Mock successful POST response
    global.fetch.mockResolvedValueOnce({
      ok: true,
      status: 200,
      text: async () => 'Success'
    });

    const result = await postToSparql(testDataset);
    expect(result).toBe(true);
    
    // Verify fetch was called correctly
    expect(fetch).toHaveBeenCalledTimes(1);
    expect(fetch.mock.calls[0][0]).toBe('http://test-update-endpoint:3030/sparql');
    expect(fetch.mock.calls[0][1].method).toBe('POST');
    expect(fetch.mock.calls[0][1].headers['Content-Type']).toBe('application/sparql-update');
  });

  it('should verify posted data with query', async () => {
    const query = `
      SELECT ?o
      WHERE {
        <http://example.org/test> <http://example.org/name> ?o .
      }
    `;

    // Mock successful query response
    global.fetch.mockResolvedValueOnce({
      ok: true,
      status: 200,
      json: async () => ({
        results: {
          bindings: [
            {
              o: { 
                type: 'literal',
                value: 'Test Entry' 
              }
            }
          ]
        }
      })
    });

    const result = await querySparql(query);
    expect(result.results.bindings.length).toBeGreaterThan(0);
    expect(result.results.bindings[0].o.value).toBe('Test Entry');
    
    // Verify fetch was called correctly
    expect(fetch).toHaveBeenCalledTimes(1);
    expect(fetch.mock.calls[0][0]).toBe('http://test-query-endpoint:3030/sparql');
    expect(fetch.mock.calls[0][1].method).toBe('POST');
    expect(fetch.mock.calls[0][1].headers['Content-Type']).toBe('application/sparql-query');
  });

  it('should handle SPARQL syntax errors gracefully', async () => {
    const badQuery = 'SELECT * WHERE { INVALID SYNTAX }';

    // Mock error response
    global.fetch.mockResolvedValueOnce({
      ok: false,
      status: 400,
      text: async () => 'Parse error: Invalid syntax at line 1'
    });

    try {
      await querySparql(badQuery);
      fail('Should throw error for invalid query');
    } catch (error) {
      expect(error).toBeDefined();
      expect(error.message).toContain('SPARQL query failed: 400');
      expect(error.message).toContain('Parse error:');
    }
  });

  it('should handle network errors gracefully', async () => {
    global.fetch.mockRejectedValueOnce(new Error('Failed to fetch'));

    try {
      await querySparql('SELECT * WHERE { ?s ?p ?o }');
      fail('Should throw error for network failure');
    } catch (error) {
      expect(error).toBeDefined();
    }
  });

  it('should handle empty dataset gracefully', async () => {
    const emptyDataset = rdf.dataset();
    
    // Mock successful POST response
    global.fetch.mockResolvedValueOnce({
      ok: true,
      status: 200,
      text: async () => 'Success'
    });
    
    const result = await postToSparql(emptyDataset);
    expect(result).toBe(true);
    
    // Verify fetch was called with empty dataset
    expect(fetch).toHaveBeenCalledTimes(1);
  });
});

================
File: test/setup.js
================
// Setup file for Jest tests
global.fetch = jest.fn();

// Mock the window object for browser-like environment
Object.defineProperty(window, 'location', {
  value: {
    hash: ''
  },
  writable: true
});

// Silence console errors during tests
console.error = jest.fn();
console.warn = jest.fn();

================
File: .babelrc
================
{
  "presets": [
    ["@babel/preset-env", {
      "targets": {
        "node": "current"
      }
    }]
  ],
  "plugins": [
    "@babel/plugin-transform-modules-commonjs"
  ]
}

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

================
File: about.md
================
```sh
cd ~/github-danny/hyperdata/packages/farelo/squirt

npm run build
npm run dev

npm run rp

```

================
File: babel.config.json
================
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "browsers": [
            "last 2 chrome versions",
            "last 2 firefox versions",
            "last 2 safari versions"
          ]
        },
        "modules": false,
        "useBuiltIns": "usage",
        "corejs": 3
      }
    ]
  ]
}

================
File: jasmine.json
================
{
    "spec_dir": "test",
    "spec_files": [
        "**/*[sS]pec.js"
    ],
    "helpers": [],
    "stopSpecOnExpectationFailure": true,
    "random": false
}

================
File: jest.config.js
================
/** @type {import('jest').Config} */
module.exports = {
  transform: {
    '^.+\\.(js|jsx)$': 'babel-jest'
  },
  testEnvironment: 'jsdom',
  moduleFileExtensions: ['js', 'json'],
  transformIgnorePatterns: ['/node_modules/(?!(@rdfjs|rdf-ext)/)'],
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1'
  },
  testMatch: ['**/test/spec/**/*.spec.js'],
  setupFiles: ['./test/setup.js']
};

================
File: package.json
================
{
  "name": "squirt",
  "version": "0.1.0",
  "type": "commonjs",
  "scripts": {
    "build": "webpack --mode production",
    "dev": "webpack serve --mode development",
    "test": "jest",
    "test:jasmine": "jasmine --config=jasmine.json",
    "rp": "tree --gitignore  -I 'knowledge|prompts|reference' > tree.xml && repomix -c repomix.config.json ."
  },
  "dependencies": {
    "@rdfjs/data-model": "^2.0.1",
    "@rdfjs/namespace": "^2.0.0",
    "@rdfjs/parser-n3": "^2.0.1",
    "@triply/yasgui": "^4.2.28",
    "codemirror": "^5.65.12",
    "cors": "^2.8.5",
    "marked": "^4.3.0",
    "rdf-ext": "^2.5.0"
  },
  "devDependencies": {
    "@babel/core": "^7.26.0",
    "@babel/plugin-transform-modules-commonjs": "^7.26.3",
    "@babel/preset-env": "^7.26.0",
    "babel-jest": "^29.7.0",
    "babel-loader": "^9.2.1",
    "chai": "^4.3.10",
    "css-loader": "^6.11.0",
    "file-loader": "^6.2.0",
    "html-webpack-plugin": "^5.6.0",
    "jasmine": "^5.1.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "mini-css-extract-plugin": "^2.9.2",
    "style-loader": "^3.3.4",
    "url-loader": "^4.1.1",
    "webpack": "^5.89.0",
    "webpack-cli": "^5.1.4",
    "webpack-dev-server": "^4.15.1"
  }
}

================
File: tree.xml
================
.
├── about.md
├── babel.config.json
├── jasmine.json
├── jest.config.js
├── package.json
├── package-lock.json
├── public
│   ├── favicon.ico
│   ├── index.html
│   ├── main.324fa52b.css
│   ├── main.bundle.js
│   ├── manifest.json
│   └── service-worker.js
├── repomix.config.json
├── squirt_repomix.md
├── src
│   ├── config.json
│   ├── css
│   │   ├── form-styles.css
│   │   ├── layout-fixes.css
│   │   ├── mobile-fixes.css
│   │   ├── styles.css
│   │   └── yasgui-styles.css
│   ├── html
│   │   └── index.html
│   └── js
│       ├── app.js
│       ├── core
│       │   ├── errors.js
│       │   ├── state.js
│       │   └── views.js
│       ├── router.js
│       ├── services
│       │   ├── rdf
│       │   │   ├── rdf-extractor.js
│       │   │   └── rdf-model.js
│       │   ├── sparql
│       │   │   ├── endpoints.js
│       │   │   └── sparql.js
│       │   └── templates
│       │       └── post-article.njk
│       ├── ui
│       │   ├── components
│       │   │   ├── endpoint-indicator.js
│       │   │   ├── endpoints-list.js
│       │   │   ├── forms.js
│       │   │   └── notifications.js
│       │   └── views
│       │       ├── settings.js
│       │       ├── wiki-editor.js
│       │       └── yasgui-view.js
│       └── utils
│           └── utils.js
├── storage
├── test
│   ├── setup.js
│   └── spec
│       ├── about.md
│       ├── sparql1.spec.js
│       └── sparql.spec.js
├── tree.xml
└── webpack.config.js

18 directories, 45 files

================
File: webpack.config.js
================
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
    entry: {
        main: './src/js/app.js'
    },
    output: {
        path: path.resolve('public'),
        filename: '[name].bundle.js',
        clean: true
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules\/(?!@triply).*/, // Allow @triply modules to be processed
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['@babel/preset-env']
                    }
                }
            },
            {
                test: /\.css$/,
                use: [
                    MiniCssExtractPlugin.loader,
                    'css-loader'
                ]
            },
            {
                test: /\.(woff|woff2|eot|ttf|otf)$/i,
                type: 'asset/resource',
                generator: {
                    filename: 'fonts/[name].[hash:8][ext]'
                }
            },
            {
                test: /\.(png|jpg|jpeg|gif|svg)$/i,
                type: 'asset/resource',
                generator: {
                    filename: 'images/[name].[hash:8][ext]'
                }
            }
        ]
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './src/html/index.html',
            favicon: './public/favicon.ico',
            minify: false
        }),
        new MiniCssExtractPlugin({
            filename: '[name].[contenthash:8].css'
        })
    ],
    resolve: {
        extensions: ['.js', '.json'],
        alias: {
            // Add alias for direct imports
            '@triply/yasgui$': path.resolve(__dirname, 'node_modules/@triply/yasgui/build/yasgui.min.js')
        }
    },
    devServer: {
        static: {
            directory: path.join(process.cwd(), 'public')
        },
        compress: true,
        hot: true,
        port: 9002
    },
    optimization: {
        minimize: false // Disable minimization for development
    }
}
