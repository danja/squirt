This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-06T14:46:52.272Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
- Code comments have been removed.

Additional Info:
----------------
User Provided Header:
-----------------------
Squirt repo

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
src/
  core/
    errors/
      error-handler.js
      error-types.js
    events/
      event-bus.js
      event-constants.js
    state/
      index.js
      store.js
    errors.js
    plugin-base.js
    plugin-manager.js
    state.js
    views.js
  css/
    form-styles.css
    layout-fixes.css
    mobile-fixes.css
    plugin-styles.css
    styles.css
    yasgui-styles.css
  domain/
    rdf/
      model.js
  html/
    index.html
  plugins/
    index.js
    wiki-plugin.js
    yasgui-plugin.js
  services/
    endpoints/
      endpoints-service.js
    rdf/
      rdf-extractor.js
      rdf-model.js
    sparql/
      endpoints.js
      sparql-service.js
      sparql.js
    storage/
      storage-service.js
    templates/
      post-article.njk
  ui/
    components/
      endpoint-indicator.js
      endpoints-list.js
      forms.js
      notifications.js
    notifications/
      notifications.js
      router.js
    views/
      settings-view.js
      wiki-view.js
      yasgui-view.js
    router.js
  utils/
    namespaces.js
    utils.js
  app.js
  config.json
test/
  spec/
    about.md
    enpoints.spec.js
    integration-test.js
    rdf-model.spec.js
    refactoring-plan.md
    refactoring-summary.md
    sparql.spec.js
    sparql1.spec.js
  setup.js
.babelrc
.gitignore
about.md
babel.config.json
jasmine.json
jest.config.js
LICENSE
package.json
README.md
tree.xml
webpack.config.js

================================================================
Files
================================================================

================
File: src/core/errors/error-handler.js
================
import { eventBus, EVENTS } from '../events/event-bus.js';
import * as ErrorTypes from './error-types.js';




export class ErrorHandler {
  constructor(eventBus) {
    this.eventBus = eventBus;
    this.errorLog = [];
    this.maxLogSize = 50;
  }










  handle(error, options = {}) {
    const {
      showToUser = true,
      rethrow = false,
      context = null
    } = options;


    const appError = this.normalizeError(error, context);


    this.logError(appError);


    this.eventBus.emit(EVENTS.ERROR_OCCURRED, appError);


    if (showToUser) {
      this.showToUser(appError);
    }


    if (rethrow) {
      throw appError;
    }

    return appError;
  }







  normalizeError(error, context = null) {

    if (error instanceof ErrorTypes.AppError) {
      if (context && !error.details.context) {
        error.details.context = context;
      }
      return error;
    }


    if (error.name === 'NetworkError' || error.message.includes('network') || error.message.includes('fetch')) {
      return new ErrorTypes.NetworkError(
        error.message,
        {
          originalError: error,
          context
        }
      );
    }

    if (error.name === 'SyntaxError' || error.message.includes('syntax')) {
      return new ErrorTypes.ValidationError(
        error.message,
        {
          originalError: error,
          context
        }
      );
    }

    if (error.message.includes('SPARQL') || error.message.includes('endpoint')) {
      return new ErrorTypes.SparqlError(
        error.message,
        {
          originalError: error,
          context
        }
      );
    }

    if (error.message.includes('localStorage') || error.message.includes('storage')) {
      return new ErrorTypes.StorageError(
        error.message,
        {
          originalError: error,
          context
        }
      );
    }


    return new ErrorTypes.AppError(
      error.message,
      'UNKNOWN_ERROR',
      {
        originalError: error,
        stack: error.stack,
        context
      }
    );
  }





  logError(error) {

    console.error('Error:', error);


    this.errorLog.unshift({
      error,
      timestamp: new Date()
    });


    if (this.errorLog.length > this.maxLogSize) {
      this.errorLog = this.errorLog.slice(0, this.maxLogSize);
    }


    this.reportToAnalytics(error);
  }





  showToUser(error) {
    const message = error.getUserMessage();


    this.eventBus.emit(EVENTS.NOTIFICATION_SHOW, {
      type: 'error',
      message,
      duration: 5000,
      error
    });
  }





  reportToAnalytics(error) {


    if (window.errorAnalytics) {
      window.errorAnalytics.push({
        type: error.name,
        code: error.code,
        message: error.message,
        timestamp: new Date().toISOString()
      });
    }
  }





  getErrorLog() {
    return [...this.errorLog];
  }




  clearErrorLog() {
    this.errorLog = [];
  }
}


export const errorHandler = new ErrorHandler(eventBus);


export function createAndHandleError(message, userMessage, code = 'APP_ERROR', options = {}) {
  const error = new ErrorTypes.AppError(message, code);

  if (userMessage) {
    error.setUserMessage(userMessage);
  }

  return errorHandler.handle(error, options);
}


export * from './error-types.js';
export {
  ErrorHandler,
  errorHandler,
  createAndHandleError
} from './error-handler.js';

================
File: src/core/errors/error-types.js
================
export class AppError extends Error {
  constructor(message, code, details = {}) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.details = details;
    this.timestamp = new Date();


    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}




export class NetworkError extends AppError {
  constructor(message, details = {}) {
    super(message, 'NETWORK_ERROR', details);
  }
}




export class SparqlError extends AppError {
  constructor(message, details = {}) {
    super(message, 'SPARQL_ERROR', details);
  }
}




export class StorageError extends AppError {
  constructor(message, details = {}) {
    super(message, 'STORAGE_ERROR', details);
  }
}




export class ConfigError extends AppError {
  constructor(message, details = {}) {
    super(message, 'CONFIG_ERROR', details);
  }
}




export class RDFError extends AppError {
  constructor(message, details = {}) {
    super(message, 'RDF_ERROR', details);
  }
}


import { eventBus, EVENTS } from '../events/event-bus.js';




class ErrorHandler {
  constructor() {
    this.errorLog = [];
  }







  handle(error, options = {}) {
    const { showToUser = true, rethrow = false } = options;


    console.error('Error:', error);


    this.errorLog.unshift({
      error,
      timestamp: new Date()
    });


    eventBus.emit(EVENTS.ERROR_OCCURRED, error);


    if (showToUser && typeof window.showNotification === 'function') {
      window.showNotification(
        error.message || 'An unexpected error occurred',
        'error'
      );
    }


    if (rethrow) {
      throw error;
    }

    return error;
  }
}

export const errorHandler = new ErrorHandler();


export * from './error-types.js';

================
File: src/core/events/event-bus.js
================
import { EVENTS } from './event-constants.js';




class EventBus {
  constructor() {
    this.listeners = new Map();
  }







  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }

    this.listeners.get(event).add(callback);


    return () => {
      const callbacks = this.listeners.get(event);
      if (callbacks) {
        callbacks.delete(callback);
        if (callbacks.size === 0) {
          this.listeners.delete(event);
        }
      }
    };
  }






  emit(event, data) {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      callbacks.forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in event listener for "${event}":`, error);
        }
      });
    }
  }





  removeAllListeners(event) {
    if (event) {
      this.listeners.delete(event);
    } else {
      this.listeners.clear();
    }
  }
}


export const eventBus = new EventBus();


export { EVENTS } from './event-constants.js';

================
File: src/core/events/event-constants.js
================
export const EVENTS = {

    APP_INITIALIZED: 'app:initialized',


    STATE_CHANGED: 'state:changed',


    POST_CREATED: 'rdf:post:created',
    POST_UPDATED: 'rdf:post:updated',
    POST_DELETED: 'rdf:post:deleted',
    MODEL_SYNCED: 'rdf:model:synced',


    ENDPOINT_ADDED: 'endpoint:added',
    ENDPOINT_REMOVED: 'endpoint:removed',
    ENDPOINT_UPDATED: 'endpoint:updated',
    ENDPOINT_STATUS_CHANGED: 'endpoint:status:changed',
    ENDPOINTS_STATUS_CHECKED: 'endpoints:status:checked',
    ENDPOINT_CHECK_REQUESTED: 'endpoint:check:requested',


    SPARQL_QUERY_STARTED: 'sparql:query:started',
    SPARQL_QUERY_COMPLETED: 'sparql:query:completed',
    SPARQL_QUERY_FAILED: 'sparql:query:failed',
    SPARQL_UPDATE_STARTED: 'sparql:update:started',
    SPARQL_UPDATE_COMPLETED: 'sparql:update:completed',
    SPARQL_UPDATE_FAILED: 'sparql:update:failed',


    VIEW_CHANGED: 'ui:view:changed',
    NOTIFICATION_SHOW: 'ui:notification:show',
    FORM_SUBMITTED: 'ui:form:submitted',


    ERROR_OCCURRED: 'error:occurred'
};

================
File: src/core/state/index.js
================
import { eventBus, EVENTS } from '../events/event-bus.js';




class Store {
  constructor(initialState = {}) {
    this.state = initialState;
    this.listeners = new Set();
  }





  getState() {
    return this.state;
  }





  setState(update) {
    this.state = { ...this.state, ...update };
    this.notify();
  }






  subscribe(listener) {
    this.listeners.add(listener);

    return () => {
      this.listeners.delete(listener);
    };
  }




  notify() {
    this.listeners.forEach(listener => {
      try {
        listener(this.state);
      } catch (error) {
        console.error('Error in state listener:', error);
      }
    });


    eventBus.emit(EVENTS.STATE_CHANGED, this.state);
  }
}


const initialState = {
  currentView: null,
  endpoints: [],
  posts: [],
  notifications: []
};


export const store = new Store(initialState);


export const setCurrentView = (viewId) => {
  store.setState({
    previousView: store.getState().currentView,
    currentView: viewId
  });
};

export const setPosts = (posts) => {
  store.setState({ posts });
};

export const addPost = (post) => {
  const posts = [...store.getState().posts, post];
  store.setState({ posts });
};

export const setEndpoints = (endpoints) => {
  store.setState({ endpoints });
};


export const getCurrentView = (state) => state.currentView;
export const getPreviousView = (state) => state.previousView;
export const getEndpoints = (state) => state.endpoints;
export const getPosts = (state) => state.posts;
export const getNotifications = (state) => state.notifications;

================
File: src/core/state/store.js
================
import { eventBus, EVENTS } from '../events/event-bus.js';







export function createStore(reducer, initialState = {}) {
  let state = initialState;
  let listeners = new Set();

  const getState = () => state;

  const dispatch = (action) => {
    state = reducer(state, action);
    listeners.forEach(listener => listener(state));
    eventBus.emit(EVENTS.STATE_CHANGED, { action, state });
    return action;
  };

  const subscribe = (listener) => {
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
    };
  };


  dispatch({ type: '@@INIT' });

  return {
    getState,
    dispatch,
    subscribe
  };
}


import { combineReducers } from './utils.js';
import { endpointsReducer } from './endpoints-reducer.js';
import { postsReducer } from './posts-reducer.js';
import { uiReducer } from './ui-reducer.js';

export const stateReducer = combineReducers({
  endpoints: endpointsReducer,
  posts: postsReducer,
  ui: uiReducer
});







export function combineReducers(reducers) {
  return (state = {}, action) => {
    const nextState = {};
    let hasChanged = false;

    for (const key in reducers) {
      const reducer = reducers[key];
      const previousStateForKey = state[key];
      const nextStateForKey = reducer(previousStateForKey, action);

      nextState[key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    return hasChanged ? nextState : state;
  };
}






export function createAction(type) {
  return (payload) => ({
    type,
    payload
  });
}


import {
  ADD_ENDPOINT,
  REMOVE_ENDPOINT,
  UPDATE_ENDPOINT,
  SET_ENDPOINTS
} from './action-types.js';

const initialState = [];

export function endpointsReducer(state = initialState, action) {
  switch (action.type) {
    case SET_ENDPOINTS:
      return action.payload;

    case ADD_ENDPOINT:

      if (state.some(e => e.url === action.payload.url)) {
        return state;
      }
      return [...state, action.payload];

    case REMOVE_ENDPOINT:
      return state.filter(endpoint => endpoint.url !== action.payload);

    case UPDATE_ENDPOINT:
      return state.map(endpoint =>
        endpoint.url === action.payload.url
          ? { ...endpoint, ...action.payload.updates }
          : endpoint
      );

    default:
      return state;
  }
}


import {
  ADD_POST,
  UPDATE_POST,
  REMOVE_POST,
  SET_POSTS
} from './action-types.js';

const initialState = [];

export function postsReducer(state = initialState, action) {
  switch (action.type) {
    case SET_POSTS:
      return action.payload;

    case ADD_POST:
      return [...state, action.payload];

    case UPDATE_POST:
      return state.map(post =>
        post.id === action.payload.id
          ? { ...post, ...action.payload.updates }
          : post
      );

    case REMOVE_POST:
      return state.filter(post => post.id !== action.payload);

    default:
      return state;
  }
}


import {
  SET_CURRENT_VIEW,
  SET_THEME,
  SHOW_NOTIFICATION,
  HIDE_NOTIFICATION
} from './action-types.js';

const initialState = {
  currentView: 'post-view',
  previousView: null,
  theme: 'light',
  notifications: []
};

export function uiReducer(state = initialState, action) {
  switch (action.type) {
    case SET_CURRENT_VIEW:
      return {
        ...state,
        previousView: state.currentView,
        currentView: action.payload
      };

    case SET_THEME:
      return {
        ...state,
        theme: action.payload
      };

    case SHOW_NOTIFICATION:
      return {
        ...state,
        notifications: [
          ...state.notifications,
          {
            id: Date.now(),
            ...action.payload
          }
        ]
      };

    case HIDE_NOTIFICATION:
      return {
        ...state,
        notifications: state.notifications.filter(n => n.id !== action.payload)
      };

    default:
      return state;
  }
}



export const SET_ENDPOINTS = 'endpoints/SET_ENDPOINTS';
export const ADD_ENDPOINT = 'endpoints/ADD_ENDPOINT';
export const REMOVE_ENDPOINT = 'endpoints/REMOVE_ENDPOINT';
export const UPDATE_ENDPOINT = 'endpoints/UPDATE_ENDPOINT';


export const SET_POSTS = 'posts/SET_POSTS';
export const ADD_POST = 'posts/ADD_POST';
export const UPDATE_POST = 'posts/UPDATE_POST';
export const REMOVE_POST = 'posts/REMOVE_POST';


export const SET_CURRENT_VIEW = 'ui/SET_CURRENT_VIEW';
export const SET_THEME = 'ui/SET_THEME';
export const SHOW_NOTIFICATION = 'ui/SHOW_NOTIFICATION';
export const HIDE_NOTIFICATION = 'ui/HIDE_NOTIFICATION';


import * as types from './action-types.js';
import { createAction } from './utils.js';


export const setEndpoints = createAction(types.SET_ENDPOINTS);
export const addEndpoint = createAction(types.ADD_ENDPOINT);
export const removeEndpoint = createAction(types.REMOVE_ENDPOINT);
export const updateEndpoint = createAction(types.UPDATE_ENDPOINT);


export const setPosts = createAction(types.SET_POSTS);
export const addPost = createAction(types.ADD_POST);
export const updatePost = createAction(types.UPDATE_POST);
export const removePost = createAction(types.REMOVE_POST);


export const setCurrentView = createAction(types.SET_CURRENT_VIEW);
export const setTheme = createAction(types.SET_THEME);
export const showNotification = createAction(types.SHOW_NOTIFICATION);
export const hideNotification = createAction(types.HIDE_NOTIFICATION);


export { createStore } from './store.js';
export { stateReducer } from './reducer.js';
export * from './actions.js';
export * from './selectors.js';


import { createStore } from './store.js';
import { stateReducer } from './reducer.js';

export const store = createStore(stateReducer);



export const getEndpoints = state => state.endpoints;
export const getActiveEndpoints = state => state.endpoints.filter(e => e.status === 'active');
export const getEndpointByUrl = (state, url) => state.endpoints.find(e => e.url === url);
export const getActiveEndpointByType = (state, type) => state.endpoints.find(e => e.type === type && e.status === 'active');


export const getPosts = state => state.posts;
export const getPostById = (state, id) => state.posts.find(p => p.id === id);
export const getPostsByType = (state, type) => state.posts.filter(p => p.type === type);
export const getPostsByTag = (state, tag) => state.posts.filter(p => p.tags.includes(tag));


export const getCurrentView = state => state.ui.currentView;
export const getPreviousView = state => state.ui.previousView;
export const getTheme = state => state.ui.theme;
export const getNotifications = state => state.ui.notifications;

================
File: src/core/errors.js
================
export class AppError extends Error {
    constructor(message, code, details = {}) {
        super(message);
        this.name = 'AppError';
        this.code = code;
        this.details = details;
    }
}




export class SparqlError extends AppError {
    constructor(message, details = {}) {
        super(message, 'SPARQL_ERROR', details);
        this.name = 'SparqlError';
    }
}




export class NetworkError extends AppError {
    constructor(message, details = {}) {
        super(message, 'NETWORK_ERROR', details);
        this.name = 'NetworkError';
    }
}




export const ErrorHandler = {





    handle(error, showToUser = true) {
        console.error('Error:', error);


        if (showToUser) {

            if (typeof window.showNotification === 'function') {
                window.showNotification(this.getUserFriendlyMessage(error), 'error');
            } else {
                console.warn(this.getUserFriendlyMessage(error));
            }
        }


        this.trackError(error);
    },






    getUserFriendlyMessage(error) {

        if (error instanceof SparqlError) {
            return 'SPARQL endpoint error. Please check your endpoint settings.';
        }

        if (error instanceof NetworkError) {
            return 'Network error. Please check your connection and try again.';
        }

        if (error instanceof AppError) {
            return error.message;
        }


        if (error.name === 'NetworkError' || error.message.includes('network') || error.message.includes('fetch')) {
            return 'Network error. Please check your connection and try again.';
        }

        if (error.name === 'SyntaxError' || error.message.includes('syntax')) {
            return 'There was a syntax error in the request. Please try again.';
        }

        if (error.message.includes('endpoint') || error.message.includes('SPARQL')) {
            return 'SPARQL endpoint error. Please check your endpoint settings.';
        }


        return error.userMessage || 'An error occurred. Please try again.';
    },





    trackError(error) {

        if (window.errorLog === undefined) {
            window.errorLog = [];
        }

        window.errorLog.push({
            timestamp: new Date().toISOString(),
            message: error.message,
            stack: error.stack,
            type: error.name
        });
    },








    createError(message, userMessage, code = 'APP_ERROR') {
        const error = new AppError(message, code);
        error.userMessage = userMessage;
        return error;
    }
};

================
File: src/core/plugin-base.js
================
export class PluginBase {





  constructor(id, options = {}) {
    if (!id) {
      throw new Error('Plugin ID is required');
    }

    this.id = id;
    this.options = options;
    this.container = null;
    this.isInitialized = false;
    this.isMounted = false;
    this._eventListeners = [];
  }





  async initialize() {
    if (this.isInitialized) {
      console.warn(`Plugin ${this.id} is already initialized`);
      return;
    }


    this.isInitialized = true;
  }






  async mount(container) {
    if (!this.isInitialized) {
      throw new Error(`Plugin ${this.id} must be initialized before mounting`);
    }

    if (this.isMounted) {
      console.warn(`Plugin ${this.id} is already mounted`);
      return;
    }

    if (!container) {
      throw new Error(`Cannot mount plugin ${this.id}: container is required`);
    }

    this.container = container;
    this.isMounted = true;


  }





  async unmount() {
    if (!this.isMounted) {
      return;
    }



    this.container = null;
    this.isMounted = false;
  }





  async destroy() {
    if (this.isMounted) {
      await this.unmount();
    }


    this._eventListeners.forEach(({ target, type, listener, options }) => {
      target.removeEventListener(type, listener, options);
    });
    this._eventListeners = [];



    this.isInitialized = false;
  }








  addEventListener(target, type, listener, options) {
    target.addEventListener(type, listener, options);
    this._eventListeners.push({ target, type, listener, options });
  }








  removeEventListener(target, type, listener, options) {
    target.removeEventListener(type, listener, options);
    this._eventListeners = this._eventListeners.filter(
      item => !(item.target === target &&
        item.type === type &&
        item.listener === listener)
    );
  }





  updateOptions(newOptions) {
    this.options = { ...this.options, ...newOptions };

  }
}

================
File: src/core/plugin-manager.js
================
import { ErrorHandler } from './errors.js';
import { state } from './state.js';




export class PluginManager {
  constructor() {
    this.plugins = new Map();
    this.containers = new Map();
    this.activePlugins = new Set();


    this.handleRouteChange = this.handleRouteChange.bind(this);
    document.addEventListener('routeChange', this.handleRouteChange);
  }







  register(viewId, pluginInstance, options = {}) {
    const pluginId = pluginInstance.id;

    if (this.plugins.has(pluginId)) {
      throw new Error(`Plugin ${pluginId} is already registered`);
    }

    this.plugins.set(pluginId, {
      instance: pluginInstance,
      viewId,
      options: {
        autoActivate: true,
        ...options
      }
    });

    console.log(`Plugin "${pluginId}" registered for view "${viewId}"`);
  }








  createContainer(viewId, pluginId, containerId = null) {
    const view = document.getElementById(viewId);
    if (!view) {
      throw new Error(`View "${viewId}" not found`);
    }


    const id = containerId || `plugin-container-${pluginId}`;


    let container = document.getElementById(id);
    if (!container) {
      container = document.createElement('div');
      container.id = id;
      container.className = 'plugin-container';
      container.dataset.plugin = pluginId;


      const pluginSection = view.querySelector('.plugins-section');
      if (pluginSection) {
        pluginSection.appendChild(container);
      } else {
        view.appendChild(container);
      }
    }


    this.containers.set(pluginId, container);

    return container;
  }





  async initializeAll() {
    const promises = [];

    for (const [pluginId, pluginData] of this.plugins.entries()) {
      try {
        promises.push(this.initializePlugin(pluginId));
      } catch (error) {
        ErrorHandler.handle(error);
        console.error(`Failed to initialize plugin ${pluginId}:`, error);
      }
    }

    await Promise.all(promises);
    console.log('All plugins initialized');


    const currentView = state.get('currentView');
    if (currentView) {
      this.activatePluginsForView(currentView);
    }
  }






  async initializePlugin(pluginId) {
    const pluginData = this.plugins.get(pluginId);
    if (!pluginData) {
      throw new Error(`Plugin ${pluginId} is not registered`);
    }

    try {
      await pluginData.instance.initialize();
      console.log(`Plugin ${pluginId} initialized successfully`);
    } catch (error) {
      ErrorHandler.handle(error);
      throw new Error(`Failed to initialize plugin ${pluginId}: ${error.message}`);
    }
  }





  async activatePluginsForView(viewId) {

    const pluginsToActivate = [];

    for (const [pluginId, pluginData] of this.plugins.entries()) {
      if (pluginData.viewId === viewId && pluginData.options.autoActivate) {
        pluginsToActivate.push(pluginId);
      }
    }


    for (const pluginId of pluginsToActivate) {
      await this.activatePlugin(pluginId);
    }
  }





  async deactivatePluginsNotInView(currentViewId) {
    const pluginsToDeactivate = [];


    for (const pluginId of this.activePlugins) {
      const pluginData = this.plugins.get(pluginId);
      if (pluginData && pluginData.viewId !== currentViewId) {
        pluginsToDeactivate.push(pluginId);
      }
    }


    for (const pluginId of pluginsToDeactivate) {
      await this.deactivatePlugin(pluginId);
    }
  }






  async activatePlugin(pluginId) {
    const pluginData = this.plugins.get(pluginId);
    if (!pluginData) {
      throw new Error(`Plugin ${pluginId} is not registered`);
    }

    const { instance, viewId } = pluginData;

    if (this.activePlugins.has(pluginId)) {
      console.warn(`Plugin ${pluginId} is already active`);
      return;
    }

    try {

      let container = this.containers.get(pluginId);
      if (!container) {
        container = this.createContainer(viewId, pluginId);
      }


      await instance.mount(container);
      this.activePlugins.add(pluginId);
      console.log(`Plugin ${pluginId} activated successfully`);
    } catch (error) {
      ErrorHandler.handle(error);
      console.error(`Failed to activate plugin ${pluginId}:`, error);
    }
  }






  async deactivatePlugin(pluginId) {
    const pluginData = this.plugins.get(pluginId);
    if (!pluginData) {
      throw new Error(`Plugin ${pluginId} is not registered`);
    }

    const { instance } = pluginData;

    if (!this.activePlugins.has(pluginId)) {
      return;
    }

    try {
      await instance.unmount();
      this.activePlugins.delete(pluginId);
      console.log(`Plugin ${pluginId} deactivated successfully`);
    } catch (error) {
      ErrorHandler.handle(error);
      console.error(`Failed to deactivate plugin ${pluginId}:`, error);
    }
  }






  getPlugin(pluginId) {
    const pluginData = this.plugins.get(pluginId);
    return pluginData ? pluginData.instance : null;
  }





  async handleRouteChange(event) {
    const { to } = event.detail;
    if (!to) return;


    await this.deactivatePluginsNotInView(to);


    await this.activatePluginsForView(to);
  }




  async destroy() {

    for (const pluginId of this.activePlugins) {
      await this.deactivatePlugin(pluginId);
    }


    for (const [pluginId, pluginData] of this.plugins.entries()) {
      try {
        await pluginData.instance.destroy();
      } catch (error) {
        ErrorHandler.handle(error);
        console.error(`Failed to destroy plugin ${pluginId}:`, error);
      }
    }


    this.plugins.clear();
    this.containers.clear();
    this.activePlugins.clear();


    document.removeEventListener('routeChange', this.handleRouteChange);
  }
}


export const pluginManager = new PluginManager();

================
File: src/core/state.js
================
export class StateManager {
    constructor() {
        this.state = {
            endpoints: [],
            currentView: null,
            user: null,
            posts: [],
            drafts: []
        };
        this.listeners = new Map();
    }

    subscribe(key, callback) {
        if (!this.listeners.has(key)) {
            this.listeners.set(key, new Set());
        }
        this.listeners.get(key).add(callback);
    }

    update(key, value) {
        this.state[key] = value;
        if (this.listeners.has(key)) {
            this.listeners.get(key).forEach(callback => callback(value));
        }
    }

    get(key) {
        return this.state[key];
    }
}

export const state = new StateManager();

================
File: src/core/views.js
================
export const VIEWS = {
  POST: 'post-view',
  DEVELOPER: 'developer-view',
  WIKI: 'wiki-view',
  YASGUI: 'yasgui-view',
  PROFILE: 'profile-view',
  SETTINGS: 'settings-view'
};

================
File: src/css/form-styles.css
================
.form-field {
  margin-bottom: var(--spacing-md);
}

.form-field label {
  display: block;
  margin-bottom: var(--spacing-xs);
  font-weight: 500;
  color: var(--text-color);
}

.form-field input,
.form-field textarea,
.form-field select {
  width: 100%;
  padding: var(--spacing-sm) var(--spacing-md);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  background: var(--card-background);
  color: var(--text-color);
  font-size: 1rem;
  font-family: inherit;
  transition: border-color 0.2s, box-shadow 0.2s;
}

.form-field textarea {
  min-height: 120px;
  resize: vertical;
}

.form-field input:focus,
.form-field textarea:focus,
.form-field select:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
}

button[type="submit"],
.button-primary {
  display: inline-block;
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: var(--border-radius);
  padding: var(--spacing-sm) var(--spacing-lg);
  font-size: 1rem;
  cursor: pointer;
  transition: background-color 0.2s;
  text-align: center;
}

button[type="submit"]:hover,
.button-primary:hover {
  background-color: var(--secondary-color);
}


#post-form {
  background: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow);
}

.form-fields {
  margin-top: var(--spacing-md);
}


.input-with-button {
  display: flex;
  gap: var(--spacing-sm);
  flex-direction: column;
}


.extract-button {
  padding: var(--spacing-sm) var(--spacing-md);
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: var(--border-radius);
  cursor: pointer;
  font-size: 0.875rem;
  transition: background-color 0.2s;
}

.extract-button:hover {
  background-color: var(--secondary-color);
}

.extract-button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}


.link-preview {
  margin-top: var(--spacing-md);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  overflow: hidden;
  background: var(--card-background);
}

.preview-card {
  display: flex;
  flex-direction: column;
  max-width: 100%;
}

.preview-image {
  width: 100%;
  max-height: 200px;
  overflow: hidden;
}

.preview-image img {
  width: 100%;
  height: auto;
  object-fit: cover;
}

.preview-content {
  padding: var(--spacing-md);
}

.preview-title {
  margin: 0 0 var(--spacing-sm) 0;
  font-size: 1.25rem;
  color: var(--text-color);
}

.preview-description {
  margin: 0 0 var(--spacing-sm) 0;
  font-size: 0.875rem;
  color: var(--text-color);
  opacity: 0.8;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.preview-site {
  font-size: 0.75rem;
  color: var(--text-color);
  opacity: 0.6;
}

#post-preview {
  margin-top: var(--spacing-lg);
}


.notifications-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1000;
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-width: 300px;
  pointer-events: none;
}

.notification {
  padding: 10px 15px;
  border-radius: var(--border-radius);
  color: white;
  box-shadow: var(--shadow);
  animation: notification-slide-in 0.3s ease-out;
  position: relative;
  overflow: hidden;
  pointer-events: auto;
}

.notification::before {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 3px;
  background: rgba(255, 255, 255, 0.5);
  animation: notification-timer 5s linear forwards;
}

.notification.success {
  background-color: var(--success-color);
}

.notification.error {
  background-color: var(--error-color);
}

.notification.info {
  background-color: var(--primary-color);
}

.notification.warning {
  background-color: #ed8936;
}

.notification.fade-out {
  opacity: 0;
  transform: translateX(100%);
  transition: opacity 0.3s, transform 0.3s;
}

@keyframes notification-slide-in {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes notification-timer {
  from {
    width: 100%;
  }
  to {
    width: 0%;
  }
}


.wiki-editor {
  background: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow);
  margin-bottom: var(--spacing-lg);
}

.wiki-preview {
  margin-top: var(--spacing-lg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  padding: var(--spacing-lg);
  background: var(--card-background);
}

.preview-content {
  max-width: 100%;
  overflow-x: auto;
}

.wiki-entries {
  margin-top: var(--spacing-lg);
}

.editor-toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-xs);
  margin-bottom: var(--spacing-sm);
  padding: var(--spacing-sm);
  background: rgba(0, 0, 0, 0.05);
  border-radius: var(--border-radius);
}


@media (min-width: 768px) {
  .input-with-button {
    flex-direction: row;
  }

  .extract-button {
    flex-shrink: 0;
  }

  .preview-card {
    flex-direction: row;
  }

  .preview-image {
    width: 200px;
    max-height: none;
  }

  .preview-content {
    flex: 1;
  }

  .storage-actions {
    display: flex;
    gap: var(--spacing-md);
  }
}

================
File: src/css/layout-fixes.css
================
.yasgui-container {
  width: 100%;
  height: 700px;
  margin-top: var(--spacing-md);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  overflow: hidden;
}


.yasgui {
  width: 100% !important;
  height: 100% !important;
}


.yasgui .yasr {
  height: 60% !important;
  overflow: auto !important;
}


.yasgui .yasqe {
  height: 40% !important;
}

.yasgui .yasqe .CodeMirror {
  height: 100% !important;
}


.wiki-editor {
  margin-bottom: var(--spacing-lg);
  background: var(--card-background);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow);
}





.CodeMirror {
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  height: auto !important;
  min-height: 200px;
  font-family: monospace;
  line-height: 1.5;
  overflow: hidden !important;
}


.CodeMirror-scroll {
  margin-bottom: 0 !important;
  margin-right: 0 !important;
  padding-bottom: 0 !important;
  padding-right: 0 !important;
  overflow-x: hidden !important;

  height: auto !important;
}


.CodeMirror-sizer {
  margin-bottom: 0 !important;
  border-right-width: 0 !important;
}


.CodeMirror-hscrollbar,
.CodeMirror-vscrollbar,
.CodeMirror-scrollbar-filler,
.CodeMirror-gutter-filler {
  display: none !important;
}


.CodeMirror-wrap pre.CodeMirror-line,
.CodeMirror-wrap pre.CodeMirror-line-like {
  word-wrap: break-word !important;
  white-space: pre-wrap !important;
  word-break: normal !important;
}


.CodeMirror-wrap {
  word-wrap: break-word !important;
}


.editor-toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
  margin-bottom: 10px;
  background: rgba(0, 0, 0, 0.05);
  border-radius: 4px;
  padding: 5px;
}


.wiki-preview {
  margin-top: var(--spacing-lg);
  padding: var(--spacing-md);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  background: var(--card-background);
}


.wiki-entries {
  margin-top: var(--spacing-lg);
}

.entry-item {
  padding: var(--spacing-md);
  margin-bottom: var(--spacing-md);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  background: var(--card-background);
}


@media (min-width: 1024px) {
  .yasgui-container {
    height: 800px;
  }

  .CodeMirror {
    min-height: 300px;
  }


  main {
    max-width: 1200px;
    padding: var(--spacing-xl);
  }

  .view {
    padding: var(--spacing-xl);
  }
}


.form-field textarea,
.wiki-editor .form-field textarea {
  max-width: 100%;
  width: 100%;
  box-sizing: border-box;
}

================
File: src/css/mobile-fixes.css
================
.yasgui-container {
  min-height: 300px;
}


@media (max-width: 767px) {
  .view {
    padding: var(--spacing-md);
  }

  #post-form {
    padding: var(--spacing-md);
  }

  .hamburger-menu {
    display: block;
    position: absolute;
    top: var(--spacing-md);
    right: var(--spacing-md);
    z-index: 101;
  }

  h2 {
    font-size: 1.5rem;
    margin-bottom: var(--spacing-md);
  }


  button[type="submit"],
  .button-primary {
    width: 100%;
    margin-top: var(--spacing-sm);
  }


  .endpoint-actions {
    margin-top: var(--spacing-sm);
  }


  nav.visible {
    border-top: 1px solid var(--border-color);
    padding-top: var(--spacing-sm);
  }


  .storage-actions {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm);
  }


  .wiki-editor {
    padding: var(--spacing-md);
  }

  .editor-toolbar {
    gap: 2px;
    justify-content: center;
  }


  .notifications-container {
    top: 10px;
    right: 10px;
    left: 10px;
    max-width: none;
  }
}


@media (min-width: 768px) and (max-width: 1023px) {

  .dashboard-grid {
    grid-template-columns: repeat(2, 1fr);
  }


  .yasgui-container {
    min-height: 400px;
  }


  .view {
    padding: var(--spacing-lg);
  }


  header {
    display: flex;
    flex-direction: column;
  }

  nav {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
  }
}


.form-field input::placeholder,
.form-field textarea::placeholder {
  opacity: 0.6;
}


button:active,
.button-primary:active,
input[type="submit"]:active {
  transform: translateY(1px);
}


@media (max-height: 450px) and (max-width: 767px) {
  header {
    position: static;
  }

  main {
    padding-top: var(--spacing-sm);
  }
}


@media print {
  header,
  nav,
  .hamburger-menu,
  .notifications-container,
  button {
    display: none !important;
  }

  main {
    padding: 0;
    margin: 0;
  }

  .view {
    box-shadow: none;
    padding: 0;
  }
}

================
File: src/css/plugin-styles.css
================
.plugins-section {
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

.plugin-container {
  width: 100%;
  margin-bottom: var(--spacing-md);
}


.plugin-loading {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 200px;
  background: rgba(0, 0, 0, 0.03);
  border-radius: var(--border-radius);
  border: 1px dashed var(--border-color);
}

.plugin-loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(0, 0, 0, 0.1);
  border-left-color: var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}


.plugin-error {
  padding: var(--spacing-md);
  background-color: rgba(231, 76, 60, 0.1);
  border: 1px solid rgba(231, 76, 60, 0.3);
  border-radius: var(--border-radius);
  color: var(--error-color);
}


.wiki-plugin {
  width: 100%;
}

.wiki-editor {
  background: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow);
  margin-bottom: var(--spacing-lg);
}

.editor-toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
  margin-bottom: 10px;
  background: rgba(0, 0, 0, 0.05);
  border-radius: 4px;
  padding: 5px;
}

.toolbar-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  padding: 0;
  border: none;
  background: transparent;
  border-radius: 4px;
  cursor: pointer;
}

.toolbar-button:hover {
  background: #e0e0e0;
}

.toolbar-button i {
  font-size: 20px;
  color: #555;
}

.wiki-preview {
  margin-top: 20px;
  padding: 20px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
}

.preview-content {
  font-family: system-ui, -apple-system, sans-serif;
  line-height: 1.6;
}

.preview-content h1,
.preview-content h2,
.preview-content h3 {
  margin-top: 1.5em;
  margin-bottom: 0.5em;
}

.preview-content p {
  margin-bottom: 1em;
}

.preview-content ul,
.preview-content ol {
  padding-left: 2em;
  margin-bottom: 1em;
}

.preview-content blockquote {
  border-left: 3px solid #ddd;
  margin-left: 0;
  padding-left: 1em;
  color: #777;
}

.preview-content code {
  font-family: monospace;
  background: #f0f0f0;
  padding: 2px 4px;
  border-radius: 3px;
}

.preview-content pre {
  background: #f0f0f0;
  padding: 1em;
  border-radius: 4px;
  overflow-x: auto;
}

.preview-content img {
  max-width: 100%;
}

.entries-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.entry-item {
  padding: 15px;
  margin-bottom: 15px;
  border: 1px solid #eee;
  border-radius: 4px;
  background: white;
}

.entry-title {
  margin: 0 0 10px 0;
  color: var(--primary-color);
}

.entry-preview {
  margin: 0 0 10px 0;
  color: #666;
}

.entry-meta {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 10px;
  font-size: 0.875rem;
  color: #999;
}

.entry-actions {
  display: flex;
  gap: 10px;
  margin-top: 10px;
}

.entry-actions button {
  padding: 5px 10px;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.entry-actions button:hover {
  background: var(--secondary-color);
}

.entry-actions button.delete-entry {
  background: var(--error-color);
}

.entry-detail {
  padding: 20px;
  background: white;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.entry-toolbar {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

.entry-content {
  line-height: 1.6;
}


.yasgui-wrapper {
  min-height: 500px;
  width: 100%;
  border: 1px solid #ddd;
  border-radius: 4px;
  overflow: hidden;
}


@media (max-width: 768px) {
  .editor-toolbar {
    justify-content: center;
  }

  .entry-actions {
    flex-direction: column;
  }

  .yasgui-wrapper {
    min-height: 400px;
  }
}

@media (min-width: 1024px) {
  .yasgui-wrapper {
    min-height: 600px;
  }
}

================
File: src/css/styles.css
================
:root {
  --primary-color: #3498db;
  --secondary-color: #2980b9;
  --error-color: #e74c3c;
  --success-color: #2ecc71;
  --background-color: #f9f9f9;
  --card-background: #ffffff;
  --text-color: #2c3e50;
  --border-color: #e1e1e1;
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;
  --spacing-xl: 2rem;
  --border-radius: 8px;
  --shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}


[data-theme="dark"] {
  --primary-color: #3498db;
  --secondary-color: #2980b9;
  --error-color: #e74c3c;
  --success-color: #2ecc71;
  --background-color: #1a1a1a;
  --card-background: #2c2c2c;
  --text-color: #f9f9f9;
  --border-color: #444444;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  line-height: 1.6;
  background: var(--background-color);
  color: var(--text-color);
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

header {
  background: var(--card-background);
  padding: var(--spacing-md);
  box-shadow: var(--shadow);
  position: sticky;
  top: 0;
  z-index: 100;
}

header h1 {
  font-size: 1.5rem;
  margin-bottom: var(--spacing-sm);
}

nav {
  display: none;
  flex-direction: column;
  gap: var(--spacing-xs);
  margin-top: var(--spacing-sm);
}

nav.visible {
  display: flex;
}

nav a {
  color: var(--text-color);
  text-decoration: none;
  padding: var(--spacing-sm) var(--spacing-md);
  border-radius: var(--border-radius);
  transition: background-color 0.2s, color 0.2s;
}

nav a:hover, nav a.active {
  background: var(--primary-color);
  color: white;
}

main {
  flex: 1;
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: var(--spacing-md);
}

.view {
  background: var(--card-background);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow);
  padding: var(--spacing-lg);
  margin-bottom: var(--spacing-lg);
}

.hidden {
  display: none;
}


.settings-section {
  background: var(--card-background);
  padding: var(--spacing-lg);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow);
  margin-bottom: var(--spacing-lg);
}

.settings-section h3 {
  margin-top: 0;
  margin-bottom: var(--spacing-md);
  color: var(--text-color);
  border-bottom: 1px solid var(--border-color);
  padding-bottom: var(--spacing-sm);
}

.endpoint-item {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
  padding: var(--spacing-md);
  border-bottom: 1px solid var(--border-color);
}

.endpoint-header {
  display: flex;
  align-items: center;
  gap: var(--spacing-sm);
}

.endpoint-url {
  font-size: 0.875rem;
  color: var(--text-color);
  opacity: 0.7;
  margin-top: var(--spacing-xs);
  word-break: break-all;
}

.endpoint-status {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #999;
  transition: background-color 0.3s ease;
  flex-shrink: 0;
}

.endpoint-status.checking {
  animation: pulse 1.5s infinite;
  background: var(--primary-color);
}

.endpoint-status.active {
  background: var(--success-color);
}

.endpoint-status.inactive {
  background: var(--error-color);
}

.endpoint-label[contenteditable] {
  padding: var(--spacing-xs);
  border-radius: 4px;
}

.endpoint-label[contenteditable]:focus {
  outline: 2px solid var(--primary-color);
  background: var(--card-background);
}

.endpoint-actions {
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-sm);
}

.endpoint-actions button {
  padding: var(--spacing-xs) var(--spacing-sm);
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

#endpoint-form {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--spacing-sm);
  margin-top: var(--spacing-md);
}

@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.4; }
  100% { opacity: 1; }
}


.yasgui-container {
  width: 100%;
  height: 500px;
  margin-top: var(--spacing-md);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  overflow: hidden;
}


.hamburger-menu {
  display: block;
  position: absolute;
  top: var(--spacing-md);
  right: var(--spacing-md);
}

.hamburger-button {
  background: transparent;
  border: none;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  height: 24px;
  width: 30px;
  padding: 0;
}

.hamburger-button span {
  background-color: var(--text-color);
  border-radius: 3px;
  display: block;
  height: 3px;
  transition: all 0.3s ease;
  width: 100%;
}

.hamburger-menu.active .hamburger-button span:nth-child(1) {
  transform: translateY(10px) rotate(45deg);
}

.hamburger-menu.active .hamburger-button span:nth-child(2) {
  opacity: 0;
}

.hamburger-menu.active .hamburger-button span:nth-child(3) {
  transform: translateY(-10px) rotate(-45deg);
}


.header-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
}


.dashboard-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: var(--spacing-lg);
}


.storage-section {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

.storage-section button {
  padding: var(--spacing-sm) var(--spacing-md);
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: var(--border-radius);
  cursor: pointer;
  transition: background-color 0.2s;
}

.storage-section button:hover {
  background: var(--secondary-color);
}

.storage-section button.danger {
  background: var(--error-color);
}

#storage-usage {
  padding: var(--spacing-md);
  background: rgba(0, 0, 0, 0.05);
  border-radius: var(--border-radius);
}


@media (min-width: 768px) {
  header h1 {
    font-size: 1.75rem;
  }

  .hamburger-menu {
    display: none;
  }

  nav {
    display: flex;
    flex-direction: row;
    margin-top: 0;
  }

  .endpoint-item {
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
  }

  #endpoint-form {
    grid-template-columns: 1fr 2fr auto;
  }

  .dashboard-grid {
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  }

  .yasgui-container {
    height: 600px;
  }
}

@media (min-width: 1024px) {
  header {
    padding: var(--spacing-md) var(--spacing-xl);
  }

  main {
    padding: var(--spacing-xl);
  }

  header h1 {
    font-size: 2rem;
  }

  .view {
    padding: var(--spacing-xl);
  }

  .yasgui-container {
    height: 700px;
  }
}


.endpoint-status-indicator {
  display: flex;
  align-items: center;
  gap: 5px;
  position: absolute;
  top: var(--spacing-md);
  left: var(--spacing-md);
  cursor: pointer;
  z-index: 100;
}

.status-light {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background-color: #999;
  transition: background-color 0.3s ease;
}

.status-light.active {
  background-color: var(--success-color);
}

.status-light.inactive {
  background-color: var(--error-color);
}

.status-light.checking {
  background-color: #999;
  animation: pulse 1.5s infinite;
}

.status-tooltip-icon {
  font-size: 12px;
  color: var(--text-color);
  opacity: 0.7;
}

@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.4; }
  100% { opacity: 1; }
}

@media (max-width: 768px) {
  .endpoint-status-indicator {
    top: var(--spacing-md);
    left: var(--spacing-md);
  }
}

================
File: src/css/yasgui-styles.css
================
.yasgui-container {
  width: 100%;
  height: 600px;
  margin-top: 1rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
  position: relative;
  overflow: hidden;
}


.yasgui-container-loading {
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: rgba(255, 255, 255, 0.8);
}

.yasgui-container-loading::after {
  content: "Loading SPARQL editor...";
  font-size: 1rem;
  color: var(--text-color);
}


.yasgui-init {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  background: #f9f9f9;
}

.yasgui-init button {
  padding: 12px 24px;
  font-size: 16px;
  background-color: var(--primary-color, #3498db);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  transition: background-color 0.2s;
}

.yasgui-init button:hover {
  background-color: #2980b9;
}

.yasgui-init button:disabled {
  background-color: #999;
  cursor: not-allowed;
}


.error-message {
  padding: 15px;
  color: #721c24;
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 4px;
  margin: 10px 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

.error-message button {
  padding: 8px 16px;
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}


.yasgui {
  width: 100% !important;
  height: 600px !important;
}


.yasgui .yasqe {
  height: 40% !important;
}

.yasgui .yasqe .CodeMirror {
  height: 100% !important;
  font-family: monospace !important;
}


.yasgui .yasr {
  height: 60% !important;
}


.yasgui .tabPanel {
  height: 100% !important;
}


.yasgui button.btn-primary {
  background-color: var(--primary-color, #3498db) !important;
  border-color: var(--primary-color, #3498db) !important;
}

.yasgui button.btn-primary:hover {
  background-color: #2980b9 !important;
  border-color: #2980b9 !important;
}


.yasgui .yasr_results table {
  margin: 1em 0;
  border-collapse: collapse;
  width: 100%;
}

.yasgui .yasr_results table th,
.yasgui .yasr_results table td {
  border: 1px solid #ddd;
  padding: 8px;
}

.yasgui .yasr_results table tr:nth-child(even) {
  background-color: #f2f2f2;
}

.yasgui .yasr_results table th {
  padding-top: 12px;
  padding-bottom: 12px;
  text-align: left;
  background-color: var(--primary-color, #3498db);
  color: white;
}


@media (max-width: 768px) {
  .yasgui-container {
    height: 500px;
  }

  .yasgui .yasqe .CodeMirror {
    font-size: 13px !important;
  }
}

@media (min-width: 1024px) {
  .yasgui-container {
    height: 700px;
  }
}

================
File: src/domain/rdf/model.js
================
import rdf from 'rdf-ext';
import { RDFError } from '../../core/errors/error-types.js';
import { namespaces } from '../../utils/namespaces.js';





export class RDFModel {
  constructor() {
    this.ns = {};


    Object.entries(namespaces).forEach(([prefix, uri]) => {
      this.ns[prefix] = rdf.namespace(uri);
    });
  }












  createPostData(postData) {
    try {
      const dataset = rdf.dataset();


      const postId = postData.customId || this.generatePostId(postData);
      const subject = rdf.namedNode(postId);


      const graph = postData.graph ?
        rdf.namedNode(postData.graph) :
        null;


      const addQuad = (s, p, o) => {
        if (graph) {
          dataset.add(rdf.quad(s, p, o, graph));
        } else {
          dataset.add(rdf.quad(s, p, o));
        }
      };


      addQuad(
        subject,
        this.ns.rdf('type'),
        this.ns.squirt(postData.type)
      );


      addQuad(
        subject,
        this.ns.squirt('content'),
        rdf.literal(postData.content)
      );


      addQuad(
        subject,
        this.ns.dc('created'),
        rdf.literal(new Date().toISOString(), rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
      );


      if (postData.title) {
        addQuad(
          subject,
          this.ns.dc('title'),
          rdf.literal(postData.title)
        );
      }


      if (postData.tags && Array.isArray(postData.tags)) {
        postData.tags.forEach(tag => {
          addQuad(
            subject,
            this.ns.squirt('tag'),
            rdf.literal(tag)
          );
        });
      }


      if (postData.type === 'link' && postData.url) {
        addQuad(
          subject,
          this.ns.squirt('url'),
          rdf.namedNode(postData.url)
        );
      }


      if (postData.type === 'wiki') {

        addQuad(
          subject,
          this.ns.dc('modified'),
          rdf.literal(new Date().toISOString(), rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
        );
      }

      return {
        id: postId,
        dataset,
        ...postData
      };
    } catch (error) {
      throw new RDFError(`Failed to create post data: ${error.message}`, {
        originalError: error,
        postData
      });
    }
  }











  extractPosts(dataset, options = {}) {
    try {
      if (!dataset) return [];

      let posts = new Map();


      const postTypePattern = this.ns.rdf('type');


      const matchOptions = {};
      if (options.graph) {
        matchOptions.graph = rdf.namedNode(options.graph);
      }


      dataset.match(null, postTypePattern, null, options.graph ? rdf.namedNode(options.graph) : null).forEach(quad => {
        const postType = quad.object.value.split('/').pop();


        if (options.type && postType !== options.type) return;

        const postId = quad.subject.value;
        const graphId = quad.graph?.value || null;

        if (!posts.has(postId)) {
          posts.set(postId, {
            id: postId,
            type: postType,
            graph: graphId,
            tags: []
          });
        }
      });


      posts.forEach((post, id) => {
        const subject = rdf.namedNode(id);
        const graph = post.graph ? rdf.namedNode(post.graph) : null;


        dataset.match(subject, this.ns.squirt('content'), null, graph).forEach(quad => {
          post.content = quad.object.value;
        });


        dataset.match(subject, this.ns.dc('title'), null, graph).forEach(quad => {
          post.title = quad.object.value;
        });


        dataset.match(subject, this.ns.dc('created'), null, graph).forEach(quad => {
          post.created = quad.object.value;
        });


        dataset.match(subject, this.ns.dc('modified'), null, graph).forEach(quad => {
          post.modified = quad.object.value;
        });


        dataset.match(subject, this.ns.squirt('tag'), null, graph).forEach(quad => {
          post.tags.push(quad.object.value);
        });


        dataset.match(subject, this.ns.squirt('url'), null, graph).forEach(quad => {
          post.url = quad.object.value;
        });
      });


      if (options.tag) {
        posts = new Map(
          Array.from(posts.entries()).filter(([_, post]) =>
            post.tags.includes(options.tag)
          )
        );
      }



      let postsArray = Array.from(posts.values())
        .sort((a, b) => {
          const dateA = a.modified ? new Date(a.modified) : new Date(a.created);
          const dateB = b.modified ? new Date(b.modified) : new Date(b.created);
          return dateB - dateA;
        });


      if (options.limit && options.limit > 0) {
        postsArray = postsArray.slice(0, options.limit);
      }

      return postsArray;
    } catch (error) {
      throw new RDFError(`Failed to extract posts: ${error.message}`, {
        originalError: error,
        options
      });
    }
  }






  generatePostId(postData) {
    const content = postData.title || postData.content || postData.url || '';
    const date = new Date().toISOString().split('T')[0];
    const hash = this.hashContent(content);

    return `http://purl.org/stuff/squirt/post_${date}_${hash}`;
  }






  hashContent(content) {
    return Array.from(content)
      .reduce((hash, char) => {
        return ((hash << 5) - hash) + char.charCodeAt(0) | 0;
      }, 0)
      .toString(16)
      .slice(0, 8);
  }
}


import { eventBus, EVENTS } from '../../core/events/event-bus.js';
import { errorHandler, RDFError } from '../../core/errors/index.js';
import { RDFModel } from './model.js';
import { store } from '../../core/state/index.js';
import { addPost, updatePost, removePost, setPosts } from '../../core/state/actions.js';
import { N3Parser } from '@rdfjs/parser-n3';





export class RDFService {
  constructor(storageService, sparqlService) {
    this.model = new RDFModel();
    this.storageService = storageService;
    this.sparqlService = sparqlService;
    this.parser = new N3Parser();


    this.loadCachedData();
  }




  async loadCachedData() {
    try {
      const cachedData = this.storageService.getItem('squirt_rdf_cache');
      if (cachedData) {
        const dataset = await this.parseFromString(cachedData);
        this.dataset = dataset;


        const posts = this.model.extractPosts(dataset);
        store.dispatch(setPosts(posts));
      } else {
        this.dataset = rdf.dataset();
      }
    } catch (error) {
      errorHandler.handle(error);
      this.dataset = rdf.dataset();
    }
  }




  saveToCache() {
    try {
      this.storageService.setItem('squirt_rdf_cache', this.dataset.toString());
    } catch (error) {
      errorHandler.handle(error);
    }
  }






  async parseFromString(turtleString) {
    try {
      const quads = [];
      const parser = this.parser;

      return new Promise((resolve, reject) => {
        const stream = parser.import(rdf.stringToStream(turtleString));

        stream.on('data', quad => {
          quads.push(quad);
        });

        stream.on('error', error => {
          reject(error);
        });

        stream.on('end', () => {
          resolve(rdf.dataset(quads));
        });
      });
    } catch (error) {
      throw new RDFError('Error parsing RDF data', { originalError: error });
    }
  }






  createPost(postData) {
    try {

      const post = this.model.createPostData(postData);


      post.dataset.forEach(quad => {
        this.dataset.add(quad);
      });


      this.saveToCache();


      store.dispatch(addPost({
        id: post.id,
        type: postData.type,
        title: postData.title,
        content: postData.content,
        url: postData.url,
        tags: postData.tags || [],
        created: new Date().toISOString()
      }));


      eventBus.emit(EVENTS.POST_CREATED, post);


      this.syncWithEndpoint().catch(error => {
        errorHandler.handle(error, {
          showToUser: true,
          context: 'Syncing with endpoint after post creation'
        });
      });

      return post.id;
    } catch (error) {
      throw errorHandler.handle(
        new RDFError('Failed to create post', {
          originalError: error,
          postData
        }),
        { rethrow: true }
      );
    }
  }







  updatePost(postId, postData) {
    try {

      this.deletePost(postId, { skipStateUpdate: true, skipSync: true });


      const updatedData = {
        ...postData,
        customId: postId
      };


      const post = this.model.createPostData(updatedData);


      post.dataset.forEach(quad => {
        this.dataset.add(quad);
      });


      this.saveToCache();


      store.dispatch(updatePost({
        id: postId,
        updates: {
          ...updatedData,
          modified: new Date().toISOString()
        }
      }));


      eventBus.emit(EVENTS.POST_UPDATED, post);


      this.syncWithEndpoint().catch(error => {
        errorHandler.handle(error, {
          showToUser: true,
          context: 'Syncing with endpoint after post update'
        });
      });

      return postId;
    } catch (error) {
      throw errorHandler.handle(
        new RDFError('Failed to update post', {
          originalError: error,
          postId,
          postData
        }),
        { rethrow: true }
      );
    }
  }









  deletePost(postId, options = {}) {
    try {
      const { skipStateUpdate = false, skipSync = false } = options;
      const subject = rdf.namedNode(postId);


      const quadsToRemove = this.dataset.match(subject);

      if (quadsToRemove.size === 0) {
        return false;
      }


      quadsToRemove.forEach(quad => {
        this.dataset.delete(quad);
      });


      this.saveToCache();


      if (!skipStateUpdate) {
        store.dispatch(removePost(postId));


        eventBus.emit(EVENTS.POST_DELETED, { id: postId });
      }


      if (!skipSync) {
        this.syncWithEndpoint().catch(error => {
          errorHandler.handle(error, {
            showToUser: true,
            context: 'Syncing with endpoint after post deletion'
          });
        });
      }

      return true;
    } catch (error) {
      throw errorHandler.handle(
        new RDFError('Failed to delete post', {
          originalError: error,
          postId
        }),
        { rethrow: true }
      );
    }
  }






  getPosts(options = {}) {
    try {
      return this.model.extractPosts(this.dataset, options);
    } catch (error) {
      throw errorHandler.handle(
        new RDFError('Failed to get posts', {
          originalError: error,
          options
        }),
        { rethrow: true }
      );
    }
  }






  getPost(postId) {
    try {
      const options = { limit: 1 };
      const subject = rdf.namedNode(postId);


      const filteredDataset = this.dataset.match(subject);

      if (filteredDataset.size === 0) {
        return null;
      }

      const posts = this.model.extractPosts(filteredDataset, options);

      return posts.length > 0 ? posts[0] : null;
    } catch (error) {
      throw errorHandler.handle(
        new RDFError('Failed to get post', {
          originalError: error,
          postId
        }),
        { rethrow: true }
      );
    }
  }




  async syncWithEndpoint() {
    try {
      if (!this.sparqlService || !this.dataset || this.dataset.size === 0) {
        return false;
      }

      const result = await this.sparqlService.postToSparql(this.dataset);

      if (result) {
        eventBus.emit(EVENTS.MODEL_SYNCED, { timestamp: new Date() });
      }

      return result;
    } catch (error) {
      throw new RDFError('Failed to sync with SPARQL endpoint', {
        originalError: error
      });
    }
  }




  async loadFromEndpoint() {
    try {
      if (!this.sparqlService) {
        return false;
      }

      const query = `
        PREFIX rdf: <${namespaces.rdf}>
        PREFIX squirt: <${namespaces.squirt}>
        PREFIX dc: <${namespaces.dc}>

        CONSTRUCT {
          ?s ?p ?o .
        }
        WHERE {
          ?s rdf:type ?type .
          FILTER(STRSTARTS(STR(?type), "${namespaces.squirt}"))
          ?s ?p ?o .
        }
      `;

      const response = await this.sparqlService.querySparql(query);

      if (response && response.results) {
        const dataset = await this.parseFromString(response.results);
        this.dataset = dataset;


        this.saveToCache();


        const posts = this.model.extractPosts(dataset);
        store.dispatch(setPosts(posts));

        return true;
      }

      return false;
    } catch (error) {
      throw new RDFError('Failed to load from SPARQL endpoint', {
        originalError: error
      });
    }
  }
}


export function createRDFService(storageService, sparqlService) {
  return new RDFService(storageService, sparqlService);
}

================
File: src/html/index.html
================
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Post information to the web easily with Squirt">
    <meta name="theme-color" content="#3498db">
    <title>Squirt</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">


    <link rel="manifest" href="/manifest.json">


    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Squirt">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon.png">
</head>

<body>
    <header>
        <div class="header-container">
            <h1>Squirt</h1>
            <div class="hamburger-menu">
                <button class="hamburger-button" aria-label="Menu">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
        </div>
<div id="endpoint-status-indicator" class="endpoint-status-indicator" title="Checking endpoint status...">
    <div class="status-light checking"></div>
    <span class="status-tooltip-icon">?</span>
</div>
        <nav>
            <a href="#" data-view="post-view">Post</a>
            <a href="#" data-view="wiki-view">Wiki</a>
            <a href="#" data-view="yasgui-view">SPARQL</a>
            <a href="#" data-view="developer-view">Developer</a>
            <a href="#" data-view="profile-view">Profile</a>
            <a href="#" data-view="settings-view">Settings</a>
        </nav>

    </header>

    <main>

        <div id="post-view" class="view">
            <h2>Create Post</h2>
            <form id="post-form" class="form-group">
                <div class="form-field">
                    <label for="post-type">Post Type</label>
                    <select id="post-type" name="post-type" required>
                        <option value="entry">Entry</option>
                        <option value="link" selected>Link</option>
                    </select>
                </div>


                <div class="form-fields">
                    <div class="form-field">
                        <label for="url">URL</label>
                        <div class="input-with-button">
                            <input type="url" id="url" name="url" placeholder="https://example.com" required>
                            <button type="button" id="extract-metadata" class="extract-button">Extract</button>
                        </div>
                    </div>

                    <div class="form-field">
                        <label for="title">Title</label>
                        <input type="text" id="title" name="title" placeholder="Enter a title">
                    </div>

                    <div class="form-field">
                        <label for="content">Content</label>
                        <textarea id="content" name="content" rows="5" placeholder="Enter your content here..."></textarea>
                    </div>

                    <div class="form-field">
                        <label for="tags">Tags (comma separated)</label>
                        <input type="text" id="tags" name="tags" placeholder="tag1, tag2, tag3">
                    </div>
                </div>

                <button type="submit" class="button-primary">Post</button>
            </form>

            <div id="post-preview"></div>
        </div>


        <div id="wiki-view" class="view hidden">
            <h2>Wiki</h2>
            <div class="wiki-editor">
                <div class="form-field">
                    <label for="wiki-title">Title</label>
                    <input type="text" id="wiki-title" name="title" required>
                </div>
                <div class="form-field">
                    <label for="wiki-content">Content (Markdown supported)</label>
                    <textarea id="wiki-content" name="content" rows="10" required></textarea>
                </div>
                <div class="form-field">
                    <label for="wiki-tags">Tags (comma separated)</label>
                    <input type="text" id="wiki-tags" name="tags" placeholder="tag1, tag2, tag3">
                </div>
                <button type="button" id="save-wiki" class="button-primary">Save</button>
            </div>
            <div class="wiki-entries"></div>
        </div>

        <div id="yasgui-view" class="view hidden">
            <h2>SPARQL Query Editor</h2>
            <div id="yasgui-container" class="yasgui-container"></div>
        </div>


        <div id="developer-view" class="view hidden">
            <h2>Developer Tools</h2>
            <div class="developer-section">
                <h3>SPARQL Query</h3>
                <div class="form-field">
                    <textarea id="sparql-query" rows="10" placeholder="Enter SPARQL query..."></textarea>
                </div>
                <button type="button" id="run-query" class="button-primary">Run Query</button>
                <div id="query-results" class="results-container"></div>
            </div>
        </div>


        <div id="profile-view" class="view hidden">
            <h2>Profile</h2>
            <form id="profile-form" class="form-group">
                <div class="form-field">
                    <label for="profile-name">Name</label>
                    <input type="text" id="profile-name" name="name">
                </div>
                <div class="form-field">
                    <label for="profile-email">Email</label>
                    <input type="email" id="profile-email" name="email">
                </div>
                <div class="form-field">
                    <label for="profile-bio">Bio</label>
                    <textarea id="profile-bio" name="bio" rows="5"></textarea>
                </div>
                <button type="submit" class="button-primary">Save Profile</button>
            </form>
        </div>


        <div id="settings-view" class="view hidden">
            <h2>Settings</h2>

            <div class="dashboard-grid">

                <div class="settings-section">
                    <h3>Appearance</h3>
                    <div class="form-field">
                        <label for="theme-selector">Theme</label>
                        <select id="theme-selector">
                            <option value="light">Light</option>
                            <option value="dark">Dark</option>
                            <option value="system">System Preference</option>
                        </select>
                    </div>
                </div>


                <div class="settings-section">
                    <h3>SPARQL Endpoints</h3>
                    <div id="endpoints-list"></div>
                    <form id="endpoint-form" class="form-group">
                        <input type="text" id="endpoint-label" placeholder="Endpoint Label" required>
                        <input type="url" id="endpoint-url" placeholder="Enter SPARQL endpoint URL" required>
                        <button type="submit" class="button-primary">Add</button>
                    </form>
                </div>


                <div class="settings-section storage-section">
                    <h3>Storage</h3>
                    <div id="storage-usage">Calculating storage usage...</div>
                    <div class="storage-actions">
                        <button id="export-data" class="button-primary">Export Data</button>
                        <button id="import-data" class="button-primary">Import Data</button>
                        <button id="clear-data" class="button-primary danger">Clear All Data</button>
                    </div>
                </div>
            </div>
        </div>
    </main>


    <div class="notifications-container"></div>
</body>

</html>

================
File: src/plugins/index.js
================
import { YasguiPlugin } from './yasgui-plugin.js';
import { WikiPlugin } from './wiki-plugin.js';

export {
  YasguiPlugin,
  WikiPlugin
};

================
File: src/plugins/wiki-plugin.js
================
import { PluginBase } from '../core/plugin-base.js';
import { rdfModel } from '../js/services/rdf/rdf-model.js';
import { ErrorHandler } from '../core/errors.js';
import { showNotification } from '../ui/components/notifications.js';




export class WikiPlugin extends PluginBase {
  constructor(id = 'wiki-plugin', options = {}) {
    super(id, {
      autoInitialize: true,
      toolbarEnabled: true,
      ...options
    });

    this.editor = null;
    this.preview = null;
    this.toolbar = null;
    this.entriesContainer = null;
    this.currentEntryId = null;
  }




  async initialize() {
    if (this.isInitialized) return;

    try {

      await this.loadDependencies();


      await super.initialize();
      console.log('Wiki plugin initialized');
    } catch (error) {
      ErrorHandler.handle(error);
      throw new Error(`Failed to initialize Wiki plugin: ${error.message}`);
    }
  }




  async loadDependencies() {
    try {

      if (window.CodeMirror) {
        this.CodeMirror = window.CodeMirror;
      } else {

        const cm = await import('codemirror');
        this.CodeMirror = cm.default;


        await import('codemirror/mode/markdown/markdown');
        await import('codemirror/addon/edit/continuelist');
        await import('codemirror/addon/display/placeholder');
      }


      if (window.marked) {
        this.marked = window.marked;
      } else {

        const markedModule = await import('marked');
        this.marked = markedModule.marked;
      }


      if (!document.querySelector('link[href*="codemirror.css"]')) {
        const cmCss = document.createElement('link');
        cmCss.rel = 'stylesheet';
        cmCss.href = 'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/codemirror.min.css';
        document.head.appendChild(cmCss);
      }


      if (!document.querySelector('link[href*="monokai.css"]')) {
        const themeCss = document.createElement('link');
        themeCss.rel = 'stylesheet';
        themeCss.href = 'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/theme/monokai.min.css';
        document.head.appendChild(themeCss);
      }


      if (this.options.toolbarEnabled && !document.querySelector('link[href*="material-icons"]')) {
        const iconsCss = document.createElement('link');
        iconsCss.rel = 'stylesheet';
        iconsCss.href = 'https://fonts.googleapis.com/icon?family=Material+Icons';
        document.head.appendChild(iconsCss);
      }

    } catch (error) {
      throw new Error(`Failed to load Wiki plugin dependencies: ${error.message}`);
    }
  }




  async mount(container) {
    await super.mount(container);

    try {

      this.createEditorStructure(container);


      this.initializeCodeMirror();


      if (this.options.toolbarEnabled) {
        this.addToolbar();
      }


      this.setupEventListeners();


      this.loadWikiEntries();

      console.log('Wiki plugin mounted successfully');
    } catch (error) {
      ErrorHandler.handle(error);
      container.innerHTML = `<div class="error-message">Failed to initialize Wiki editor: ${error.message}</div>`;
      throw error;
    }
  }




  createEditorStructure(container) {

    container.innerHTML = `
      <div class="wiki-plugin">
        <div class="wiki-editor">
          <div class="form-field">
            <label for="wiki-title">Title</label>
            <input type="text" id="wiki-title" name="title" required>
          </div>
          <div class="form-field">
            <label for="wiki-content">Content (Markdown supported)</label>
            <textarea id="wiki-content" name="content" rows="10" required></textarea>
          </div>
          <div class="form-field">
            <label for="wiki-tags">Tags (comma separated)</label>
            <input type="text" id="wiki-tags" name="tags" placeholder="tag1, tag2, tag3">
          </div>
          <button type="button" id="save-wiki" class="button-primary">Save</button>
          <button type="button" id="cancel-edit" class="button-secondary" style="display: none;">Cancel</button>
        </div>
        <div class="wiki-preview">
          <h3>Preview</h3>
          <div class="preview-content"></div>
        </div>
        <div class="wiki-entries">
          <h3>Recent Entries</h3>
          <!-- Entries will be loaded here -->
        </div>
      </div>
    `;


    this.editorContainer = container.querySelector('.wiki-editor');
    this.previewContainer = container.querySelector('.wiki-preview');
    this.preview = container.querySelector('.preview-content');
    this.entriesContainer = container.querySelector('.wiki-entries');
    this.titleInput = container.querySelector('#wiki-title');
    this.tagsInput = container.querySelector('#wiki-tags');
    this.saveButton = container.querySelector('#save-wiki');
    this.cancelButton = container.querySelector('#cancel-edit');
  }




  initializeCodeMirror() {
    const textarea = this.container.querySelector('#wiki-content');
    if (!textarea) {
      throw new Error('Wiki content textarea not found');
    }


    this.editor = this.CodeMirror.fromText


    import { PluginBase } from '../core/plugin-base.js';
    import { rdfModel } from '../services/rdf/rdf-model.js';
    import { ErrorHandler } from '../core/errors.js';
    import { showNotification } from '../ui/components/notifications.js';




    export class WikiPlugin extends PluginBase {
      constructor(id = 'wiki-plugin', options = {}) {
        super(id, {
          autoInitialize: true,
          toolbarEnabled: true,
          ...options
        });

        this.editor = null;
        this.preview = null;
        this.toolbar = null;
        this.entriesContainer = null;
        this.currentEntryId = null;
      }




      async initialize() {
        if (this.isInitialized) return;

        try {

          await this.loadDependencies();


          await super.initialize();
          console.log('Wiki plugin initialized');
        } catch (error) {
          ErrorHandler.handle(error);
          throw new Error(`Failed to initialize Wiki plugin: ${error.message}`);
        }
      }




      async loadDependencies() {
        try {

          if (window.CodeMirror) {
            this.CodeMirror = window.CodeMirror;
          } else {

            const cm = await import('codemirror');
            this.CodeMirror = cm.default;


            await import('codemirror/mode/markdown/markdown');
            await import('codemirror/addon/edit/continuelist');
            await import('codemirror/addon/display/placeholder');
          }


          if (window.marked) {
            this.marked = window.marked;
          } else {

            const markedModule = await import('marked');
            this.marked = markedModule.marked;
          }


          if (!document.querySelector('link[href*="codemirror.css"]')) {
            const cmCss = document.createElement('link');
            cmCss.rel = 'stylesheet';
            cmCss.href = 'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/codemirror.min.css';
            document.head.appendChild(cmCss);
          }


          if (!document.querySelector('link[href*="monokai.css"]')) {
            const themeCss = document.createElement('link');
            themeCss.rel = 'stylesheet';
            themeCss.href = 'https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.12/theme/monokai.min.css';
            document.head.appendChild(themeCss);
          }


          if (this.options.toolbarEnabled && !document.querySelector('link[href*="material-icons"]')) {
            const iconsCss = document.createElement('link');
            iconsCss.rel = 'stylesheet';
            iconsCss.href = 'https://fonts.googleapis.com/icon?family=Material+Icons';
            document.head.appendChild(iconsCss);
          }

        } catch (error) {
          throw new Error(`Failed to load Wiki plugin dependencies: ${error.message}`);
        }
      }




      async mount(container) {
        await super.mount(container);

        try {

          this.createEditorStructure(container);


          this.initializeCodeMirror();


          if (this.options.toolbarEnabled) {
            this.addToolbar();
          }


          this.setupEventListeners();


          this.loadWikiEntries();

          console.log('Wiki plugin mounted successfully');
        } catch (error) {
          ErrorHandler.handle(error);
          container.innerHTML = `<div class="error-message">Failed to initialize Wiki editor: ${error.message}</div>`;
          throw error;
        }
      }




      createEditorStructure(container) {

        container.innerHTML = `
          <div class="wiki-plugin">
            <div class="wiki-editor">
              <div class="form-field">
                <label for="wiki-title">Title</label>
                <input type="text" id="wiki-title" name="title" required>
              </div>
              <div class="form-field">
                <label for="wiki-content">Content (Markdown supported)</label>
                <textarea id="wiki-content" name="content" rows="10" required></textarea>
              </div>
              <div class="form-field">
                <label for="wiki-tags">Tags (comma separated)</label>
                <input type="text" id="wiki-tags" name="tags" placeholder="tag1, tag2, tag3">
              </div>
              <button type="button" id="save-wiki" class="button-primary">Save</button>
              <button type="button" id="cancel-edit" class="button-secondary" style="display: none;">Cancel</button>
            </div>
            <div class="wiki-preview">
              <h3>Preview</h3>
              <div class="preview-content"></div>
            </div>
            <div class="wiki-entries">
              <h3>Recent Entries</h3>
              <!-- Entries will be loaded here -->
            </div>
          </div>
        `;


        this.editorContainer = container.querySelector('.wiki-editor');
        this.previewContainer = container.querySelector('.wiki-preview');
        this.preview = container.querySelector('.preview-content');
        this.entriesContainer = container.querySelector('.wiki-entries');
        this.titleInput = container.querySelector('#wiki-title');
        this.tagsInput = container.querySelector('#wiki-tags');
        this.saveButton = container.querySelector('#save-wiki');
        this.cancelButton = container.querySelector('#cancel-edit');
      }




      initializeCodeMirror() {
        const textarea = this.container.querySelector('#wiki-content');
        if (!textarea) {
          throw new Error('Wiki content textarea not found');
        }


        this.editor = this.CodeMirror.fromTextArea(textarea, {
          mode: 'markdown',
          theme: 'monokai',
          lineNumbers: true,
          lineWrapping: true,
          viewportMargin: Infinity,
          placeholder: 'Enter markdown content here...',
          extraKeys: {
            'Enter': 'newlineAndIndentContinueMarkdownList'
          }
        });


        this.editor.on('change', () => this.updatePreview());


        this.updatePreview();
      }




      updatePreview() {
        if (!this.editor || !this.preview) return;

        const content = this.editor.getValue();


        this.preview.innerHTML = this.marked(content);


        this.preview.querySelectorAll('pre code').forEach(block => {
          if (window.hljs) {
            window.hljs.highlightBlock(block);
          }
        });
      }




      addToolbar() {

        this.toolbar = document.createElement('div');
        this.toolbar.className = 'editor-toolbar';


        const buttons = [
          { icon: 'format_bold', title: 'Bold', action: () => this.wrapText('**', '**') },
          { icon: 'format_italic', title: 'Italic', action: () => this.wrapText('*', '*') },
          { icon: 'format_quote', title: 'Quote', action: () => this.prependLine('> ') },
          { icon: 'format_list_bulleted', title: 'Bullet List', action: () => this.prependLine('- ') },
          { icon: 'format_list_numbered', title: 'Numbered List', action: () => this.prependLine('1. ') },
          { icon: 'insert_link', title: 'Link', action: () => this.insertLink() },
          { icon: 'insert_photo', title: 'Image', action: () => this.insertImage() },
          { icon: 'code', title: 'Code', action: () => this.wrapText('`', '`') },
          { icon: 'view_headline', title: 'Heading', action: () => this.prependLine('## ') }
        ];


        buttons.forEach(button => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'toolbar-button';
          btn.title = button.title;
          btn.innerHTML = `<i class="material-icons">${button.icon}</i>`;
          btn.addEventListener('click', button.action);
          this.toolbar.appendChild(btn);
        });


        if (this.editor) {
          const editorWrapper = this.editor.getWrapperElement();
          editorWrapper.parentNode.insertBefore(this.toolbar, editorWrapper);
        }
      }




      setupEventListeners() {

        if (this.saveButton) {
          this.saveButton.addEventListener('click', () => this.saveWikiEntry());
        }


        if (this.cancelButton) {
          this.cancelButton.addEventListener('click', () => this.cancelEdit());
        }
      }




      wrapText(prefix, suffix) {
        if (!this.editor) return;

        const selection = this.editor.getSelection();
        if (selection) {
          this.editor.replaceSelection(prefix + selection + suffix);
        } else {
          const cursor = this.editor.getCursor();
          this.editor.replaceRange(prefix + suffix, cursor);
          this.editor.setCursor({
            line: cursor.line,
            ch: cursor.ch + prefix.length
          });
        }
        this.editor.focus();
      }




      prependLine(text) {
        if (!this.editor) return;

        const selection = this.editor.getSelection();
        const cursor = this.editor.getCursor();

        if (selection) {
          const lines = selection.split('\n');
          const newText = lines.map(line => text + line).join('\n');
          this.editor.replaceSelection(newText);
        } else {
          const line = this.editor.getLine(cursor.line);
          this.editor.replaceRange(text + line, { line: cursor.line, ch: 0 }, { line: cursor.line, ch: line.length });
          this.editor.setCursor({ line: cursor.line, ch: text.length + cursor.ch });
        }
        this.editor.focus();
      }




      insertLink() {
        if (!this.editor) return;

        const selection = this.editor.getSelection();
        const url = prompt('Enter URL:', 'https://');

        if (url) {
          if (selection) {
            this.editor.replaceSelection(`[${selection}](${url})`);
          } else {
            const text = prompt('Enter link text:', 'Link text');
            if (text) {
              this.editor.replaceSelection(`[${text}](${url})`);
            }
          }
        }
        this.editor.focus();
      }




      insertImage() {
        if (!this.editor) return;

        const url = prompt('Enter image URL:', 'https://');

        if (url) {
          const alt = prompt('Enter image description:', 'Image');
          if (alt) {
            this.editor.replaceSelection(`![${alt}](${url})`);
          }
        }
        this.editor.focus();
      }




      saveWikiEntry() {
        if (!this.titleInput || !this.titleInput.value.trim()) {
          showNotification('Please enter a title for your wiki entry', 'error');
          return;
        }

        const content = this.editor ? this.editor.getValue() : '';
        if (!content.trim()) {
          showNotification('Please enter some content for your wiki entry', 'error');
          return;
        }

        const tags = this.tagsInput && this.tagsInput.value
          ? this.tagsInput.value.split(',').map(tag => tag.trim())
          : [];

        try {

          if (this.currentEntryId) {
            rdfModel.deletePost(this.currentEntryId);
          }


          const postData = {
            type: 'wiki',
            title: this.titleInput.value.trim(),
            content: content,
            tags: tags
          };


          if (this.currentEntryId) {
            postData.customId = this.currentEntryId;
          }

          const postId = rdfModel.createPost(postData);


          rdfModel.syncWithEndpoint()
            .catch(error => {
              console.warn('Wiki entry saved locally but failed to sync with endpoint', error);
            });


          this.resetForm();

          showNotification(this.currentEntryId ? 'Wiki entry updated successfully' : 'Wiki entry saved successfully', 'success');


          this.currentEntryId = null;


          if (this.saveButton) {
            this.saveButton.textContent = 'Save';
          }


          if (this.cancelButton) {
            this.cancelButton.style.display = 'none';
          }


          this.loadWikiEntries();
        } catch (error) {
          ErrorHandler.handle(error);
          showNotification('Failed to save wiki entry: ' + error.message, 'error');
        }
      }




      cancelEdit() {
        this.resetForm();
        this.currentEntryId = null;


        if (this.saveButton) {
          this.saveButton.textContent = 'Save';
        }


        if (this.cancelButton) {
          this.cancelButton.style.display = 'none';
        }
      }




      resetForm() {
        if (this.titleInput) {
          this.titleInput.value = '';
        }

        if (this.editor) {
          this.editor.setValue('');
        }

        if (this.tagsInput) {
          this.tagsInput.value = '';
        }
      }

      /**
       * Load and display wiki entries
       */
      loadWikiEntries() {
        if (!this.entriesContainer) return;

        // Clear existing entries
        this.entriesContainer.innerHTML = '<h3>Recent Entries</h3>';

        try {
          // Get wiki posts from RDF model
          const entries = rdfModel.getPosts({
            type: 'wiki',
            limit: 10
          });

          if (entries.length === 0) {
            this.entriesContainer.innerHTML += '<p>No wiki entries found.</p>';
            return;
          }


          const list = document.createElement('ul');
          list.className = 'entries-list';

          entries.forEach(entry => {
            const item = document.createElement('li');
            item.className = 'entry-item';

            item.innerHTML = `
              <h4 class="entry-title">${entry.title || 'Untitled'}</h4>
              <p class="entry-preview">${entry.content.substring(0, 100)}${entry.content.length > 100 ? '...' : ''}</p>
              <div class="entry-meta">
                <span class="entry-date">${new Date(entry.created).toLocaleString()}</span>
                ${entry.tags.length > 0 ? `<span class="entry-tags">${entry.tags.join(', ')}</span>` : ''}
              </div>
              <div class="entry-actions">
                <button class="view-entry" data-id="${entry.id}">View</button>
                <button class="edit-entry" data-id="${entry.id}">Edit</button>
                <button class="delete-entry" data-id="${entry.id}">Delete</button>
              </div>
            `;


            item.querySelector('.view-entry').addEventListener('click', () => this.viewEntry(entry.id));
            item.querySelector('.edit-entry').addEventListener('click', () => this.editEntry(entry.id));
            item.querySelector('.delete-entry').addEventListener('click', () => this.deleteEntry(entry.id));

            list.appendChild(item);
          });

          this.entriesContainer.appendChild(list);
        } catch (error) {
          ErrorHandler.handle(error);
          this.entriesContainer.innerHTML += `<p class="error">Error loading entries: ${error.message}</p>`;
        }
      }




      viewEntry(id) {
        try {

          const posts = rdfModel.getPosts();
          const post = posts.find(p => p.id === id);

          if (!post) {
            showNotification('Entry not found', 'error');
            return;
          }


          const entryView = document.createElement('div');
          entryView.className = 'entry-detail';

          entryView.innerHTML = `
            <div class="entry-toolbar">
              <button class="back-button">Back to list</button>
              <button class="edit-entry" data-id="${post.id}">Edit</button>
            </div>
            <h3 class="entry-title">${post.title || 'Untitled'}</h3>
            <div class="entry-meta">
              <span class="entry-date">${new Date(post.created).toLocaleString()}</span>
              ${post.tags.length > 0 ? `<span class="entry-tags">Tags: ${post.tags.join(', ')}</span>` : ''}
            </div>
            <div class="entry-content">${this.marked(post.content)}</div>
          `;


          if (this.entriesContainer) {
            this.entriesContainer.innerHTML = '';
            this.entriesContainer.appendChild(entryView);
          }

          // Add back button handler
          entryView.querySelector('.back-button').addEventListener('click', () => this.loadWikiEntries());


          entryView.querySelector('.edit-entry').addEventListener('click', () => this.editEntry(post.id));


          entryView.querySelectorAll('pre code').forEach(block => {
            if (window.hljs) {
              window.hljs.highlightBlock(block);
            }
          });
        } catch (error) {
          ErrorHandler.handle(error);
          showNotification('Error viewing entry: ' + error.message, 'error');
        }
      }




      editEntry(id) {
        try {

          const posts = rdfModel.getPosts();
          const post = posts.find(p => p.id === id);

          if (!post) {
            showNotification('Entry not found', 'error');
            return;
          }


          this.currentEntryId = id;


          if (this.titleInput) {
            this.titleInput.value = post.title || '';
          }

          if (this.tagsInput) {
            this.tagsInput.value = post.tags.join(', ');
          }

          if (this.editor) {
            this.editor.setValue(post.content || '');
          }

          // Update button text
          if (this.saveButton) {
            this.saveButton.textContent = 'Update';
          }


          if (this.cancelButton) {
            this.cancelButton.style.display = 'inline-block';
          }


          if (this.editorContainer) {
            this.editorContainer.scrollIntoView({
              behavior: 'smooth',
              block: 'start'
            });
          }

          showNotification('Editing entry: ' + post.title, 'info');
        } catch (error) {
          ErrorHandler.handle(error);
          showNotification('Error editing entry: ' + error.message, 'error');
        }
      }




      deleteEntry(id) {
        if (!confirm('Are you sure you want to delete this entry? This cannot be undone.')) {
          return;
        }

        try {

          const success = rdfModel.deletePost(id);

          if (success) {
            showNotification('Entry deleted successfully', 'success');


            this.loadWikiEntries();


            if (this.currentEntryId === id) {
              this.resetForm();
              this.currentEntryId = null;


              if (this.saveButton) {
                this.saveButton.textContent = 'Save';
              }


              if (this.cancelButton) {
                this.cancelButton.style.display = 'none';
              }
            }
          } else {
            showNotification('Failed to delete entry', 'error');
          }
        } catch (error) {
          ErrorHandler.handle(error);
          showNotification('Error deleting entry: ' + error.message, 'error');
        }
      }




      async unmount() {
        if (!this.isMounted) return;


        if (this.editor) {
          this.editor.toTextArea();
          this.editor = null;
        }


        if (this.previewContainer) {
          this.previewContainer.innerHTML = '';
        }

        if (this.entriesContainer) {
          this.entriesContainer.innerHTML = '';
        }

        // Remove toolbar if it exists
        if (this.toolbar && this.toolbar.parentNode) {
          this.toolbar.parentNode.removeChild(this.toolbar);
          this.toolbar = null;
        }

        await super.unmount();
        console.log('Wiki plugin unmounted');
      }




      async destroy() {
        await this.unmount();
        await super.destroy();
        console.log('Wiki plugin destroyed');
      }
    }

================
File: src/plugins/yasgui-plugin.js
================
import { PluginBase } from '../core/plugin-base.js';
import { state } from '../core/state.js';
import { ErrorHandler } from '../core/errors.js';
import { showNotification } from '../ui/components/notifications.js';




export class YasguiPlugin extends PluginBase {
  constructor(id = 'yasgui-plugin', options = {}) {
    super(id, {
      autoInitialize: true,
      defaultQuery: `PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX squirt: <http://purl.org/stuff/squirt/>

SELECT ?subject ?predicate ?object
WHERE {
  ?subject ?predicate ?object
}
LIMIT 10`,
      ...options
    });

    this.yasguiInstance = null;
    this.resizeObserver = null;
  }




  async initialize() {
    if (this.isInitialized) return;

    try {

      await this.loadYasguiDependencies();

      super.initialize();
      console.log('YASGUI plugin initialized');
    } catch (error) {
      ErrorHandler.handle(error);
      throw new Error(`Failed to initialize YASGUI plugin: ${error.message}`);
    }
  }




  async loadYasguiDependencies() {
    try {

      if (window.Yasgui) {
        this.Yasgui = window.Yasgui;
        return;
      }


      const module = await import('@triply/yasgui');
      this.Yasgui = module.default;


      if (!document.querySelector('link[href*="yasgui.min.css"]')) {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://cdn.jsdelivr.net/npm/@triply/yasgui/build/yasgui.min.css';
        document.head.appendChild(link);
      }
    } catch (error) {
      throw new Error(`Failed to load YASGUI dependencies: ${error.message}`);
    }
  }




  async mount(container) {
    await super.mount(container);

    try {

      container.innerHTML = '<div class="yasgui-wrapper"></div>';
      const wrapper = container.querySelector('.yasgui-wrapper');


      const endpoints = state.get('endpoints') || [];
      const activeEndpoint = endpoints.find(e => e.type === 'query' && e.status === 'active');


      const config = {
        requestConfig: {
          endpoint: activeEndpoint ? activeEndpoint.url : 'http://localhost:4030/semem/query',
          method: 'POST'
        }
      };


      if (activeEndpoint && activeEndpoint.credentials) {
        const authString = btoa(activeEndpoint.credentials.user + ':' + activeEndpoint.credentials.password);
        config.requestConfig.headers = {
          'Authorization': 'Basic ' + authString
        };
      }


      this.yasguiInstance = new this.Yasgui(wrapper, config);


      const tab = this.yasguiInstance.getTab();
      if (tab && tab.yasqe) {
        tab.yasqe.setValue(this.options.defaultQuery);
      }


      this.setupResizeObserver();


      this.addEventListener(document, 'endpointsStatusChecked', this.handleEndpointChange.bind(this));

      console.log('YASGUI plugin mounted successfully');
    } catch (error) {
      ErrorHandler.handle(error);
      container.innerHTML = `<div class="error-message">Failed to initialize SPARQL editor: ${error.message}</div>`;
      throw error;
    }
  }




  handleEndpointChange(event) {
    if (!this.yasguiInstance) return;

    try {
      const { queryActive } = event.detail;
      if (queryActive) {

        const endpoints = state.get('endpoints') || [];
        const activeEndpoint = endpoints.find(e => e.type === 'query' && e.status === 'active');

        if (activeEndpoint) {

          this.yasguiInstance.getTab().yasqe.options.requestConfig.endpoint = activeEndpoint.url;


          if (activeEndpoint.credentials) {
            const authString = btoa(activeEndpoint.credentials.user + ':' + activeEndpoint.credentials.password);
            this.yasguiInstance.getTab().yasqe.options.requestConfig.headers = {
              'Authorization': 'Basic ' + authString
            };
          } else {

            delete this.yasguiInstance.getTab().yasqe.options.requestConfig.headers;
          }

          showNotification('SPARQL endpoint updated', 'success');
        }
      }
    } catch (error) {
      ErrorHandler.handle(error);
    }
  }




  setupResizeObserver() {

    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }


    this.resizeObserver = new ResizeObserver(entries => {
      for (const entry of entries) {
        if (entry.target === this.container) {
          this.handleResize();
        }
      }
    });


    if (this.container) {
      this.resizeObserver.observe(this.container);
    }


    this.handleResize();
  }




  handleResize() {
    if (!this.yasguiInstance || !this.container) return;


    const { width, height } = this.container.getBoundingClientRect();


    const wrapper = this.container.querySelector('.yasgui-wrapper');
    if (wrapper) {
      wrapper.style.minHeight = '500px';
      wrapper.style.height = `${height}px`;
      wrapper.style.width = `${width}px`;
    }


    if (this.yasguiInstance.store) {
      this.yasguiInstance.store.dispatch({
        type: 'YASGUI_RESIZE'
      });
    }
  }




  async unmount() {
    if (!this.isMounted) return;


    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }


    if (this.yasguiInstance) {

      this.yasguiInstance = null;
    }


    if (this.container) {
      this.container.innerHTML = '';
    }

    await super.unmount();
    console.log('YASGUI plugin unmounted');
  }




  async destroy() {
    await this.unmount();
    await super.destroy();
    console.log('YASGUI plugin destroyed');
  }
}

================
File: src/services/endpoints/endpoints-service.js
================
import { ConfigError } from '../../core/errors/error-types.js';
import { eventBus, EVENTS } from '../../core/events/event-bus.js';
import { store } from '../../core/state/index.js';
import { setEndpoints, addEndpoint, removeEndpoint, updateEndpoint as updateEndpointAction } from '../../core/state/actions.js';
import { getEndpoints } from '../../core/state/selectors.js';




export class EndpointsService {






  constructor(storageService, config, testEndpointFn) {
    this.storageService = storageService;
    this.config = config;
    this.testEndpointFn = testEndpointFn;
    this.STORAGE_KEY = 'endpoints';
    this.statusCheckInterval = 60000;


    this.statusCheckIntervalId = null;
  }




  async initialize() {
    try {
      console.log('Initializing endpoints service...');


      const endpointsFromConfig = this.loadFromConfig();


      const storedEndpoints = this.loadFromStorage();


      let endpoints = endpointsFromConfig;

      if (storedEndpoints && storedEndpoints.length > 0) {

        const storedUrls = new Set(storedEndpoints.map(e => e.url));
        const newEndpoints = endpointsFromConfig.filter(e => !storedUrls.has(e.url));

        endpoints = [...storedEndpoints, ...newEndpoints];
      }

      if (!endpoints || endpoints.length === 0) {
        console.warn('No endpoints found in config or storage, using defaults');
        endpoints = this.getDefaultEndpoints();
      }

      console.log(`Loaded ${endpoints.length} endpoints`);


      store.dispatch(setEndpoints(endpoints));


      this.saveToStorage();


      this.startStatusChecks();

      return endpoints;
    } catch (error) {
      console.error('Error initializing endpoints:', error);
      const fallback = this.getDefaultEndpoints();
      store.dispatch(setEndpoints(fallback));
      this.startStatusChecks();
      throw new ConfigError('Failed to initialize endpoints', {
        originalError: error
      });
    }
  }





  loadFromStorage() {
    try {
      return this.storageService.getItem(this.STORAGE_KEY);
    } catch (error) {
      console.error('Error loading endpoints from storage:', error);
      return null;
    }
  }





  loadFromConfig() {
    try {

      if (this.config && Array.isArray(this.config.endpoints)) {
        console.log('Found endpoints in config:', this.config.endpoints);
        return this.config.endpoints.map(endpoint => ({
          url: endpoint.url,
          label: endpoint.name || endpoint.label,
          type: endpoint.type,
          credentials: endpoint.credentials,
          status: 'unknown'
        }));
      }

      throw new ConfigError('Invalid or missing endpoints in config');
    } catch (error) {
      console.error('Error loading endpoints from config:', error);
      return [];
    }
  }





  getDefaultEndpoints() {
    console.warn('Using default endpoints as fallback');
    return [
      {
        url: 'http://localhost:4030/semem/query',
        label: 'Local Query Endpoint',
        type: 'query',
        status: 'unknown',
        credentials: {
          user: 'admin',
          password: 'admin123'
        }
      },
      {
        url: 'http://localhost:4030/semem/update',
        label: 'Local Update Endpoint',
        type: 'update',
        status: 'unknown',
        credentials: {
          user: 'admin',
          password: 'admin123'
        }
      }
    ];
  }




  startStatusChecks() {

    if (this.statusCheckIntervalId) {
      clearInterval(this.statusCheckIntervalId);
    }


    this.checkEndpointsHealth();


    this.statusCheckIntervalId = setInterval(() => {
      this.checkEndpointsHealth();
    }, this.statusCheckInterval);


    eventBus.on(EVENTS.ENDPOINT_CHECK_REQUESTED, () => {
      this.checkEndpointsHealth();
    });
  }




  saveToStorage() {
    try {
      const endpoints = getEndpoints(store.getState());
      this.storageService.setItem(this.STORAGE_KEY, endpoints);
    } catch (error) {
      console.error('Error saving endpoints to storage:', error);
      throw error;
    }
  }








  addEndpoint(url, label, type = 'query', credentials = null) {
    const endpoints = getEndpoints(store.getState());


    if (endpoints.some(e => e.url === url)) {
      throw new ConfigError(`Endpoint with URL ${url} already exists`);
    }

    const newEndpoint = {
      url,
      label,
      type,
      credentials,
      status: 'unknown',
      lastChecked: null
    };


    store.dispatch(addEndpoint(newEndpoint));


    this.saveToStorage();


    eventBus.emit(EVENTS.ENDPOINT_ADDED, newEndpoint);


    this.checkEndpoint(url, credentials);

    return newEndpoint;
  }





  removeEndpoint(url) {

    store.dispatch(removeEndpoint(url));


    this.saveToStorage();


    eventBus.emit(EVENTS.ENDPOINT_REMOVED, { url });
  }






  updateEndpoint(url, updates) {

    store.dispatch(updateEndpointAction({
      url,
      updates
    }));


    this.saveToStorage();


    eventBus.emit(EVENTS.ENDPOINT_UPDATED, { url, updates });
  }







  async checkEndpoint(url, credentials = null) {
    const endpoints = getEndpoints(store.getState());
    const endpoint = endpoints.find(e => e.url === url);

    if (!endpoint) {
      throw new ConfigError(`Endpoint with URL ${url} not found`);
    }


    this.updateEndpoint(url, { status: 'checking' });

    try {
      const status = await this.testEndpointFn(url, credentials || endpoint.credentials);


      this.updateEndpoint(url, {
        status: status ? 'active' : 'inactive',
        lastChecked: new Date().toISOString()
      });


      eventBus.emit(EVENTS.ENDPOINT_STATUS_CHANGED, {
        url,
        status: status ? 'active' : 'inactive'
      });

      return status;
    } catch (error) {
      console.error(`Error checking endpoint ${url}:`, error);

      this.updateEndpoint(url, {
        status: 'inactive',
        lastChecked: new Date().toISOString(),
        lastError: error.message
      });


      eventBus.emit(EVENTS.ENDPOINT_STATUS_CHANGED, {
        url,
        status: 'inactive',
        error: error.message
      });

      return false;
    }
  }





  async checkEndpointsHealth() {
    const endpoints = getEndpoints(store.getState());

    if (endpoints.length === 0) {
      console.log('No endpoints to check');
      return {
        success: false,
        message: 'No endpoints configured'
      };
    }

    console.log(`Checking health of ${endpoints.length} endpoints...`);


    endpoints.forEach(endpoint => {
      this.updateEndpoint(endpoint.url, { status: 'checking' });
    });


    try {
      const results = await Promise.all(
        endpoints.map(async (endpoint) => {
          try {
            const isActive = await this.testEndpointFn(endpoint.url, endpoint.credentials);

            this.updateEndpoint(endpoint.url, {
              status: isActive ? 'active' : 'inactive',
              lastChecked: new Date().toISOString()
            });

            return {
              url: endpoint.url,
              label: endpoint.label,
              type: endpoint.type,
              isActive,
              error: null
            };
          } catch (error) {
            console.error(`Error checking endpoint ${endpoint.url}:`, error);

            this.updateEndpoint(endpoint.url, {
              status: 'inactive',
              lastChecked: new Date().toISOString(),
              lastError: error.message
            });

            return {
              url: endpoint.url,
              label: endpoint.label,
              type: endpoint.type,
              isActive: false,
              error: error.message
            };
          }
        })
      );


      try {
        const anyActive = results.some(r => r.isActive);
        const queryActive = results.some(r => r.isActive && r.type === 'query');
        const updateActive = results.some(r => r.isActive && r.type === 'update');

        eventBus.emit(EVENTS.ENDPOINTS_STATUS_CHECKED, {
          results,
          anyActive,
          queryActive,
          updateActive
        });
      } catch (error) {
        console.error('Error dispatching endpoints status event:', error);
      }


      return {
        success: true,
        anyActive: results.some(r => r.isActive),
        queryActive: results.some(r => r.isActive && r.type === 'query'),
        updateActive: results.some(r => r.isActive && r.type === 'update'),
        results
      };
    } catch (error) {
      console.error('Error checking endpoints health:', error);
      return { success: false, message: error.message };
    }
  }






  getActiveEndpoint(type) {
    const endpoints = getEndpoints(store.getState());
    return endpoints.find(e => e.type === type && e.status === 'active');
  }
}


export function createEndpointsService(storageService, config, testEndpointFn) {
  return new EndpointsService(storageService, config, testEndpointFn);
}

================
File: src/services/rdf/rdf-extractor.js
================
import rdf from 'rdf-ext';
import { generateNid } from '../../utils/utils.js';
import { namespaces } from '../../utils/utils.js';

export class RDFFormExtractor {
  constructor() {
    this.dataset = rdf.dataset();
  }

  async extract(form) {
    const formData = new FormData(form);
    const subject = rdf.namedNode(generateNid(formData.get('title')));

    for (const element of form.elements) {
      if (!element.name) continue;

      const predicate = rdf.namedNode(element.dataset.namespace + element.dataset.term);
      const object = this.createObject(element);

      if (object) {
        this.dataset.add(rdf.quad(subject, predicate, object));
      }
    }


    const type = rdf.namedNode('http://purl.org/stuff/squirt/' + form.dataset.type);
    const now = new Date().toISOString();

    this.dataset.add(rdf.quad(
      subject,
      rdf.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
      type
    ));

    this.dataset.add(rdf.quad(
      subject,
      rdf.namedNode('http://purl.org/dc/terms/created'),
      rdf.literal(now, rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
    ));

    return this.dataset;
  }

  createObject(element) {
    const value = element.value.trim();
    if (!value) return null;

    switch (element.type) {
      case 'url':
        return rdf.namedNode(value);
      case 'number':
        return rdf.literal(value, rdf.namedNode('http://www.w3.org/2001/XMLSchema#decimal'));
      default:
        return rdf.literal(value);
    }
  }
}






export async function extractFromUrl(url) {
  try {
    const metadata = await extractMetadataFromUrl(url);
    return {
      metadata,
      dataset: createDatasetFromMetadata(metadata)
    };
  } catch (error) {
    console.error('Error extracting from URL:', error);
    throw error;
  }
}






export function createDatasetFromMetadata(metadata) {
  const dataset = rdf.dataset();
  const subject = rdf.namedNode(generateNid(metadata.url));


  dataset.add(rdf.quad(
    subject,
    rdf.namedNode(namespaces.rdf + 'type'),
    rdf.namedNode(namespaces.squirt + 'link')
  ));


  if (metadata.url) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.squirt + 'url'),
      rdf.namedNode(metadata.url)
    ));
  }


  if (metadata.title) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.dc + 'title'),
      rdf.literal(metadata.title)
    ));
  }


  if (metadata.description) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.dc + 'description'),
      rdf.literal(metadata.description)
    ));
  }


  if (metadata.image) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.squirt + 'image'),
      rdf.namedNode(metadata.image)
    ));
  }


  if (metadata.siteName) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.squirt + 'siteName'),
      rdf.literal(metadata.siteName)
    ));
  }


  if (metadata.author) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.dc + 'creator'),
      rdf.literal(metadata.author)
    ));
  }


  if (metadata.date) {
    dataset.add(rdf.quad(
      subject,
      rdf.namedNode(namespaces.dc + 'date'),
      rdf.literal(metadata.date, rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
    ));
  }


  if (metadata.tags && Array.isArray(metadata.tags)) {
    metadata.tags.forEach(tag => {
      dataset.add(rdf.quad(
        subject,
        rdf.namedNode(namespaces.squirt + 'tag'),
        rdf.literal(tag)
      ));
    });
  }


  const now = new Date().toISOString();
  dataset.add(rdf.quad(
    subject,
    rdf.namedNode(namespaces.dc + 'created'),
    rdf.literal(now, rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
  ));

  return dataset;
}






export async function extractMetadataFromUrl(url) {
  try {

    if (!url) {
      throw new Error('URL is required');
    }


    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;

    const response = await fetch(proxyUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch URL: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    const html = data.contents;


    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');


    const metadata = {
      url: url,
      title: extractTitle(doc),
      description: extractDescription(doc),
      image: extractImage(doc, url),
      siteName: extractSiteName(doc),
      type: extractType(doc),
      date: extractDate(doc),
      author: extractAuthor(doc),
      tags: extractTags(doc)
    };

    return metadata;
  } catch (error) {
    console.error('Error extracting metadata:', error);

    return {
      url: url,
      title: extractBasicTitleFromUrl(url),
      error: error.message
    };
  }
}






function extractTitle(doc) {

  const ogTitle = doc.querySelector('meta[property="og:title"]');
  if (ogTitle) {
    return ogTitle.getAttribute('content');
  }


  const twitterTitle = doc.querySelector('meta[name="twitter:title"]');
  if (twitterTitle) {
    return twitterTitle.getAttribute('content');
  }


  const docTitle = doc.querySelector('title');
  if (docTitle && docTitle.textContent) {
    return docTitle.textContent.trim();
  }


  const h1 = doc.querySelector('h1');
  if (h1 && h1.textContent) {
    return h1.textContent.trim();
  }

  return '';
}

/**
 * Extract description from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted description
 */
function extractDescription(doc) {
  // Try Open Graph description
  const ogDesc = doc.querySelector('meta[property="og:description"]');
  if (ogDesc) {
    return ogDesc.getAttribute('content');
  }


  const twitterDesc = doc.querySelector('meta[name="twitter:description"]');
  if (twitterDesc) {
    return twitterDesc.getAttribute('content');
  }


  const metaDesc = doc.querySelector('meta[name="description"]');
  if (metaDesc) {
    return metaDesc.getAttribute('content');
  }

  return '';
}

/**
 * Extract image from document
 * @param {Document} doc - The HTML document
 * @param {string} baseUrl - The base URL for resolving relative URLs
 * @returns {string} - The extracted image URL
 */
function extractImage(doc, baseUrl) {
  // Try Open Graph image
  const ogImage = doc.querySelector('meta[property="og:image"]');
  if (ogImage) {
    const imageSrc = ogImage.getAttribute('content');
    return resolveUrl(imageSrc, baseUrl);
  }


  const twitterImage = doc.querySelector('meta[name="twitter:image"]');
  if (twitterImage) {
    const imageSrc = twitterImage.getAttribute('content');
    return resolveUrl(imageSrc, baseUrl);
  }


  const articleImage = doc.querySelector('article img, .content img, .post img');
  if (articleImage) {
    const imageSrc = articleImage.getAttribute('src');
    return resolveUrl(imageSrc, baseUrl);
  }

  return '';
}

/**
 * Extract site name from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted site name
 */
function extractSiteName(doc) {
  // Try Open Graph site name
  const ogSite = doc.querySelector('meta[property="og:site_name"]');
  if (ogSite) {
    return ogSite.getAttribute('content');
  }


  const schemaWebsite = doc.querySelector('[itemtype="http://schema.org/WebSite"] [itemprop="name"]');
  if (schemaWebsite) {
    return schemaWebsite.textContent.trim();
  }

  return '';
}

/**
 * Extract content type from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted type
 */
function extractType(doc) {
  // Try Open Graph type
  const ogType = doc.querySelector('meta[property="og:type"]');
  if (ogType) {
    return ogType.getAttribute('content');
  }


  const schemaType = doc.querySelector('[itemtype]');
  if (schemaType) {
    const type = schemaType.getAttribute('itemtype');
    return type.replace('http://schema.org/', '');
  }

  return 'website';
}






function extractDate(doc) {

  const metaDate = doc.querySelector('meta[property="article:published_time"]');
  if (metaDate) {
    return metaDate.getAttribute('content');
  }


  const schemaDate = doc.querySelector('[itemprop="datePublished"]');
  if (schemaDate) {
    return schemaDate.getAttribute('content') || schemaDate.textContent.trim();
  }


  const timeElement = doc.querySelector('time');
  if (timeElement) {
    return timeElement.getAttribute('datetime') || timeElement.textContent.trim();
  }

  return '';
}

/**
 * Extract author from document
 * @param {Document} doc - The HTML document
 * @returns {string} - The extracted author
 */
function extractAuthor(doc) {
  // Try meta author
  const metaAuthor = doc.querySelector('meta[name="author"]');
  if (metaAuthor) {
    return metaAuthor.getAttribute('content');
  }


  const ogAuthor = doc.querySelector('meta[property="article:author"]');
  if (ogAuthor) {
    return ogAuthor.getAttribute('content');
  }


  const schemaAuthor = doc.querySelector('[itemprop="author"] [itemprop="name"]');
  if (schemaAuthor) {
    return schemaAuthor.textContent.trim();
  }


  const byline = doc.querySelector('.byline, .author');
  if (byline) {
    return byline.textContent.trim().replace(/^By\s+/i, '');
  }

  return '';
}

/**
 * Extract tags/keywords from document
 * @param {Document} doc - The HTML document
 * @returns {string[]} - The extracted tags
 */
function extractTags(doc) {
  const tags = [];

  // Try meta keywords
  const metaKeywords = doc.querySelector('meta[name="keywords"]');
  if (metaKeywords) {
    const keywordsStr = metaKeywords.getAttribute('content');
    if (keywordsStr) {
      tags.push(...keywordsStr.split(',').map(tag => tag.trim()));
    }
  }


  const articleTags = doc.querySelectorAll('meta[property="article:tag"]');
  articleTags.forEach(tag => {
    tags.push(tag.getAttribute('content'));
  });


  const tagLinks = doc.querySelectorAll('.tags a, .categories a, .topics a');
  tagLinks.forEach(link => {
    tags.push(link.textContent.trim());
  });

  return [...new Set(tags)];
}







function resolveUrl(url, base) {
  if (!url) return '';
  try {
    return new URL(url, base).href;
  } catch (e) {
    return url;
  }
}

/**
 * Extract a basic title from the URL if nothing else is available
 * @param {string} url - The URL
 * @returns {string} - A title derived from the URL
 */
function extractBasicTitleFromUrl(url) {
  try {
    const urlObj = new URL(url);
    const path = urlObj.pathname;

    // Get the last part of the path
    const parts = path.split('/').filter(Boolean);

    if (parts.length > 0) {
      // Get the last part and clean it up
      const lastPart = parts[parts.length - 1]
        .replace(/\.html$|\.php$|\.aspx$/, '')
        .replace(/-|_/g, ' ');

      // Capitalize first letter of each word
      return lastPart
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }

    // Fall back to domain if no path
    return urlObj.hostname.replace('www.', '');
  } catch (e) {
    // If all fails, return a portion of the URL
    return url.substring(0, 50) + (url.length > 50 ? '...' : '');
  }
}

================
File: src/services/rdf/rdf-model.js
================
import rdf from 'rdf-ext';
import N3Parser from '@rdfjs/parser-n3';
import { namespaces, generateNid } from '../../utils/utils.js';
import { state } from '../../core/state.js';
import { querySparql, postToSparql } from '../../../services/sparql/sparql.js';

export class RDFModel {
  constructor() {
    this.parser = new N3Parser();
    this.ns = {};


    Object.entries(namespaces).forEach(([prefix, uri]) => {
      this.ns[prefix] = rdf.namespace(uri);
    });


    this.loadCachedData();
  }

  async loadCachedData() {
    try {
      const cachedData = localStorage.getItem('squirt_rdf_cache');
      if (cachedData) {
        const dataset = await this.parseFromString(cachedData);
        state.update('rdfDataset', dataset);
      } else {
        state.update('rdfDataset', rdf.dataset());
      }
    } catch (error) {
      console.error('Error loading cached RDF data:', error);
      state.update('rdfDataset', rdf.dataset());
    }
  }

  saveToCache(dataset) {
    try {
      localStorage.setItem('squirt_rdf_cache', dataset.toString());
    } catch (error) {
      console.error('Error caching RDF data:', error);
    }
  }

  async parseFromString(turtleString) {
    try {
      const quads = [];
      const parser = this.parser;

      return new Promise((resolve, reject) => {
        const stream = parser.import(rdf.stringToStream(turtleString));

        stream.on('data', quad => {
          quads.push(quad);
        });

        stream.on('error', error => {
          reject(error);
        });

        stream.on('end', () => {
          resolve(rdf.dataset(quads));
        });
      });
    } catch (error) {
      console.error('Error parsing RDF data:', error);
      throw error;
    }
  }












  createPost(postData) {
    const dataset = state.get('rdfDataset') || rdf.dataset();


    const postId = postData.customId || generateNid(postData.content);
    const subject = rdf.namedNode(postId);


    const graph = postData.graph ?
      rdf.namedNode(postData.graph) :
      null;


    const addQuad = (s, p, o) => {
      if (graph) {
        dataset.add(rdf.quad(s, p, o, graph));
      } else {
        dataset.add(rdf.quad(s, p, o));
      }
    };


    addQuad(
      subject,
      this.ns.rdf('type'),
      this.ns.squirt(postData.type)
    );


    addQuad(
      subject,
      this.ns.squirt('content'),
      rdf.literal(postData.content)
    );


    addQuad(
      subject,
      this.ns.dc('created'),
      rdf.literal(new Date().toISOString(), rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
    );


    if (postData.title) {
      addQuad(
        subject,
        this.ns.dc('title'),
        rdf.literal(postData.title)
      );
    }


    if (postData.tags && Array.isArray(postData.tags)) {
      postData.tags.forEach(tag => {
        addQuad(
          subject,
          this.ns.squirt('tag'),
          rdf.literal(tag)
        );
      });
    }


    if (postData.type === 'link' && postData.url) {
      addQuad(
        subject,
        this.ns.squirt('url'),
        rdf.namedNode(postData.url)
      );
    }


    if (postData.type === 'wiki') {

      addQuad(
        subject,
        this.ns.dc('modified'),
        rdf.literal(new Date().toISOString(), rdf.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'))
      );
    }


    state.update('rdfDataset', dataset);


    this.saveToCache(dataset);

    return postId;
  }










  getPosts(options = {}) {
    const dataset = state.get('rdfDataset');
    if (!dataset) return [];

    let posts = new Map();


    const postTypePattern = this.ns.rdf('type');


    const matchOptions = {};
    if (options.graph) {
      matchOptions.graph = rdf.namedNode(options.graph);
    }


    dataset.match(null, postTypePattern, null, options.graph ? rdf.namedNode(options.graph) : null).forEach(quad => {
      const postType = quad.object.value.split('/').pop();


      if (options.type && postType !== options.type) return;

      const postId = quad.subject.value;
      const graphId = quad.graph?.value || null;

      if (!posts.has(postId)) {
        posts.set(postId, {
          id: postId,
          type: postType,
          graph: graphId,
          tags: []
        });
      }
    });


    posts.forEach((post, id) => {
      const subject = rdf.namedNode(id);
      const graph = post.graph ? rdf.namedNode(post.graph) : null;


      dataset.match(subject, this.ns.squirt('content'), null, graph).forEach(quad => {
        post.content = quad.object.value;
      });


      dataset.match(subject, this.ns.dc('title'), null, graph).forEach(quad => {
        post.title = quad.object.value;
      });


      dataset.match(subject, this.ns.dc('created'), null, graph).forEach(quad => {
        post.created = quad.object.value;
      });


      dataset.match(subject, this.ns.dc('modified'), null, graph).forEach(quad => {
        post.modified = quad.object.value;
      });


      dataset.match(subject, this.ns.squirt('tag'), null, graph).forEach(quad => {
        post.tags.push(quad.object.value);
      });


      dataset.match(subject, this.ns.squirt('url'), null, graph).forEach(quad => {
        post.url = quad.object.value;
      });
    });


    if (options.tag) {
      posts = new Map(
        Array.from(posts.entries()).filter(([_, post]) =>
          post.tags.includes(options.tag)
        )
      );
    }



    let postsArray = Array.from(posts.values())
      .sort((a, b) => {
        const dateA = a.modified ? new Date(a.modified) : new Date(a.created);
        const dateB = b.modified ? new Date(b.modified) : new Date(b.created);
        return dateB - dateA;
      });


    if (options.limit && options.limit > 0) {
      postsArray = postsArray.slice(0, options.limit);
    }

    return postsArray;
  }




  async syncWithEndpoint() {
    const dataset = state.get('rdfDataset');
    if (!dataset || dataset.size === 0) return;

    try {
      await postToSparql(dataset);
      console.log('Data synchronized with SPARQL endpoint');
    } catch (error) {
      console.error('Failed to sync with SPARQL endpoint:', error);
      throw error;
    }
  }




  async loadFromEndpoint() {
    try {
      const query = `
        PREFIX rdf: <${namespaces.rdf}>
        PREFIX squirt: <${namespaces.squirt}>
        PREFIX dc: <${namespaces.dc}>

        CONSTRUCT {
          ?s ?p ?o .
        }
        WHERE {
          ?s rdf:type ?type .
          FILTER(STRSTARTS(STR(?type), "${namespaces.squirt}"))
          ?s ?p ?o .
        }
      `;

      const response = await querySparql(query);

      if (response && response.results) {
        const dataset = await this.parseFromString(response.results);
        state.update('rdfDataset', dataset);
        this.saveToCache(dataset);
        console.log('Loaded data from SPARQL endpoint');
      }
    } catch (error) {
      console.error('Failed to load data from SPARQL endpoint:', error);
      throw error;
    }
  }






  deletePost(postId) {
    const dataset = state.get('rdfDataset');
    if (!dataset) return false;

    const subject = rdf.namedNode(postId);


    const quadsToRemove = dataset.match(subject);

    if (quadsToRemove.size === 0) return false;

    quadsToRemove.forEach(quad => {
      dataset.delete(quad);
    });


    state.update('rdfDataset', dataset);


    this.saveToCache(dataset);

    return true;
  }
}


export const rdfModel = new RDFModel();

================
File: src/services/sparql/endpoints.js
================
import { state } from '../../core/state.js';
import { testEndpoint } from '../../js/services/sparql/sparql.js';
import { ErrorHandler } from '../../core/errors.js';

export class EndpointManager {
  constructor() {
    this.STORAGE_KEY = 'squirt_endpoints';
    this.statusCheckInterval = 60000;
  }

  async initialize() {
    try {
      console.log('Initializing endpoints manager...');


      const endpointsFromFile = this.loadFromConfig();


      const storedEndpoints = this.loadFromStorage();


      let endpoints = endpointsFromFile;

      if (storedEndpoints && storedEndpoints.length > 0) {

        const storedUrls = new Set(storedEndpoints.map(e => e.url));
        const newEndpoints = endpointsFromFile.filter(e => !storedUrls.has(e.url));

        endpoints = [...storedEndpoints, ...newEndpoints];
      }

      if (!endpoints || endpoints.length === 0) {
        console.warn('No endpoints found in config or storage, using defaults');
        endpoints = this.getDefaultEndpoints();
      }

      console.log(`Loaded ${endpoints.length} endpoints`);


      state.update('endpoints', endpoints);


      this.startStatusChecks();

      return endpoints;
    } catch (error) {
      console.error('Error initializing endpoints:', error);
      ErrorHandler.handle(error);
      const fallback = this.getDefaultEndpoints();
      state.update('endpoints', fallback);
      this.startStatusChecks();
      return fallback;
    }
  }

  loadFromStorage() {
    try {
      const stored = localStorage.getItem(this.STORAGE_KEY);
      return stored ? JSON.parse(stored) : null;
    } catch (error) {
      console.error('Error loading endpoints from storage:', error);
      return null;
    }
  }


  loadFromConfig() {
    try {

      const config = require('../../config.json');


      if (config && Array.isArray(config)) {
        console.log('Found endpoints in config.json:', config);
        return config.map(endpoint => ({
          url: endpoint.url,
          label: endpoint.name,
          type: endpoint.type,
          credentials: endpoint.credentials,
          status: 'unknown'
        }));
      }
      throw new Error('Invalid config format in config.json');
    } catch (error) {
      console.error('Error loading endpoints from config.json:', error);
      return [];
    }
  }

  getDefaultEndpoints() {
    console.warn('Using default endpoints as fallback');
    return [
      {
        url: 'http://localhost:3030/semem/query',
        label: 'Local Query Endpoint',
        type: 'query',
        status: 'unknown',
        credentials: {
          user: 'admin',
          password: 'admin123'
        }
      },
      {
        url: 'http://localhost:3030/semem/update',
        label: 'Local Update Endpoint',
        type: 'update',
        status: 'unknown',
        credentials: {
          user: 'admin',
          password: 'admin123'
        }
      }
    ];
  }

  async startStatusChecks() {
    const checkAll = async () => {
      const endpoints = state.get('endpoints');

      if (!endpoints || endpoints.length === 0) return;

      console.log(`Checking ${endpoints.length} endpoints...`);

      for (const endpoint of endpoints) {
        try {
          const status = await testEndpoint(endpoint.url, endpoint.credentials);
          endpoint.status = status ? 'active' : 'inactive';
          endpoint.lastChecked = new Date().toISOString();
          console.log(`Endpoint ${endpoint.url} status: ${endpoint.status}`);
        } catch (error) {
          console.error(`Error checking endpoint ${endpoint.url}:`, error);
          endpoint.status = 'inactive';
        }
      }

      state.update('endpoints', [...endpoints]);
      this.saveToStorage();
    };


    await checkAll();
    setInterval(checkAll, this.statusCheckInterval);
  }

  saveToStorage() {
    try {
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(state.get('endpoints')));
    } catch (error) {
      console.error('Error saving endpoints to storage:', error);
    }
  }

  addEndpoint(url, label, type = 'query', credentials = null) {
    const endpoints = state.get('endpoints') || [];


    if (endpoints.some(e => e.url === url)) {
      throw new Error(`Endpoint with URL ${url} already exists`);
    }

    endpoints.push({
      url,
      label,
      type,
      credentials,
      status: 'unknown',
      lastChecked: null
    });

    state.update('endpoints', endpoints);
    this.saveToStorage();


    this.checkEndpoint(url, credentials).then(status => {
      this.updateEndpoint(url, {
        status: status ? 'active' : 'inactive',
        lastChecked: new Date().toISOString()
      });
    });
  }

  async checkEndpoint(url, credentials = null) {
    return testEndpoint(url, credentials);
  }

  removeEndpoint(url) {
    const endpoints = state.get('endpoints').filter(e => e.url !== url);
    state.update('endpoints', endpoints);
    this.saveToStorage();
  }

  updateEndpoint(url, updates) {
    const endpoints = state.get('endpoints').map(e =>
      e.url === url ? { ...e, ...updates } : e
    );
    state.update('endpoints', endpoints);
    this.saveToStorage();
  }

  getActiveEndpoint(type) {
    const endpoints = state.get('endpoints') || [];
    return endpoints.find(e => e.type === type && e.status === 'active');
  }







  async checkEndpointsHealth() {

    const endpoints = [...(state.get('endpoints') || [])];

    if (endpoints.length === 0) {
      console.log('No endpoints to check');
      return { success: false, message: 'No endpoints configured' };
    }

    console.log(`Checking health of ${endpoints.length} endpoints...`);


    endpoints.forEach(endpoint => {
      endpoint.status = 'checking';
    });


    state.update('endpoints', endpoints);


    try {
      const results = await Promise.all(
        endpoints.map(async (endpoint) => {
          try {

            const isActive = await this.checkEndpoint(endpoint.url, endpoint.credentials);
            return {
              url: endpoint.url,
              label: endpoint.label,
              type: endpoint.type,
              isActive,
              error: null
            };
          } catch (error) {
            console.error(`Error checking endpoint ${endpoint.url}:`, error);
            return {
              url: endpoint.url,
              label: endpoint.label,
              type: endpoint.type,
              isActive: false,
              error: error.message
            };
          }
        })
      );


      const updatedEndpoints = endpoints.map(endpoint => {
        const result = results.find(r => r.url === endpoint.url);
        return {
          ...endpoint,
          status: result?.isActive ? 'active' : 'inactive',
          lastChecked: new Date().toISOString(),
          lastError: result?.error || null
        };
      });


      state.update('endpoints', updatedEndpoints);


      try {
        const anyActive = results.some(r => r.isActive);
        const queryActive = results.some(r => r.isActive && r.type === 'query');
        const updateActive = results.some(r => r.isActive && r.type === 'update');

        const event = new CustomEvent('endpointsStatusChecked', {
          detail: {
            results,
            anyActive,
            queryActive,
            updateActive
          }
        });

        document.dispatchEvent(event);
      } catch (error) {
        console.error('Error dispatching endpoints status event:', error);
      }


      return {
        success: true,
        anyActive: results.some(r => r.isActive),
        queryActive: results.some(r => r.isActive && r.type === 'query'),
        updateActive: results.some(r => r.isActive && r.type === 'update'),
        results
      };
    } catch (error) {
      console.error('Error checking endpoints health:', error);
      return { success: false, message: error.message };
    }
  }







  async checkEndpointsHealth() {

    const endpoints = [...(state.get('endpoints') || [])];

    if (endpoints.length === 0) {
      console.log('No endpoints to check');
      return { success: false, message: 'No endpoints configured' };
    }

    console.log(`Checking health of ${endpoints.length} endpoints...`);


    endpoints.forEach(endpoint => {
      endpoint.status = 'checking';
    });


    state.update('endpoints', endpoints);


    try {
      const results = await Promise.all(
        endpoints.map(async (endpoint) => {
          try {

            const isActive = await this.checkEndpoint(endpoint.url, endpoint.credentials);
            return {
              url: endpoint.url,
              label: endpoint.label,
              type: endpoint.type,
              isActive,
              error: null
            };
          } catch (error) {
            console.error(`Error checking endpoint ${endpoint.url}:`, error);
            return {
              url: endpoint.url,
              label: endpoint.label,
              type: endpoint.type,
              isActive: false,
              error: error.message
            };
          }
        })
      );


      const updatedEndpoints = endpoints.map(endpoint => {
        const result = results.find(r => r.url === endpoint.url);
        return {
          ...endpoint,
          status: result?.isActive ? 'active' : 'inactive',
          lastChecked: new Date().toISOString(),
          lastError: result?.error || null
        };
      });


      state.update('endpoints', updatedEndpoints);


      try {
        const anyActive = results.some(r => r.isActive);
        const queryActive = results.some(r => r.isActive && r.type === 'query');
        const updateActive = results.some(r => r.isActive && r.type === 'update');

        const event = new CustomEvent('endpointsStatusChecked', {
          detail: {
            results,
            anyActive,
            queryActive,
            updateActive
          }
        });

        document.dispatchEvent(event);
      } catch (error) {
        console.error('Error dispatching endpoints status event:', error);
      }


      return {
        success: true,
        anyActive: results.some(r => r.isActive),
        queryActive: results.some(r => r.isActive && r.type === 'query'),
        updateActive: results.some(r => r.isActive && r.type === 'update'),
        results
      };
    } catch (error) {
      console.error('Error checking endpoints health:', error);
      return { success: false, message: error.message };
    }
  }
}


export const endpointManager = new EndpointManager();

================
File: src/services/sparql/sparql-service.js
================
import { SparqlError, NetworkError } from '../../core/errors/error-types.js';
import { eventBus, EVENTS } from '../../core/events/event-bus.js';




export class SparqlService {




  constructor(getEndpointFn) {
    this.getEndpointFn = getEndpointFn;
  }






  async querySparql(query) {
    if (!query) {
      throw new SparqlError('Query is required');
    }

    try {
      const endpoint = this.getEndpointFn('query');

      if (!endpoint) {
        throw new SparqlError('No active query endpoint available');
      }

      const headers = {
        'Content-Type': 'application/sparql-query',
        'Accept': 'application/sparql-results+json, application/json'
      };


      if (endpoint.credentials) {
        const { user, password } = endpoint.credentials;
        const auth = btoa(`${user}:${password}`);
        headers['Authorization'] = `Basic ${auth}`;
      }

      eventBus.emit(EVENTS.SPARQL_QUERY_STARTED, { query, endpoint: endpoint.url });

      try {
        const response = await fetch(endpoint.url, {
          method: 'POST',
          headers,
          body: query
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new SparqlError(`SPARQL query failed: ${response.status} ${errorText}`, {
            query,
            endpoint: endpoint.url,
            status: response.status,
            response: errorText
          });
        }

        const result = await response.json();

        eventBus.emit(EVENTS.SPARQL_QUERY_COMPLETED, {
          query,
          endpoint: endpoint.url,
          resultCount: result.results?.bindings?.length || 0
        });

        return result;
      } catch (error) {
        if (error instanceof SparqlError) {
          throw error;
        }

        if (error.message.includes('fetch')) {
          throw new NetworkError(`Network error when querying endpoint ${endpoint.url}`, {
            query,
            endpoint: endpoint.url,
            originalError: error
          });
        }

        throw new SparqlError(`Error querying endpoint ${endpoint.url}`, {
          query,
          endpoint: endpoint.url,
          originalError: error
        });
      }
    } catch (error) {
      eventBus.emit(EVENTS.SPARQL_QUERY_FAILED, {
        query,
        error
      });
      throw error;
    }
  }






  async postToSparql(dataset) {
    if (!dataset) {
      throw new SparqlError('Dataset is required');
    }

    try {
      const endpoint = this.getEndpointFn('update');

      if (!endpoint) {
        throw new SparqlError('No active update endpoint available');
      }

      const insertQuery = `
        INSERT DATA {
          ${dataset.toString()}
        }
      `;

      const headers = {
        'Content-Type': 'application/sparql-update',
        'Accept': 'application/json, */*'
      };


      if (endpoint.credentials) {
        const { user, password } = endpoint.credentials;
        const auth = btoa(`${user}:${password}`);
        headers['Authorization'] = `Basic ${auth}`;
      }

      eventBus.emit(EVENTS.SPARQL_UPDATE_STARTED, {
        endpoint: endpoint.url,
        datasetSize: dataset.size
      });

      try {
        const response = await fetch(endpoint.url, {
          method: 'POST',
          headers,
          body: insertQuery
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new SparqlError(`SPARQL update failed: ${response.status} ${errorText}`, {
            endpoint: endpoint.url,
            status: response.status,
            response: errorText
          });
        }

        eventBus.emit(EVENTS.SPARQL_UPDATE_COMPLETED, {
          endpoint: endpoint.url,
          datasetSize: dataset.size
        });

        return true;
      } catch (error) {
        if (error instanceof SparqlError) {
          throw error;
        }

        if (error.message.includes('fetch')) {
          throw new NetworkError(`Network error when updating endpoint ${endpoint.url}`, {
            endpoint: endpoint.url,
            originalError: error
          });
        }

        throw new SparqlError(`Error updating endpoint ${endpoint.url}`, {
          endpoint: endpoint.url,
          originalError: error
        });
      }
    } catch (error) {
      eventBus.emit(EVENTS.SPARQL_UPDATE_FAILED, {
        error
      });
      throw error;
    }
  }







  async testEndpoint(url, credentials) {
    try {
      const headers = {
        'Content-Type': 'application/sparql-query',
        'Accept': 'application/sparql-results+json, application/json'
      };

      if (credentials) {
        const { user, password } = credentials;
        const auth = btoa(`${user}:${password}`);
        headers['Authorization'] = `Basic ${auth}`;
      }


      const query = 'ASK { ?s ?p ?o } LIMIT 1';

      const response = await fetch(url, {
        method: 'POST',
        headers,
        body: query
      });

      return response.ok;
    } catch (error) {
      console.warn(`Endpoint test failed for ${url}:`, error);
      return false;
    }
  }
}


export function createSparqlService(getEndpointFn) {
  return new SparqlService(getEndpointFn);
}

================
File: src/services/sparql/sparql.js
================
import { state } from '../../core/state.js';
import { ErrorHandler } from '../../core/errors.js';






export function getEndpoint(type) {
  const endpoints = state.get('endpoints') || [];
  const endpoint = endpoints.find(e => e.type === type && e.status === 'active');

  if (!endpoint) {
    throw new Error(`No active ${type} endpoint available. Please check your SPARQL configuration.`);
  }

  return endpoint;
}






export async function postToSparql(dataset) {
  if (!dataset) {
    throw new Error('Dataset is required');
  }

  const endpoint = getEndpoint('update');
  const insertQuery = `
    INSERT DATA {
      ${dataset.toString()}
    }
  `;

  try {
    const headers = {
      'Content-Type': 'application/sparql-update',
      'Accept': 'application/json, */*'
    };


    if (endpoint.credentials) {
      const { user, password } = endpoint.credentials;
      const auth = btoa(`${user}:${password}`);
      headers['Authorization'] = `Basic ${auth}`;
    }

    const response = await fetch(endpoint.url, {
      method: 'POST',
      headers,
      body: insertQuery
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`SPARQL update failed for endpoint ${endpoint.url}: ${response.status} ${errorText}`);
    }
    return true;
  } catch (error) {
    ErrorHandler.handle(error);
    throw error;
  }
}






export async function querySparql(query) {
  if (!query) {
    throw new Error('Query is required');
  }

  const endpoint = getEndpoint('query');

  try {
    const headers = {
      'Content-Type': 'application/sparql-query',
      'Accept': 'application/sparql-results+json, application/json'
    };


    if (endpoint.credentials) {
      const { user, password } = endpoint.credentials;
      const auth = btoa(`${user}:${password}`);
      headers['Authorization'] = `Basic ${auth}`;
    }

    const response = await fetch(endpoint.url, {
      method: 'POST',
      headers,
      body: query
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`SPARQL query failed for endpoint ${endpoint.url}: ${response.status} ${errorText}\n${query}`);
    }

    return response.json();
  } catch (error) {
    ErrorHandler.handle(error);
    throw error;
  }
}







export async function testEndpoint(url, credentials) {
  try {
    const headers = {
      'Content-Type': 'application/sparql-query',
      'Accept': 'application/sparql-results+json, application/json'
    };

    if (credentials) {
      const { user, password } = credentials;
      const auth = btoa(`${user}:${password}`);
      headers['Authorization'] = `Basic ${auth}`;
    }


    const query = 'ASK { ?s ?p ?o } LIMIT 1';

    const response = await fetch(url, {
      method: 'POST',
      headers,
      body: query
    });

    return response.ok;
  } catch (error) {
    console.error(`Endpoint test failed for ${url}:`, error);
    return false;
  }
}

================
File: src/services/storage/storage-service.js
================
import { StorageError } from '../../core/errors/error-types.js';




class StorageService {
  constructor(prefix = 'squirt_') {
    this.prefix = prefix;
  }






  getItem(key) {
    try {
      const value = localStorage.getItem(`${this.prefix}${key}`);
      if (value === null) return null;

      try {

        return JSON.parse(value);
      } catch (e) {

        return value;
      }
    } catch (error) {
      console.error(`Error getting item ${key}:`, error);
      throw new StorageError(`Failed to get item "${key}" from localStorage`);
    }
  }






  setItem(key, value) {
    try {
      const serializedValue = typeof value === 'string'
        ? value
        : JSON.stringify(value);

      localStorage.setItem(`${this.prefix}${key}`, serializedValue);
    } catch (error) {
      console.error(`Error setting item ${key}:`, error);
      throw new StorageError(`Failed to set item "${key}" in localStorage`);
    }
  }





  removeItem(key) {
    try {
      localStorage.removeItem(`${this.prefix}${key}`);
    } catch (error) {
      console.error(`Error removing item ${key}:`, error);
      throw new StorageError(`Failed to remove item "${key}" from localStorage`);
    }
  }
}


export const storageService = new StorageService();


export function createStorageService(prefix) {
  return new StorageService(prefix);
}

================
File: src/services/templates/post-article.njk
================
PREFIX schema: <http://schema.org/>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX : <http://purl.org/stuff/transmissions/>

INSERT DATA {
    GRAPH <http://purl.org/stuff/squirt/> {
        <{{uri}}> a schema:Article ;
            schema:headline "{{title}}" ;
            schema:dateCreated "{{dates.created}}"^^xsd:dateTime ;
            schema:dateModified "{{dates.modified}}"^^xsd:dateTime ;
            schema:articleBody """{{content}}""" ;
            schema:creator <{{creator.uri}}> ;
            :tag "tag1" ;
            :tag "tag2" .
        <{{creator.uri}}> a schema:Person ;
            schema:name "{{creator.name}}" .
    }
}

================
File: src/ui/components/endpoint-indicator.js
================
import { state } from '../../core/state.js';




export class EndpointStatusIndicator {
  constructor() {

    this.handleEndpointChange = this.handleEndpointChange.bind(this);
    this.handleStatusChangeEvent = this.handleStatusChangeEvent.bind(this);
    this.handleStatusCheckedEvent = this.handleStatusCheckedEvent.bind(this);

    this.indicator = document.getElementById('endpoint-status-indicator');

    if (!this.indicator) {
      console.error('Endpoint status indicator element not found');
      return;
    }


    this.statusLight = this.indicator.querySelector('.status-light');


    this.updateStatus('checking', 'Checking endpoint status...');


    state.subscribe('endpoints', this.handleEndpointChange);


    document.addEventListener('endpointStatusChanged', this.handleStatusChangeEvent);
    document.addEventListener('endpointsStatusChecked', this.handleStatusCheckedEvent);


    this.indicator.addEventListener('click', () => {
      this.updateStatus('checking', 'Checking endpoints...');


      try {
        const event = new CustomEvent('checkEndpointsRequest');
        document.dispatchEvent(event);
      } catch (error) {
        console.error('Error dispatching endpoint check request:', error);
      }
    });
  }




  handleEndpointChange(endpoints) {
    try {
      if (!endpoints || endpoints.length === 0) {
        this.updateStatus('inactive', 'No endpoints configured');
        return;
      }

      const activeEndpoint = endpoints.find(e => e.status === 'active');
      if (activeEndpoint) {
        this.updateStatus('active', `SPARQL endpoint available: ${activeEndpoint.url}`);
      } else if (endpoints.some(e => e.status === 'checking')) {
        this.updateStatus('checking', 'Checking endpoints...');
      } else {
        this.updateStatus('inactive', 'No available endpoints');
      }
    } catch (error) {
      console.error('Error handling endpoint change:', error);
    }
  }




  handleStatusChangeEvent(e) {
    try {
      if (e.detail) {
        const { status, url, label } = e.detail;

        if (status === 'active') {
          this.updateStatus('active', `SPARQL endpoint available: ${url}`);
        }
      }
    } catch (error) {
      console.error('Error handling status change event:', error);
    }
  }




  handleStatusCheckedEvent(e) {
    try {
      if (e.detail && e.detail.anyActive) {

        const endpoints = state.get('endpoints') || [];
        const activeEndpoint = endpoints.find(e => e.status === 'active');

        if (activeEndpoint) {
          this.updateStatus('active', `SPARQL endpoint available: ${activeEndpoint.url}`);
        } else {
          this.updateStatus('active', 'SPARQL endpoint is available');
        }
      } else {
        this.updateStatus('inactive', 'No available endpoints');
      }
    } catch (error) {
      console.error('Error handling status checked event:', error);
    }
  }






  updateStatus(status, message = '') {
    try {
      if (!this.statusLight) return;

      // Remove all status classes
      this.statusLight.classList.remove('active', 'inactive', 'checking');


      this.statusLight.classList.add(status);


      this.indicator.title = message || status;
    } catch (error) {
      console.error('Error updating status:', error);
    }
  }
}




export function initializeEndpointIndicator() {
  try {
    return new EndpointStatusIndicator();
  } catch (error) {
    console.error('Error initializing endpoint indicator:', error);
    return null;
  }
}

================
File: src/ui/components/endpoints-list.js
================
import { state } from '../../core/state.js';
import { ErrorHandler } from '../../core/errors.js';


export function setupEndpointsList() {
    const container = document.getElementById('endpoints-list');
    if (!container) return;


    renderEndpointsList(container);


    state.subscribe('endpoints', () => renderEndpointsList(container));


    container.addEventListener('click', async (e) => {

        const item = e.target.closest('.endpoint-item');
        if (!item) return;

        const url = item.dataset.url;

        try {

            if (e.target.matches('.check-endpoint')) {
                await checkEndpoint(url, item);
            }

            else if (e.target.matches('.remove-endpoint')) {
                if (confirm('Are you sure you want to remove this endpoint?')) {
                    removeEndpoint(url);

                    showNotification('Endpoint removed', 'info');
                }
            }

            else if (e.target.matches('.edit-endpoint')) {
                toggleEditMode(item);
            }

            else if (e.target.matches('.save-endpoint')) {
                saveEndpointChanges(item);
            }
        } catch (error) {
            ErrorHandler.handle(error);
            showNotification('Operation failed: ' + error.message, 'error');
        }
    });
}

function renderEndpointsList(container) {
    const endpoints = state.get('endpoints') || [];

    if (endpoints.length === 0) {
        container.innerHTML = '<p>No endpoints configured yet.</p>';
        return;
    }

    container.innerHTML = endpoints.map(endpoint => `
        <div class="endpoint-item" data-url="${endpoint.url}">
            <div class="endpoint-info">
                <div class="endpoint-header">
                    <div class="endpoint-status ${endpoint.status || 'unknown'}"></div>
                    <div class="endpoint-details">
                        <span class="endpoint-label">${endpoint.label}</span>
                        <span class="endpoint-type">(${endpoint.type})</span>
                    </div>
                </div>
                <div class="endpoint-url">${endpoint.url}</div>
                <div class="endpoint-edit-form" style="display: none;">
                    <div class="form-field">
                        <label for="edit-label-${encodeURIComponent(endpoint.url)}">Label</label>
                        <input type="text" class="edit-label" id="edit-label-${encodeURIComponent(endpoint.url)}" value="${endpoint.label}">
                    </div>
                    <div class="form-field">
                        <label for="edit-type-${encodeURIComponent(endpoint.url)}">Type</label>
                        <select class="edit-type" id="edit-type-${encodeURIComponent(endpoint.url)}">
                            <option value="query" ${endpoint.type === 'query' ? 'selected' : ''}>Query</option>
                            <option value="update" ${endpoint.type === 'update' ? 'selected' : ''}>Update</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="endpoint-actions">
                <button class="check-endpoint">Check</button>
                <button class="edit-endpoint">Edit</button>
                <button class="save-endpoint" style="display: none;">Save</button>
                <button class="remove-endpoint">Remove</button>
            </div>
        </div>
    `).join('');
}

async function checkEndpoint(url, item) {
    const statusIndicator = item.querySelector('.endpoint-status');


    statusIndicator.className = 'endpoint-status checking';

    try {

        const { EndpointManager } = await import('../../services/sparql/endpoints.js');
        const endpointManager = new EndpointManager();


        const endpoints = state.get('endpoints');
        const endpoint = endpoints.find(e => e.url === url);

        if (!endpoint) {
            throw new Error('Endpoint not found');
        }


        const status = await endpointManager.checkEndpoint(url, endpoint.credentials);


        endpointManager.updateEndpoint(url, {
            status: status ? 'active' : 'inactive',
            lastChecked: new Date().toISOString()
        });


        showNotification(
            `Endpoint is ${status ? 'active' : 'inactive'}`,
            status ? 'success' : 'error'
        );
    } catch (error) {
        console.error('Error checking endpoint:', error);
        statusIndicator.className = 'endpoint-status error';
        throw error;
    }
}

function removeEndpoint(url) {

    import('../../services/sparql/endpoints.js').then(({ EndpointManager }) => {
        const endpointManager = new EndpointManager();
        endpointManager.removeEndpoint(url);
    });
}

function toggleEditMode(item) {
    const editForm = item.querySelector('.endpoint-edit-form');
    const saveButton = item.querySelector('.save-endpoint');
    const editButton = item.querySelector('.edit-endpoint');

    if (editForm.style.display === 'none') {

        editForm.style.display = 'block';
        saveButton.style.display = 'inline-block';
        editButton.style.display = 'none';
    } else {

        editForm.style.display = 'none';
        saveButton.style.display = 'none';
        editButton.style.display = 'inline-block';
    }
}

function saveEndpointChanges(item) {
    const url = item.dataset.url;
    const label = item.querySelector('.edit-label').value;
    const type = item.querySelector('.edit-type').value;


    import('../../services/sparql/endpoints.js').then(({ EndpointManager }) => {
        const endpointManager = new EndpointManager();
        endpointManager.updateEndpoint(url, { label, type });


        toggleEditMode(item);


        showNotification('Endpoint updated successfully', 'success');
    });
}


window.updateEndpointsList = function () {
    const container = document.getElementById('endpoints-list');
    if (container) {
        renderEndpointsList(container);
    }
};

function showNotification(message, type = 'info') {

    if (typeof window.showNotification === 'function') {
        window.showNotification(message, type);
        return;
    }


    console.log(`${type.toUpperCase()}: ${message}`);
}

================
File: src/ui/components/forms.js
================
import { state } from '../../core/state.js';
import { ErrorHandler } from '../../core/errors.js';
import { rdfModel } from '../../services/rdf/rdf-model.js';
import { extractMetadataFromUrl, createDatasetFromMetadata } from '../../services/rdf/rdf-extractor.js';
import { showNotification } from './notifications.js';

export function setupForms() {
  setupPostForm();
  setupEndpointForm();
}

function setupPostForm() {
  console.log('Setting up post form...');
  const form = document.getElementById('post-form');
  if (!form) {
    console.warn('Post form not found, it may be loaded dynamically');
    return;
  }

  console.log('Post form found, setting up extract button...');


  const extractButton = document.getElementById('extract-metadata');
  const urlInput = document.getElementById('url');

  if (extractButton && urlInput) {
    console.log('Extract button found, adding listener');
    extractButton.addEventListener('click', async () => {
      if (urlInput.value) {
        try {
          extractButton.disabled = true;
          extractButton.textContent = 'Extracting...';

          showNotification('Extracting metadata, please wait...', 'info');

          const metadata = await extractMetadataFromUrl(urlInput.value);


          if (metadata.title) {
            const titleInput = document.getElementById('title');
            if (titleInput && !titleInput.value) {
              titleInput.value = metadata.title;
            }
          }

          if (metadata.description) {
            const contentInput = document.getElementById('content');
            if (contentInput && !contentInput.value) {
              contentInput.value = metadata.description;
            }
          }

          if (metadata.tags && metadata.tags.length > 0) {
            const tagsInput = document.getElementById('tags');
            if (tagsInput && !tagsInput.value) {
              tagsInput.value = metadata.tags.join(', ');
            }
          }


          const previewElement = document.getElementById('post-preview');
          if (previewElement) {
            previewElement.innerHTML = `
              <h3>Link Preview</h3>
              <div class="link-preview">
                <div class="preview-card">
                  ${metadata.image ? `<div class="preview-image"><img src="${metadata.image}" alt="${metadata.title || 'Preview'}"></div>` : ''}
                  <div class="preview-content">
                    <h3 class="preview-title">${metadata.title || 'No title'}</h3>
                    <p class="preview-description">${metadata.description || ''}</p>
                    ${metadata.siteName ? `<span class="preview-site">${metadata.siteName}</span>` : ''}
                  </div>
                </div>
              </div>
            `;
          }

          showNotification('Metadata extracted successfully', 'success');

        } catch (error) {
          console.error('Error extracting metadata:', error);
          showNotification(`Failed to extract metadata: ${error.message}`, 'error');
        } finally {
          extractButton.disabled = false;
          extractButton.textContent = 'Extract';
        }
      } else {
        showNotification('Please enter a valid URL first', 'warning');
      }
    });
  } else {
    console.warn('Extract button or URL input not found!');
  }

  form.addEventListener('submit', async (e) => {
    e.preventDefault();

    try {
      state.update('postSubmitting', true);
      const formData = new FormData(form);


      const postData = {
        type: formData.get('post-type'),
        content: formData.get('content'),
        tags: formData.get('tags') ? formData.get('tags').split(',').map(tag => tag.trim()) : []
      };


      if (postData.type === 'link' && formData.get('url')) {
        postData.url = formData.get('url');
      }


      if (formData.get('title')) {
        postData.title = formData.get('title');
      }


      const postId = rdfModel.createPost(postData);


      try {
        await rdfModel.syncWithEndpoint();
      } catch (syncError) {
        console.warn('Post created locally but failed to sync with endpoint', syncError);
      }


      state.update('lastPost', {
        id: postId,
        ...postData,
        timestamp: new Date().toISOString()
      });

      state.update('lastPostStatus', 'success');


      form.reset();


      showNotification('Post created successfully', 'success');

    } catch (error) {
      ErrorHandler.handle(error);
      state.update('lastPostStatus', 'error');
      showNotification('Failed to create post: ' + error.message, 'error');
    } finally {
      state.update('postSubmitting', false);
    }
  });
}


const typeSelector = document.getElementById('post-type');
if (typeSelector) {
  typeSelector.addEventListener('change', (e) => {
    console.log('Post type changed to:', e.target.value);

    alert('Changing post type is not implemented in this demo. Please refresh the page.');
  });
}

function setupEndpointForm() {
  const form = document.getElementById('endpoint-form');
  if (!form) return;

  form.addEventListener('submit', async (e) => {
    e.preventDefault();

    try {
      const url = document.getElementById('endpoint-url').value;
      const label = document.getElementById('endpoint-label').value;
      const type = 'query';


      const { EndpointManager } = await import('../../services/sparql/endpoints.js');
      const endpointManager = new EndpointManager();

      endpointManager.addEndpoint(url, label, type);
      form.reset();

      showNotification('Endpoint added successfully', 'success');


      if (typeof updateEndpointsList === 'function') {
        updateEndpointsList();
      }
    } catch (error) {
      ErrorHandler.handle(error);
      showNotification('Failed to add endpoint: ' + error.message, 'error');
    }
  });
}

function addFormField(container, field) {
  const wrapper = document.createElement('div');
  wrapper.className = 'form-field';


  const label = document.createElement('label');
  label.setAttribute('for', field.name);
  label.textContent = field.label;
  wrapper.appendChild(label);


  let input;
  if (field.type === 'textarea') {
    input = document.createElement('textarea');
  } else {
    input = document.createElement('input');
    input.type = field.type;
  }

  input.name = field.name;
  input.id = field.name;

  if (field.placeholder) {
    input.placeholder = field.placeholder;
  }

  if (field.required) {
    input.required = true;
  }

  wrapper.appendChild(input);
  container.appendChild(wrapper);
}

================
File: src/ui/components/notifications.js
================
let notificationsContainer;




export function initializeNotifications() {
    console.log('Initializing notifications system');


    if (!notificationsContainer) {
        notificationsContainer = document.createElement('div');
        notificationsContainer.className = 'notifications-container';
        document.body.appendChild(notificationsContainer);


        if (!document.getElementById('notification-styles')) {
            const style = document.createElement('style');
            style.id = 'notification-styles';
            style.textContent = `
                .notifications-container {
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 1000;
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                    max-width: 300px;
                }

                .notification {
                    padding: 10px 15px;
                    border-radius: 4px;
                    color: white;
                    animation: notification-slide-in 0.3s ease-out;
                    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
                    position: relative;
                    overflow: hidden;
                }

                .notification::before {
                    content: '';
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    width: 100%;
                    height: 3px;
                    background: rgba(255, 255, 255, 0.5);
                    animation: notification-timer 5s linear forwards;
                }

                .notification.success {
                    background-color: var(--success-color, #48bb78);
                }

                .notification.error {
                    background-color: var(--error-color, #f56565);
                }

                .notification.info {
                    background-color: var(--primary-color, #4299e1);
                }

                .notification.warning {
                    background-color: #ed8936;
                }

                .notification.fade-out {
                    opacity: 0;
                    transform: translateX(100%);
                    transition: opacity 0.3s, transform 0.3s;
                }

                @keyframes notification-slide-in {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }

                @keyframes notification-timer {
                    from {
                        width: 100%;
                    }
                    to {
                        width: 0%;
                    }
                }
            `;
            document.head.appendChild(style);
        }
    }


    window.showNotification = showNotification;
}







export function showNotification(message, type = 'info', duration = 5000) {

    if (!notificationsContainer) {
        initializeNotifications();
    }


    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;


    notificationsContainer.appendChild(notification);


    setTimeout(() => {
        notification.classList.add('fade-out');
        setTimeout(() => notification.remove(), 300);
    }, duration);

    return notification;
}






export function showError(message, duration = 5000) {
    return showNotification(message, 'error', duration);
}






export function showSuccess(message, duration = 5000) {
    return showNotification(message, 'success', duration);
}






export function showInfo(message, duration = 5000) {
    return showNotification(message, 'info', duration);
}






export function showWarning(message, duration = 5000) {
    return showNotification(message, 'warning', duration);
}

================
File: src/ui/notifications/notifications.js
================
import { eventBus, EVENTS } from '../../core/events/event-bus.js';
import { store } from '../../core/state/index.js';
import { showNotification as showNotificationAction, hideNotification } from '../../core/state/actions.js';
import { getNotifications } from '../../core/state/selectors.js';

let notificationsContainer;




export function initNotifications() {
  console.log('Initializing notifications system');


  if (!notificationsContainer) {
    notificationsContainer = document.querySelector('.notifications-container');

    if (!notificationsContainer) {
      notificationsContainer = document.createElement('div');
      notificationsContainer.className = 'notifications-container';
      document.body.appendChild(notificationsContainer);
    }
  }


  store.subscribe(renderNotifications);


  eventBus.on(EVENTS.NOTIFICATION_SHOW, handleNotificationEvent);


  window.showNotification = showNotification;
}





function handleNotificationEvent(notification) {
  showNotification(
    notification.message,
    notification.type,
    notification.duration
  );
}







export function showNotification(message, type = 'info', duration = 5000) {
  const id = Date.now();


  store.dispatch(showNotificationAction({
    id,
    message,
    type,
    duration,
    timestamp: new Date().toISOString()
  }));


  if (duration > 0) {
    setTimeout(() => {
      store.dispatch(hideNotification(id));
    }, duration);
  }

  return id;
}





export function hideNotificationById(id) {
  store.dispatch(hideNotification(id));
}




function renderNotifications() {
  const notifications = getNotifications(store.getState());


  const existingElements = notificationsContainer.querySelectorAll('.notification');
  const existingIds = new Set();

  existingElements.forEach(element => {
    const id = parseInt(element.dataset.id, 10);
    existingIds.add(id);


    if (!notifications.find(n => n.id === id)) {
      element.classList.add('fade-out');
      setTimeout(() => element.remove(), 300);
    }
  });


  notifications.forEach(notification => {
    if (!existingIds.has(notification.id)) {
      createNotificationElement(notification);
    }
  });
}





function createNotificationElement(notification) {
  const element = document.createElement('div');
  element.className = `notification ${notification.type}`;
  element.dataset.id = notification.id;
  element.textContent = notification.message;


  if (notification.duration === 0) {
    const closeButton = document.createElement('button');
    closeButton.className = 'notification-close';
    closeButton.innerHTML = '&times;';
    closeButton.addEventListener('click', () => {
      hideNotificationById(notification.id);
    });
    element.appendChild(closeButton);
  }


  notificationsContainer.appendChild(element);

  return element;
}


export const showSuccess = (msg, duration) => showNotification(msg, 'success', duration);
export const showError = (msg, duration) => showNotification(msg, 'error', duration);
export const showInfo = (msg, duration) => showNotification(msg, 'info', duration);
export const showWarning = (msg, duration) => showNotification(msg, 'warning', duration);

================
File: src/ui/notifications/router.js
================
import { eventBus, EVENTS } from '../core/events/event-bus.js';
import { errorHandler } from '../core/errors/index.js';
import { store } from '../core/state/index.js';
import { setCurrentView } from '../core/state/actions.js';
import { getCurrentView } from '../core/state/selectors.js';


const VIEWS = {
    POST: 'post-view',
    WIKI: 'wiki-view',
    YASGUI: 'yasgui-view',
    DEVELOPER: 'developer-view',
    PROFILE: 'profile-view',
    SETTINGS: 'settings-view'
};


const ROUTE_MAP = {
    'post': VIEWS.POST,
    'wiki': VIEWS.WIKI,
    'sparql': VIEWS.YASGUI,
    'dev': VIEWS.DEVELOPER,
    'profile': VIEWS.PROFILE,
    'settings': VIEWS.SETTINGS
};


const VIEW_MODULES = {
    [VIEWS.POST]: () => import('./views/post-view.js'),
    [VIEWS.WIKI]: () => import('./views/wiki-view.js'),
    [VIEWS.YASGUI]: () => import('./views/yasgui-view.js'),
    [VIEWS.DEVELOPER]: () => import('./views/developer-view.js'),
    [VIEWS.PROFILE]: () => import('./views/profile-view.js'),
    [VIEWS.SETTINGS]: () => import('./views/settings-view.js')
};


const activeViewHandlers = {};




export function initRouter() {

    window.addEventListener('hashchange', handleRouteChange);


    handleRouteChange();


    setupNavLinks();
}




function handleRouteChange() {
    try {
        const hash = window.location.hash.slice(1) || 'post';
        const viewId = ROUTE_MAP[hash] || VIEWS.POST;

        const currentView = getCurrentView(store.getState());


        if (currentView === viewId) {
            return;
        }


        const event = new CustomEvent('routeChange', {
            detail: {
                from: currentView,
                to: viewId
            },
            cancelable: true
        });


        if (!document.dispatchEvent(event)) {

            if (currentView) {
                const route = Object.keys(ROUTE_MAP).find(key => ROUTE_MAP[key] === currentView);
                if (route) {
                    window.location.hash = route;
                }
            }
            return;
        }


        store.dispatch(setCurrentView(viewId));


        showView(viewId);


        initializeView(viewId);


        updateActiveNavLink(viewId);


        eventBus.emit(EVENTS.VIEW_CHANGED, {
            from: currentView,
            to: viewId
        });
    } catch (error) {
        errorHandler.handle(error, {
            showToUser: true,
            context: 'Route change'
        });


        if (window.location.hash !== '#post') {
            window.location.hash = 'post';
        }
    }
}




function showView(viewId) {
    Object.values(VIEWS).forEach(id => {
        const view = document.getElementById(id);
        if (view) {
            view.classList.toggle('hidden', id !== viewId);
        }
    });
}




async function initializeView(viewId) {
    try {

        if (activeViewHandlers[viewId]) {

            if (typeof activeViewHandlers[viewId].update === 'function') {
                activeViewHandlers[viewId].update();
            }
            return;
        }


        const moduleLoader = VIEW_MODULES[viewId];
        if (!moduleLoader) {
            console.warn(`No module defined for view ${viewId}`);
            return;
        }


        const module = await moduleLoader();


        if (typeof module.initView === 'function') {
            activeViewHandlers[viewId] = module.initView() || {};
        } else {
            console.warn(`No initView function in module for ${viewId}`);
            activeViewHandlers[viewId] = {};
        }
    } catch (error) {
        errorHandler.handle(error, {
            showToUser: true,
            context: `Initializing view ${viewId}`
        });
    }
}




function updateActiveNavLink(viewId) {
    document.querySelectorAll('nav a').forEach(link => {
        const linkViewId = link.getAttribute('data-view');
        link.classList.toggle('active', linkViewId === viewId);
    });
}




function setupNavLinks() {
    document.querySelectorAll('nav a').forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const viewId = e.target.getAttribute('data-view');
            if (viewId) {
                const route = Object.keys(ROUTE_MAP).find(key => ROUTE_MAP[key] === viewId);
                if (route) {
                    window.location.hash = route;
                }


                const menu = document.querySelector('.hamburger-menu');
                if (menu && menu.classList.contains('active')) {
                    menu.classList.remove('active');
                    document.querySelector('nav').classList.remove('visible');
                }
            }
        });
    });
}


export { VIEWS, ROUTE_MAP };

================
File: src/ui/views/settings-view.js
================
import { state } from '../../core/state.js';
import { setupEndpointsList } from '../components/endpoints-list.js';
import { showNotification, initializeNotifications } from '../components/notifications.js';
import { rdfModel } from '../../js/services/rdf/rdf-model.js';




export function initializeSettingsView() {
    const view = document.getElementById('settings-view');
    if (!view) {
        console.warn('Settings view not found');
        return;
    }


    setupEndpointsList();
    initializeNotifications();


    setupThemeSelector();


    setupStorageManagement();
}




function setupThemeSelector() {
    const themeSelector = document.getElementById('theme-selector');
    if (!themeSelector) return;


    const currentTheme = localStorage.getItem('squirt_theme') || 'light';


    themeSelector.value = currentTheme;


    document.documentElement.setAttribute('data-theme', currentTheme);


    themeSelector.addEventListener('change', () => {
        const theme = themeSelector.value;
        localStorage.setItem('squirt_theme', theme);
        document.documentElement.setAttribute('data-theme', theme);
        showNotification(`Theme changed to ${theme}`, 'info');
    });
}




function setupStorageManagement() {
    const storageSection = document.querySelector('.storage-section');
    if (!storageSection) return;


    if (!document.getElementById('export-data')) {
        const exportBtn = document.createElement('button');
        exportBtn.id = 'export-data';
        exportBtn.textContent = 'Export Data';
        exportBtn.addEventListener('click', exportData);
        storageSection.appendChild(exportBtn);
    }


    if (!document.getElementById('import-data')) {
        const importBtn = document.createElement('button');
        importBtn.id = 'import-data';
        importBtn.textContent = 'Import Data';
        importBtn.addEventListener('click', () => {

            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.ttl,.json';
            fileInput.style.display = 'none';
            document.body.appendChild(fileInput);


            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    importData(file);
                }
                document.body.removeChild(fileInput);
            });


            fileInput.click();
        });
        storageSection.appendChild(importBtn);
    }


    if (!document.getElementById('clear-data')) {
        const clearBtn = document.createElement('button');
        clearBtn.id = 'clear-data';
        clearBtn.className = 'danger';
        clearBtn.textContent = 'Clear All Data';
        clearBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                clearAllData();
            }
        });
        storageSection.appendChild(clearBtn);
    }


    updateStorageUsage();
}




async function exportData() {
    try {

        const dataset = state.get('rdfDataset');

        if (!dataset || dataset.size === 0) {
            showNotification('No data to export', 'warning');
            return;
        }


        const turtle = dataset.toString();


        const blob = new Blob([turtle], { type: 'text/turtle' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const date = new Date().toISOString().split('T')[0];
        a.href = url;
        a.download = `squirt_export_${date}.ttl`;
        a.style.display = 'none';


        document.body.appendChild(a);
        a.click();


        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);

        showNotification('Data exported successfully', 'success');
    } catch (error) {
        console.error('Error exporting data:', error);
        showNotification('Failed to export data', 'error');
    }
}





async function importData(file) {
    try {
        const reader = new FileReader();

        reader.onload = async (e) => {
            try {
                const content = e.target.result;


                try {
                    const dataset = await rdfModel.parseFromString(content);


                    const currentDataset = state.get('rdfDataset');
                    dataset.forEach(quad => {
                        currentDataset.add(quad);
                    });


                    state.update('rdfDataset', currentDataset);


                    rdfModel.saveToCache(currentDataset);

                    showNotification('Data imported successfully', 'success');
                } catch (parseError) {
                    console.error('Error parsing imported data:', parseError);
                    showNotification('Invalid data format', 'error');
                }
            } catch (processError) {
                console.error('Error processing imported data:', processError);
                showNotification('Failed to import data', 'error');
            }
        };

        reader.onerror = () => {
            showNotification('Failed to read file', 'error');
        };

        reader.readAsText(file);
    } catch (error) {
        console.error('Error importing data:', error);
        showNotification('Failed to import data', 'error');
    }
}




function clearAllData() {
    try {

        state.update('rdfDataset', rdfModel.createEmptyDataset());


        const themeSettings = localStorage.getItem('squirt_theme');
        const endpointSettings = localStorage.getItem('squirt_endpoints');

        localStorage.clear();


        if (themeSettings) {
            localStorage.setItem('squirt_theme', themeSettings);
        }

        if (endpointSettings) {
            localStorage.setItem('squirt_endpoints', endpointSettings);
        }

        showNotification('All data has been cleared', 'success');


        updateStorageUsage();
    } catch (error) {
        console.error('Error clearing data:', error);
        showNotification('Failed to clear data', 'error');
    }
}




function updateStorageUsage() {

    let usageElement = document.getElementById('storage-usage');
    if (!usageElement) {
        usageElement = document.createElement('div');
        usageElement.id = 'storage-usage';
        document.querySelector('.storage-section')?.appendChild(usageElement);
    }


    let total = 0;
    for (const key in localStorage) {
        if (localStorage.hasOwnProperty(key)) {
            total += localStorage[key].length * 2;
        }
    }


    let size;
    if (total < 1024) {
        size = `${total} bytes`;
    } else if (total < 1024 * 1024) {
        size = `${(total / 1024).toFixed(2)} KB`;
    } else {
        size = `${(total / (1024 * 1024)).toFixed(2)} MB`;
    }


    usageElement.textContent = `Storage used: ${size}`;
}

================
File: src/ui/views/wiki-view.js
================
import CodeMirror from 'codemirror';
import 'codemirror/lib/codemirror.css';
import 'codemirror/mode/markdown/markdown';
import 'codemirror/theme/monokai.css';
import 'codemirror/addon/edit/continuelist';
import 'codemirror/addon/display/placeholder';
import { marked } from 'marked';
import { rdfModel } from '../../services/rdf/rdf-model.js';
import { showNotification } from '../components/notifications.js';

let editor = null;
let preview = null;




export function initializeWikiEditor() {
  const wikiContent = document.getElementById('wiki-content');
  const previewContainer = document.querySelector('.wiki-preview');
  const saveButton = document.getElementById('save-wiki');

  if (!wikiContent) {
    console.warn('Wiki content element not found');
    return;
  }


  if (!previewContainer) {
    preview = document.createElement('div');
    preview.className = 'wiki-preview';
    preview.innerHTML = '<h3>Preview</h3><div class="preview-content"></div>';

    const wikiEditor = document.querySelector('.wiki-editor');
    if (wikiEditor) {
      wikiEditor.appendChild(preview);
    }
  } else {
    preview = previewContainer;
  }


  editor = CodeMirror.fromTextArea(wikiContent, {
    mode: 'markdown',
    theme: 'monokai',
    lineNumbers: true,
    lineWrapping: true,
    viewportMargin: Infinity,
    placeholder: 'Enter markdown content here...',
    extraKeys: {
      'Enter': 'newlineAndIndentContinueMarkdownList'
    }
  });


  editor.on('change', updatePreview);


  if (saveButton) {
    saveButton.addEventListener('click', saveWikiEntry);
  }


  addToolbar();


  updatePreview();
}




function updatePreview() {
  const content = editor.getValue();
  const previewContent = preview.querySelector('.preview-content');

  if (previewContent) {

    previewContent.innerHTML = marked(content);


    previewContent.querySelectorAll('pre code').forEach(block => {
      if (window.hljs) {
        window.hljs.highlightBlock(block);
      }
    });
  }
}




function addToolbar() {
  const toolbar = document.createElement('div');
  toolbar.className = 'editor-toolbar';


  const buttons = [
    { icon: 'format_bold', title: 'Bold', action: () => wrapText('**', '**') },
    { icon: 'format_italic', title: 'Italic', action: () => wrapText('*', '*') },
    { icon: 'format_quote', title: 'Quote', action: () => prependLine('> ') },
    { icon: 'format_list_bulleted', title: 'Bullet List', action: () => prependLine('- ') },
    { icon: 'format_list_numbered', title: 'Numbered List', action: () => prependLine('1. ') },
    { icon: 'insert_link', title: 'Link', action: insertLink },
    { icon: 'insert_photo', title: 'Image', action: insertImage },
    { icon: 'code', title: 'Code', action: () => wrapText('`', '`') },
    { icon: 'view_headline', title: 'Heading', action: () => prependLine('## ') }
  ];


  if (!document.querySelector('link[href*="material-icons"]')) {
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = 'https://fonts.googleapis.com/icon?family=Material+Icons';
    document.head.appendChild(link);
  }


  buttons.forEach(button => {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'toolbar-button';
    btn.title = button.title;
    btn.innerHTML = `<i class="material-icons">${button.icon}</i>`;
    btn.addEventListener('click', button.action);
    toolbar.appendChild(btn);
  });


  const editorContainer = editor.getWrapperElement().parentNode;
  editorContainer.insertBefore(toolbar, editor.getWrapperElement());


  if (!document.getElementById('editor-toolbar-styles')) {
    const style = document.createElement('style');
    style.id = 'editor-toolbar-styles';
    style.textContent = `
      .editor-toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        margin-bottom: 10px;
        padding: 5px;
        background: #f5f5f5;
        border-radius: 4px;
      }

      .toolbar-button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 36px;
        height: 36px;
        padding: 0;
        border: none;
        background: transparent;
        border-radius: 4px;
        cursor: pointer;
      }

      .toolbar-button:hover {
        background: #e0e0e0;
      }

      .toolbar-button i {
        font-size: 20px;
        color: #555;
      }

      .wiki-preview {
        margin-top: 20px;
        padding: 20px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
      }

      .preview-content {
        font-family: system-ui, -apple-system, sans-serif;
        line-height: 1.6;
      }

      .preview-content h1,
      .preview-content h2,
      .preview-content h3 {
        margin-top: 1.5em;
        margin-bottom: 0.5em;
      }

      .preview-content p {
        margin-bottom: 1em;
      }

      .preview-content ul,
      .preview-content ol {
        padding-left: 2em;
        margin-bottom: 1em;
      }

      .preview-content blockquote {
        border-left: 3px solid #ddd;
        margin-left: 0;
        padding-left: 1em;
        color: #777;
      }

      .preview-content code {
        font-family: monospace;
        background: #f0f0f0;
        padding: 2px 4px;
        border-radius: 3px;
      }

      .preview-content pre {
        background: #f0f0f0;
        padding: 1em;
        border-radius: 4px;
        overflow-x: auto;
      }

      .preview-content img {
        max-width: 100%;
      }
    `;
    document.head.appendChild(style);
  }
}




function wrapText(prefix, suffix) {
  const selection = editor.getSelection();
  if (selection) {
    editor.replaceSelection(prefix + selection + suffix);
  } else {
    const cursor = editor.getCursor();
    editor.replaceRange(prefix + suffix, cursor);
    editor.setCursor({
      line: cursor.line,
      ch: cursor.ch + prefix.length
    });
  }
  editor.focus();
}




function prependLine(text) {
  const selection = editor.getSelection();
  const cursor = editor.getCursor();

  if (selection) {
    const lines = selection.split('\n');
    const newText = lines.map(line => text + line).join('\n');
    editor.replaceSelection(newText);
  } else {
    const line = editor.getLine(cursor.line);
    editor.replaceRange(text + line, { line: cursor.line, ch: 0 }, { line: cursor.line, ch: line.length });
    editor.setCursor({ line: cursor.line, ch: text.length + cursor.ch });
  }
  editor.focus();
}




function insertLink() {
  const selection = editor.getSelection();
  const url = prompt('Enter URL:', 'https://');

  if (url) {
    if (selection) {
      editor.replaceSelection(`[${selection}](${url})`);
    } else {
      const text = prompt('Enter link text:', 'Link text');
      if (text) {
        editor.replaceSelection(`[${text}](${url})`);
      }
    }
  }
  editor.focus();
}




function insertImage() {
  const url = prompt('Enter image URL:', 'https://');

  if (url) {
    const alt = prompt('Enter image description:', 'Image');
    if (alt) {
      editor.replaceSelection(`![${alt}](${url})`);
    }
  }
  editor.focus();
}




function saveWikiEntry() {
  const titleInput = document.getElementById('wiki-title');
  const tagsInput = document.getElementById('wiki-tags');

  if (!titleInput || !titleInput.value.trim()) {
    showNotification('Please enter a title for your wiki entry', 'error');
    return;
  }

  const content = editor.getValue();
  if (!content.trim()) {
    showNotification('Please enter some content for your wiki entry', 'error');
    return;
  }

  const tags = tagsInput && tagsInput.value
    ? tagsInput.value.split(',').map(tag => tag.trim())
    : [];

  try {

    const postId = rdfModel.createPost({
      type: 'wiki',
      title: titleInput.value.trim(),
      content: content,
      tags: tags
    });


    rdfModel.syncWithEndpoint()
      .catch(error => {
        console.warn('Wiki entry saved locally but failed to sync with endpoint', error);
      });


    titleInput.value = '';
    editor.setValue('');
    if (tagsInput) tagsInput.value = '';

    showNotification('Wiki entry saved successfully', 'success');


    loadWikiEntries();
  } catch (error) {
    console.error('Error saving wiki entry:', error);
    showNotification('Failed to save wiki entry: ' + error.message, 'error');
  }
}




function loadWikiEntries() {
  const entriesList = document.querySelector('.wiki-entries');
  if (!entriesList) return;


  entriesList.innerHTML = '<h3>Recent Entries</h3>';

  try {

    const entries = rdfModel.getPosts({
      type: 'wiki',
      limit: 10
    });

    if (entries.length === 0) {
      entriesList.innerHTML += '<p>No wiki entries found.</p>';
      return;
    }


    const list = document.createElement('ul');
    list.className = 'entries-list';

    entries.forEach(entry => {
      const item = document.createElement('li');
      item.className = 'entry-item';

      item.innerHTML = `
        <h4 class="entry-title">${entry.title || 'Untitled'}</h4>
        <p class="entry-preview">${entry.content.substring(0, 100)}${entry.content.length > 100 ? '...' : ''}</p>
        <div class="entry-meta">
          <span class="entry-date">${new Date(entry.created).toLocaleString()}</span>
          ${entry.tags.length > 0 ? `<span class="entry-tags">${entry.tags.join(', ')}</span>` : ''}
        </div>
        <button class="view-entry" data-id="${entry.id}">View</button>
        <button class="edit-entry" data-id="${entry.id}">Edit</button>
      `;


      item.querySelector('.view-entry').addEventListener('click', () => viewEntry(entry.id));
      item.querySelector('.edit-entry').addEventListener('click', () => editEntry(entry.id));

      list.appendChild(item);
    });

    entriesList.appendChild(list);


    if (!document.getElementById('entries-list-styles')) {
      const style = document.createElement('style');
      style.id = 'entries-list-styles';
      style.textContent = `
        .entries-list {
          list-style: none;
          padding: 0;
          margin: 0;
        }

        .entry-item {
          padding: 15px;
          margin-bottom: 15px;
          border: 1px solid #eee;
          border-radius: 4px;
          background: white;
        }

        .entry-title {
          margin: 0 0 10px 0;
          color: var(--primary-color, #3498db);
        }

        .entry-preview {
          margin: 0 0 10px 0;
          color: #666;
        }

        .entry-meta {
          display: flex;
          flex-wrap: wrap;
          gap: 10px;
          margin-bottom: 10px;
          font-size: 0.875rem;
          color: #999;
        }

        .entry-item button {
          padding: 5px 10px;
          margin-right: 5px;
          background: var(--primary-color, #3498db);
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        }

        .entry-item button:hover {
          opacity: 0.9;
        }
      `;
      document.head.appendChild(style);
    }
  } catch (error) {
    console.error('Error loading wiki entries:', error);
    entriesList.innerHTML += `<p class="error">Error loading entries: ${error.message}</p>`;
  }
}




function viewEntry(id) {
  try {

    const entriesContainer = document.querySelector('.wiki-entries');
    if (!entriesContainer) return;


    const posts = rdfModel.getPosts();
    const post = posts.find(p => p.id === id);

    if (!post) {
      showNotification('Entry not found', 'error');
      return;
    }


    const entryView = document.createElement('div');
    entryView.className = 'entry-detail';

    entryView.innerHTML = `
      <div class="entry-toolbar">
        <button class="back-button">Back to list</button>
        <button class="edit-entry" data-id="${post.id}">Edit</button>
      </div>
      <h3 class="entry-title">${post.title || 'Untitled'}</h3>
      <div class="entry-meta">
        <span class="entry-date">${new Date(post.created).toLocaleString()}</span>
        ${post.tags.length > 0 ? `<span class="entry-tags">Tags: ${post.tags.join(', ')}</span>` : ''}
      </div>
      <div class="entry-content">${marked(post.content)}</div>
    `;


    entriesContainer.innerHTML = '';
    entriesContainer.appendChild(entryView);

    // Add back button handler
    entryView.querySelector('.back-button').addEventListener('click', loadWikiEntries);


    entryView.querySelector('.edit-entry').addEventListener('click', () => editEntry(post.id));


    entryView.querySelectorAll('pre code').forEach(block => {
      if (window.hljs) {
        window.hljs.highlightBlock(block);
      }
    });


    if (!document.getElementById('entry-detail-styles')) {
      const style = document.createElement('style');
      style.id = 'entry-detail-styles';
      style.textContent = `
        .entry-detail {
          padding: 20px;
          background: white;
          border-radius: 4px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .entry-toolbar {
          display: flex;
          gap: 10px;
          margin-bottom: 20px;
        }

        .entry-toolbar button {
          padding: 5px 10px;
          background: var(--primary-color, #3498db);
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
        }

        .entry-detail .entry-title {
          margin: 0 0 10px 0;
          font-size: 2rem;
          color: var(--text-color, #2c3e50);
        }

        .entry-detail .entry-meta {
          display: flex;
          flex-wrap: wrap;
          gap: 15px;
          margin-bottom: 20px;
          color: #777;
        }

        .entry-detail .entry-content {
          line-height: 1.6;
          font-size: 1.1rem;
        }

        .entry-detail .entry-content h1,
        .entry-detail .entry-content h2,
        .entry-detail .entry-content h3 {
          margin-top: 1.5em;
          margin-bottom: 0.5em;
        }

        .entry-detail .entry-content p {
          margin-bottom: 1em;
        }

        .entry-detail .entry-content img {
          max-width: 100%;
        }

        .entry-detail .entry-content blockquote {
          border-left: 3px solid #ddd;
          margin-left: 0;
          padding-left: 1em;
          color: #777;
        }
      `;
      document.head.appendChild(style);
    }
  } catch (error) {
    console.error('Error viewing wiki entry:', error);
    showNotification('Error viewing entry: ' + error.message, 'error');
  }
}




function editEntry(id) {
  try {

    const posts = rdfModel.getPosts();
    const post = posts.find(p => p.id === id);

    if (!post) {
      showNotification('Entry not found', 'error');
      return;
    }


    const titleInput = document.getElementById('wiki-title');
    const tagsInput = document.getElementById('wiki-tags');

    if (!titleInput) {
      showNotification('Editor not found', 'error');
      return;
    }


    titleInput.value = post.title || '';
    if (tagsInput) {
      tagsInput.value = post.tags.join(', ');
    }

    // Set editor content
    editor.setValue(post.content || '');

    // Scroll to editor
    document.querySelector('.wiki-editor').scrollIntoView({
      behavior: 'smooth',
      block: 'start'
    });


    const saveButton = document.getElementById('save-wiki');
    if (saveButton) {

      const newSaveButton = saveButton.cloneNode(true);
      saveButton.parentNode.replaceChild(newSaveButton, saveButton);


      newSaveButton.addEventListener('click', () => updateWikiEntry(id));
    }

    showNotification('Editing entry: ' + post.title, 'info');
  } catch (error) {
    console.error('Error editing wiki entry:', error);
    showNotification('Error editing entry: ' + error.message, 'error');
  }
}




function updateWikiEntry(id) {
  const titleInput = document.getElementById('wiki-title');
  const tagsInput = document.getElementById('wiki-tags');

  if (!titleInput || !titleInput.value.trim()) {
    showNotification('Please enter a title for your wiki entry', 'error');
    return;
  }

  const content = editor.getValue();
  if (!content.trim()) {
    showNotification('Please enter some content for your wiki entry', 'error');
    return;
  }

  const tags = tagsInput && tagsInput.value
    ? tagsInput.value.split(',').map(tag => tag.trim())
    : [];

  try {

    rdfModel.deletePost(id);


    const postData = {
      type: 'wiki',
      title: titleInput.value.trim(),
      content: content,
      tags: tags
    };


    postData.customId = id;


    rdfModel.createPost(postData);


    rdfModel.syncWithEndpoint()
      .catch(error => {
        console.warn('Wiki entry updated locally but failed to sync with endpoint', error);
      });


    titleInput.value = '';
    editor.setValue('');
    if (tagsInput) tagsInput.value = '';

    // Reset save button to handle new entries
    const saveButton = document.getElementById('save-wiki');
    if (saveButton) {

      const newSaveButton = saveButton.cloneNode(true);
      saveButton.parentNode.replaceChild(newSaveButton, saveButton);


      newSaveButton.addEventListener('click', saveWikiEntry);
    }

    showNotification('Wiki entry updated successfully', 'success');


    loadWikiEntries();
  } catch (error) {
    console.error('Error updating wiki entry:', error);
    showNotification('Failed to update wiki entry: ' + error.message, 'error');
  }
}


document.addEventListener('routeChange', (e) => {
  if (e.detail.to === 'wiki-view') {
    setTimeout(() => {
      initializeWikiEditor();
      loadWikiEntries();
    }, 100);
  }
});

================
File: src/ui/views/yasgui-view.js
================
import { YasguiPlugin } from '../../plugins/yasgui-plugin.js';
import { pluginManager } from '../../core/plugin-manager.js';
import { showNotification } from '../notifications/notifications.js';
import { errorHandler } from '../../core/errors/index.js';
import { VIEWS } from '../../core/views.js';

const PLUGIN_ID = 'yasgui-plugin';





export function initView() {
    try {
        console.log('Initializing YASGUI view');


        let plugin = pluginManager.getPlugin(PLUGIN_ID);

        if (!plugin) {

            console.log('Creating new YASGUI plugin instance');
            plugin = new YasguiPlugin(PLUGIN_ID);


            pluginManager.register(VIEWS.YASGUI, plugin, {
                autoActivate: true
            });
        }


        const container = document.getElementById('yasgui-container');
        if (!container) {
            throw new Error('YASGUI container element not found');
        }


        pluginManager.createContainer(VIEWS.YASGUI, PLUGIN_ID, 'yasgui-container');




        return {

            update() {
                console.log('Updating YASGUI view');
            },


            cleanup() {
                console.log('Cleaning up YASGUI view');
            }
        };
    } catch (error) {
        errorHandler.handle(error, {
            showToUser: true,
            context: 'Initializing YASGUI view'
        });


        const container = document.getElementById('yasgui-container');
        if (container) {
            container.innerHTML = `
        <div class="error-message">
          <p>Failed to initialize SPARQL editor: ${error.message}</p>
          <button onclick="window.location.reload()">Reload Page</button>
        </div>
      `;
        }

        return {};
    }
}

================
File: src/ui/router.js
================
import { eventBus, EVENTS } from '../core/events/event-bus.js';
import { errorHandler } from '../core/errors/index.js';
import { store } from '../core/state/index.js';
import { setCurrentView } from '../core/state/actions.js';
import { getCurrentView } from '../core/state/selectors.js';


const VIEWS = {
    POST: 'post-view',
    WIKI: 'wiki-view',
    YASGUI: 'yasgui-view',
    DEVELOPER: 'developer-view',
    PROFILE: 'profile-view',
    SETTINGS: 'settings-view'
};


const ROUTE_MAP = {
    'post': VIEWS.POST,
    'wiki': VIEWS.WIKI,
    'sparql': VIEWS.YASGUI,
    'dev': VIEWS.DEVELOPER,
    'profile': VIEWS.PROFILE,
    'settings': VIEWS.SETTINGS
};


const VIEW_MODULES = {
    [VIEWS.POST]: () => import('./views/post-view.js'),
    [VIEWS.WIKI]: () => import('./views/wiki-view.js'),
    [VIEWS.YASGUI]: () => import('./views/yasgui-view.js'),
    [VIEWS.DEVELOPER]: () => import('./views/developer-view.js'),
    [VIEWS.PROFILE]: () => import('./views/profile-view.js'),
    [VIEWS.SETTINGS]: () => import('./views/settings-view.js')
};


const activeViewHandlers = {};




export function initRouter() {

    window.addEventListener('hashchange', handleRouteChange);


    handleRouteChange();


    setupNavLinks();
}




function handleRouteChange() {
    try {
        const hash = window.location.hash.slice(1) || 'post';
        const viewId = ROUTE_MAP[hash] || VIEWS.POST;

        const currentView = getCurrentView(store.getState());


        if (currentView === viewId) {
            return;
        }


        const event = new CustomEvent('routeChange', {
            detail: {
                from: currentView,
                to: viewId
            },
            cancelable: true
        });


        if (!document.dispatchEvent(event)) {

            if (currentView) {
                const route = Object.keys(ROUTE_MAP).find(key => ROUTE_MAP[key] === currentView);
                if (route) {
                    window.location.hash = route;
                }
            }
            return;
        }


        store.dispatch(setCurrentView(viewId));


        showView(viewId);


        initializeView(viewId);


        updateActiveNavLink(viewId);


        eventBus.emit(EVENTS.VIEW_CHANGED, {
            from: currentView,
            to: viewId
        });
    } catch (error) {
        errorHandler.handle(error, {
            showToUser: true,
            context: 'Route change'
        });


        if (window.location.hash !== '#post') {
            window.location.hash = 'post';
        }
    }
}




function showView(viewId) {
    Object.values(VIEWS).forEach(id => {
        const view = document.getElementById(id);
        if (view) {
            view.classList.toggle('hidden', id !== viewId);
        }
    });
}




async function initializeView(viewId) {
    try {

        if (activeViewHandlers[viewId]) {

            if (typeof activeViewHandlers[viewId].update === 'function') {
                activeViewHandlers[viewId].update();
            }
            return;
        }


        const moduleLoader = VIEW_MODULES[viewId];
        if (!moduleLoader) {
            console.warn(`No module defined for view ${viewId}`);
            return;
        }


        const module = await moduleLoader();


        if (typeof module.initView === 'function') {
            activeViewHandlers[viewId] = module.initView() || {};
        } else {
            console.warn(`No initView function in module for ${viewId}`);
            activeViewHandlers[viewId] = {};
        }
    } catch (error) {
        errorHandler.handle(error, {
            showToUser: true,
            context: `Initializing view ${viewId}`
        });
    }
}




function updateActiveNavLink(viewId) {
    document.querySelectorAll('nav a').forEach(link => {
        const linkViewId = link.getAttribute('data-view');
        link.classList.toggle('active', linkViewId === viewId);
    });
}




function setupNavLinks() {
    document.querySelectorAll('nav a').forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const viewId = e.target.getAttribute('data-view');
            if (viewId) {
                const route = Object.keys(ROUTE_MAP).find(key => ROUTE_MAP[key] === viewId);
                if (route) {
                    window.location.hash = route;
                }


                const menu = document.querySelector('.hamburger-menu');
                if (menu && menu.classList.contains('active')) {
                    menu.classList.remove('active');
                    document.querySelector('nav').classList.remove('visible');
                }
            }
        });
    });
}


export { VIEWS, ROUTE_MAP };

================
File: src/utils/namespaces.js
================
export const namespaces = {
  rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
  rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
  dc: 'http://purl.org/dc/terms/',
  foaf: 'http://xmlns.com/foaf/0.1/',
  squirt: 'http://purl.org/stuff/squirt/'
};






export function generateNid(content) {
  const date = new Date().toISOString().split('T')[0];
  const hash = hashContent(content);
  return `http://purl.org/stuff/squirt/nid_${date}_${hash}`;
}






function hashContent(content) {
  return Array.from(content)
    .reduce((hash, char) => {
      return ((hash << 5) - hash) + char.charCodeAt(0) | 0;
    }, 0)
    .toString(16)
    .slice(0, 4);
}

================
File: src/utils/utils.js
================
export const namespaces = {
  rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
  rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
  dc: 'http://purl.org/dc/terms/',
  foaf: 'http://xmlns.com/foaf/0.1/',
  squirt: 'http://purl.org/stuff/squirt/'
};

export function generateNid(content) {
  const date = new Date().toISOString().split('T')[0];
  const hash = hashContent(content);
  return `http://purl.org/stuff/squirt/nid_${date}_${hash}`;
}

function hashContent(content) {
  return Array.from(content)
    .reduce((hash, char) => {
      return ((hash << 5) - hash) + char.charCodeAt(0) | 0;
    }, 0)
    .toString(16)
    .slice(0, 4);
}

================
File: src/app.js
================
import { eventBus, EVENTS } from './core/events/event-bus.js';
import { errorHandler } from './core/errors/index.js';
import { store } from './core/state/index.js';
import { storageService } from './services/storage/storage-service.js';
import { initRouter } from './ui/router.js';
import { initNotifications } from './ui/notifications/notifications.js';
import { pluginManager } from './core/plugin-manager.js';


import './css/styles.css';
import './css/form-styles.css';
import './css/yasgui-styles.css';
import './css/layout-fixes.css';
import './css/mobile-fixes.css';
import './css/plugin-styles.css';


export const namespaces = {
  rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
  rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
  dc: 'http://purl.org/dc/terms/',
  foaf: 'http://xmlns.com/foaf/0.1/',
  squirt: 'http://purl.org/stuff/squirt/'
};


export const services = {
  storage: storageService
};




export async function initializeApp() {
  try {
    console.log('Initializing application...');


    window.services = services;


    initNotifications();
    initRouter();


    await pluginManager.initializeAll();


    setupNotifications();


    setupHamburgerMenu();

    console.log('Application initialized successfully');
    eventBus.emit(EVENTS.APP_INITIALIZED);

    return { success: true };
  } catch (error) {
    errorHandler.handle(error);
    return { success: false, error };
  }
}




function setupNotifications() {

  let container = document.querySelector('.notifications-container');
  if (!container) {
    container = document.createElement('div');
    container.className = 'notifications-container';
    document.body.appendChild(container);
  }


  window.showNotification = (message, type = 'info', duration = 5000) => {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;

    container.appendChild(notification);

    if (duration > 0) {
      setTimeout(() => {
        notification.classList.add('fade-out');
        setTimeout(() => notification.remove(), 300);
      }, duration);
    }

    return notification;
  };


  eventBus.on(EVENTS.NOTIFICATION_SHOW, (data) => {
    window.showNotification(data.message, data.type, data.duration);
  });
}




function setupHamburgerMenu() {
  const hamburgerButton = document.querySelector('.hamburger-button');
  const nav = document.querySelector('nav');

  if (hamburgerButton && nav) {
    hamburgerButton.addEventListener('click', () => {
      nav.classList.toggle('visible');
    });
  }
}


document.addEventListener('DOMContentLoaded', () => {
  initializeApp();
});

================
File: src/config.json
================
[
    {
        "name": "local query",
        "type": "query",
        "url": "http://localhost:4030/semem/query",
        "credentials": {
            "user": "admin",
            "password": "admin123"
        }
    },
    {
        "name": "local update",
        "type": "update",
        "url": "http://localhost:4030/semem/update",
        "credentials": {
            "user": "admin",
            "password": "admin123"
        }
    }
]

================
File: test/spec/about.md
================
npm test -- tests/unit/RunCommand.spec.js

================
File: test/spec/enpoints.spec.js
================
import { EndpointManager } from '../../src/js/services/sparql/endpoints.js';
import { state } from '../../src/js/core/state.js';
import { testEndpoint } from '../../src/js/services/sparql/sparql.js';


jest.mock('../../src/js/services/sparql/sparql.js', () => ({
  testEndpoint: jest.fn()
}));

jest.mock('../../src/js/core/state.js', () => ({
  state: {
    update: jest.fn(),
    get: jest.fn()
  }
}));


global.localStorage = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn()
};

describe('EndpointManager', () => {
  let endpointManager;

  beforeEach(() => {
    jest.clearAllMocks();
    endpointManager = new EndpointManager();


    jest.mock('../../../config.json', () => [
      {
        name: 'Test Endpoint',
        type: 'query',
        url: 'http://test-endpoint:3030/sparql'
      }
    ], { virtual: true });
  });

  describe('initialize', () => {
    it('should load endpoints from config and storage', async () => {

      const storedEndpoints = [
        {
          url: 'http://stored-endpoint:3030/sparql',
          label: 'Stored Endpoint',
          type: 'query',
          status: 'unknown'
        }
      ];

      localStorage.getItem.mockReturnValue(JSON.stringify(storedEndpoints));
      state.update.mockClear();


      const result = await endpointManager.initialize();


      expect(localStorage.getItem).toHaveBeenCalledWith(endpointManager.STORAGE_KEY);
      expect(state.update).toHaveBeenCalledWith('endpoints', expect.any(Array));
      expect(result.length).toBeGreaterThan(0);


      const hasStoredEndpoint = result.some(e => e.url === 'http://stored-endpoint:3030/sparql');
      expect(hasStoredEndpoint).toBe(true);
    });

    it('should use default endpoints if none are found', async () => {

      localStorage.getItem.mockReturnValue(null);
      jest.spyOn(endpointManager, 'loadFromConfig').mockReturnValue([]);


      const result = await endpointManager.initialize();


      expect(result.length).toBeGreaterThan(0);
      expect(state.update).toHaveBeenCalledWith('endpoints', expect.any(Array));
    });
  });

  describe('addEndpoint', () => {
    it('should add a new endpoint and check its status', async () => {

      state.get.mockReturnValue([]);
      testEndpoint.mockResolvedValue(true);
      jest.spyOn(endpointManager, 'saveToStorage').mockImplementation(() => {});


      endpointManager.addEndpoint(
        'http://new-endpoint:3030/sparql',
        'New Endpoint',
        'query'
      );


      expect(state.update).toHaveBeenCalledWith('endpoints', [
        expect.objectContaining({
          url: 'http://new-endpoint:3030/sparql',
          label: 'New Endpoint',
          type: 'query'
        })
      ]);
      expect(endpointManager.saveToStorage).toHaveBeenCalled();


      await new Promise(resolve => setTimeout(resolve, 10));
      expect(testEndpoint).toHaveBeenCalledWith(
        'http://new-endpoint:3030/sparql',
        null
      );
    });

    it('should throw error if endpoint with same URL already exists', () => {

      state.get.mockReturnValue([
        {
          url: 'http://existing-endpoint:3030/sparql',
          label: 'Existing Endpoint',
          type: 'query'
        }
      ]);


      expect(() => {
        endpointManager.addEndpoint(
          'http://existing-endpoint:3030/sparql',
          'New Label',
          'query'
        );
      }).toThrow();
    });
  });

  describe('removeEndpoint', () => {
    it('should remove an endpoint by URL', () => {

      const endpoints = [
        {
          url: 'http://endpoint1:3030/sparql',
          label: 'Endpoint 1',
          type: 'query'
        },
        {
          url: 'http://endpoint2:3030/sparql',
          label: 'Endpoint 2',
          type: 'update'
        }
      ];

      state.get.mockReturnValue(endpoints);
      jest.spyOn(endpointManager, 'saveToStorage').mockImplementation(() => {});


      endpointManager.removeEndpoint('http://endpoint1:3030/sparql');


      expect(state.update).toHaveBeenCalledWith(
        'endpoints',
        expect.arrayContaining([
          expect.objectContaining({
            url: 'http://endpoint2:3030/sparql'
          })
        ])
      );
      expect(state.update.mock.calls[0][1].length).toBe(1);
      expect(endpointManager.saveToStorage).toHaveBeenCalled();
    });
  });

  describe('updateEndpoint', () => {
    it('should update an existing endpoint', () => {

      const endpoints = [
        {
          url: 'http://endpoint1:3030/sparql',
          label: 'Endpoint 1',
          type: 'query',
          status: 'unknown'
        }
      ];

      state.get.mockReturnValue(endpoints);
      jest.spyOn(endpointManager, 'saveToStorage').mockImplementation(() => {});


      endpointManager.updateEndpoint('http://endpoint1:3030/sparql', {
        label: 'Updated Label',
        status: 'active'
      });


      expect(state.update).toHaveBeenCalledWith(
        'endpoints',
        [
          expect.objectContaining({
            url: 'http://endpoint1:3030/sparql',
            label: 'Updated Label',
            type: 'query',
            status: 'active'
          })
        ]
      );
      expect(endpointManager.saveToStorage).toHaveBeenCalled();
    });
  });

  describe('getActiveEndpoint', () => {
    it('should return active endpoint of specified type', () => {

      const endpoints = [
        {
          url: 'http://query-endpoint:3030/sparql',
          label: 'Query Endpoint',
          type: 'query',
          status: 'active'
        },
        {
          url: 'http://update-endpoint:3030/sparql',
          label: 'Update Endpoint',
          type: 'update',
          status: 'active'
        },
        {
          url: 'http://inactive-endpoint:3030/sparql',
          label: 'Inactive Endpoint',
          type: 'query',
          status: 'inactive'
        }
      ];

      state.get.mockReturnValue(endpoints);


      const result = endpointManager.getActiveEndpoint('update');


      expect(result).toEqual(expect.objectContaining({
        url: 'http://update-endpoint:3030/sparql',
        type: 'update',
        status: 'active'
      }));
    });

    it('should return undefined if no active endpoint of the specified type exists', () => {

      const endpoints = [
        {
          url: 'http://query-endpoint:3030/sparql',
          label: 'Query Endpoint',
          type: 'query',
          status: 'inactive'
        }
      ];

      state.get.mockReturnValue(endpoints);


      const result = endpointManager.getActiveEndpoint('query');


      expect(result).toBeUndefined();
    });
  });
});

================
File: test/spec/integration-test.js
================
import { services, initializeApp } from '../../src/app.js';
import { store } from '../../src/core/state/index.js';
import { eventBus, EVENTS } from '../../src/core/events/event-bus.js';


jest.mock('../../src/core/state/index.js', () => ({
  store: {
    getState: jest.fn(),
    dispatch: jest.fn(),
    subscribe: jest.fn()
  },
  createStore: jest.fn()
}));

jest.mock('../../src/services/storage/storage-service.js', () => ({
  createStorageService: jest.fn().mockReturnValue({
    getItem: jest.fn(),
    setItem: jest.fn()
  }),
  storageService: {
    getItem: jest.fn(),
    setItem: jest.fn()
  }
}));


global.fetch = jest.fn().mockResolvedValue({
  ok: true,
  json: jest.fn().mockResolvedValue({
    endpoints: [
      {
        name: 'Test Query',
        type: 'query',
        url: 'http://test-endpoint/query',
        credentials: null
      }
    ]
  })
});


document.body.innerHTML = `
  <header>
    <nav>
      <a href="#" data-view="post-view">Post</a>
      <a href="#" data-view="settings-view">Settings</a>
    </nav>
  </header>
  <main>
    <div id="post-view" class="view"></div>
    <div id="settings-view" class="view hidden"></div>
  </main>
  <div class="notifications-container"></div>
`;

describe('Application Integration', () => {
  beforeEach(() => {
    jest.clearAllMocks();


    for (const key in EVENTS) {
      eventBus.removeAllListeners(EVENTS[key]);
    }


    delete window.location;
    window.location = {
      hash: '#post',
      assign: jest.fn()
    };
  });

  it('should initialize the application successfully', async () => {

    const initHandler = jest.fn();
    eventBus.on(EVENTS.APP_INITIALIZED, initHandler);


    const result = await initializeApp();


    expect(result.success).toBe(true);


    expect(initHandler).toHaveBeenCalled();


    expect(services.storage).toBeDefined();
  });

  it('should create and use RDF service for post management', async () => {

    await initializeApp();


    services.rdf = {
      createPost: jest.fn().mockReturnValue('post-123'),
      getPosts: jest.fn().mockReturnValue([
        { id: 'post-123', title: 'Test Post', content: 'Test content' }
      ])
    };


    const postId = services.rdf.createPost({
      type: 'link',
      title: 'Test Post',
      content: 'Test content',
      url: 'https://example.com'
    });


    expect(postId).toBe('post-123');
    expect(services.rdf.createPost).toHaveBeenCalledWith({
      type: 'link',
      title: 'Test Post',
      content: 'Test content',
      url: 'https://example.com'
    });


    const posts = services.rdf.getPosts();


    expect(posts).toHaveLength(1);
    expect(posts[0].title).toBe('Test Post');
  });

  it('should handle endpoint status changes', async () => {

    await initializeApp();


    services.endpoints = {
      checkEndpointsHealth: jest.fn().mockResolvedValue({
        success: true,
        anyActive: true,
        results: [
          {
            url: 'http://test-endpoint/query',
            isActive: true,
            type: 'query'
          }
        ]
      }),
      getActiveEndpoint: jest.fn().mockReturnValue({
        url: 'http://test-endpoint/query',
        type: 'query',
        status: 'active'
      })
    };


    const statusHandler = jest.fn();
    eventBus.on(EVENTS.ENDPOINTS_STATUS_CHECKED, statusHandler);


    const result = await services.endpoints.checkEndpointsHealth();


    expect(result.success).toBe(true);
    expect(result.anyActive).toBe(true);


    const endpoint = services.endpoints.getActiveEndpoint('query');


    expect(endpoint).toBeDefined();
    expect(endpoint.url).toBe('http://test-endpoint/query');
    expect(endpoint.status).toBe('active');
  });

  it('should show notifications', async () => {

    await initializeApp();


    services.storage = {
      getItem: jest.fn(),
      setItem: jest.fn()
    };


    const container = document.querySelector('.notifications-container');


    window.showNotification = (message, type, duration) => {

      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;


      container.appendChild(notification);


      if (duration) {
        setTimeout(() => notification.remove(), duration);
      }

      return notification;
    };


    const notification = window.showNotification('Test notification', 'info', 0);


    expect(container.querySelector('.notification')).not.toBeNull();
    expect(container.querySelector('.notification').textContent).toBe('Test notification');


    notification.remove();
  });
});

================
File: test/spec/rdf-model.spec.js
================
import { RDFModel } from '../../src/js/services/rdf/rdf-model.js';
import rdf from 'rdf-ext';


global.localStorage = {
    getItem: jest.fn(),
    setItem: jest.fn(),
    removeItem: jest.fn(),
    clear: jest.fn()
};


jest.mock('../../src/js/core/state.js', () => ({
    state: {
        update: jest.fn(),
        get: jest.fn()
    }
}));


jest.mock('../../src/js/services/sparql/sparql.js', () => ({
    querySparql: jest.fn().mockResolvedValue({}),
    postToSparql: jest.fn().mockResolvedValue(true)
}));

describe('RDFModel', () => {
    let rdfModel;

    beforeEach(() => {
        jest.clearAllMocks();
        rdfModel = new RDFModel();
    });

    it('should create a post and add it to the dataset', () => {

        const mockDataset = rdf.dataset();
        const mockUpdate = jest.fn();
        rdfModel.saveToCache = jest.fn();


        require('../../src/js/core/state.js').state.get.mockReturnValue(mockDataset);
        require('../../src/js/core/state.js').state.update = mockUpdate;


        const postData = {
            type: 'link',
            title: 'Test Title',
            content: 'Test Content',
            url: 'https://example.com',
            tags: ['test', 'example']
        };


        const postId = rdfModel.createPost(postData);


        expect(postId).toBeDefined();
        expect(mockUpdate).toHaveBeenCalled();
        expect(rdfModel.saveToCache).toHaveBeenCalled();


        const updatedDataset = mockUpdate.mock.calls[0][1];
        expect(updatedDataset.size).toBeGreaterThan(0);


        let titleFound = false;
        let typeFound = false;

        updatedDataset.forEach(quad => {
            if (quad.predicate.value.includes('title')) {
                expect(quad.object.value).toBe('Test Title');
                titleFound = true;
            }
            if (quad.predicate.value.includes('type')) {
                expect(quad.object.value.includes('link')).toBe(true);
                typeFound = true;
            }
        });

        expect(titleFound).toBe(true);
        expect(typeFound).toBe(true);
    });

    it('should get posts filtered by type', () => {

        const mockDataset = rdf.dataset();
        const ns = {
            rdf: rdf.namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#'),
            squirt: rdf.namespace('http://purl.org/stuff/squirt/'),
            dc: rdf.namespace('http://purl.org/dc/terms/')
        };


        const postId = 'http://example.org/post1';
        mockDataset.add(rdf.quad(
            rdf.namedNode(postId),
            ns.rdf('type'),
            ns.squirt('link')
        ));
        mockDataset.add(rdf.quad(
            rdf.namedNode(postId),
            ns.dc('title'),
            rdf.literal('Test Post')
        ));
        mockDataset.add(rdf.quad(
            rdf.namedNode(postId),
            ns.squirt('content'),
            rdf.literal('Test Content')
        ));
        mockDataset.add(rdf.quad(
            rdf.namedNode(postId),
            ns.squirt('tag'),
            rdf.literal('test')
        ));


        require('../../src/js/core/state.js').state.get.mockReturnValue(mockDataset);


        const posts = rdfModel.getPosts({ type: 'link' });


        expect(posts.length).toBe(1);
        expect(posts[0].id).toBe(postId);
        expect(posts[0].title).toBe('Test Post');
        expect(posts[0].content).toBe('Test Content');
        expect(posts[0].tags).toContain('test');
        expect(posts[0].type).toBe('link');
    });

    it('should delete a post from the dataset', () => {

        const mockDataset = rdf.dataset();
        const postId = 'http://example.org/post1';
        const ns = {
            rdf: rdf.namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#'),
            squirt: rdf.namespace('http://purl.org/stuff/squirt/'),
        };

        mockDataset.add(rdf.quad(
            rdf.namedNode(postId),
            ns.rdf('type'),
            ns.squirt('link')
        ));


        const mockUpdate = jest.fn();
        require('../../src/js/core/state.js').state.get.mockReturnValue(mockDataset);
        require('../../src/js/core/state.js').state.update = mockUpdate;
        rdfModel.saveToCache = jest.fn();


        const result = rdfModel.deletePost(postId);


        expect(result).toBe(true);
        expect(mockUpdate).toHaveBeenCalled();
        expect(rdfModel.saveToCache).toHaveBeenCalled();


        const updatedDataset = mockUpdate.mock.calls[0][1];
        expect(updatedDataset.size).toBe(0);
    });
});

================
File: test/spec/refactoring-plan.md
================
# Refactoring Plan for Squirt

## Issues Identified

1. **Circular Dependencies**:
   - State management is tightly coupled with services
   - Components reference each other directly

2. **Inconsistent Error Handling**:
   - Mix of direct console.error and ErrorHandler usage
   - Inconsistent notification of errors to users

3. **Tight UI and Data Coupling**:
   - UI components directly manipulate RDF data model
   - UI state changes mixed with business logic

4. **Mixed Responsibilities**:
   - Some modules handle both data processing and UI rendering
   - Missing clear separation of concerns

5. **Sparse Testing**:
   - Limited unit tests for critical components
   - No integration testing

## Refactoring Strategy

### 1. Create Clear Architecture

```
src/
   core/               # Application core
      config/         # Configuration handling
      state/          # State management
      errors/         # Error handling
   domain/             # Domain logic
      models/         # Data models
      rdf/            # RDF related functionality
      sparql/         # SPARQL related functionality
   ui/                 # User interface
      components/     # Reusable UI components
      views/          # Page views
      forms/          # Form handling
      notifications/  # User notification system
   services/           # External services
      storage/        # Storage service (localstorage, etc.)
      network/        # Network request handling
      endpoints/      # Endpoint management
   utils/              # Utility functions
```

### 2. Break Circular Dependencies

1. **Create a Mediator/Event Bus**
   - Implement a simple pub/sub event system
   - Components communicate through events, not direct references

2. **Dependency Injection**
   - Pass dependencies to modules rather than importing directly
   - Use factory functions to create instances with dependencies

3. **Interface-Based Programming**
   - Define clear interfaces for services
   - Allow for different implementations

### 3. Standardize Error Handling

1. **Create Error Classes Hierarchy**
   - Define specific error types for different scenarios
   - Include appropriate metadata for each error type

2. **Centralized Error Processing**
   - Enhance ErrorHandler to handle all error types consistently
   - Add error event system for components to subscribe to

3. **User-Facing Error Management**
   - Standardize error notification system
   - Improve error recovery options

### 4. Improve Testing Infrastructure

1. **Unit Testing Framework**
   - Complete unit tests for core functionality
   - Mock external dependencies for isolation

2. **Integration Tests**
   - Test component interactions
   - Add end-to-end tests for critical user flows

3. **Test Utilities**
   - Create helpers for common testing tasks
   - Add fixtures for test data

## Specific Modules to Refactor

### State Management

```javascript
// Before: src/js/core/state.js
export class StateManager {
    constructor() {
        this.state = {/* ... */};
        this.listeners = new Map();
    }
    // Methods...
}
export const state = new StateManager();
```

```javascript
// After: src/core/state/index.js
import { createStore } from './store';
import { stateReducer } from './reducer';

export const store = createStore(stateReducer);
export { connect } from './connect';
export * from './actions';
```

### Error Handling

```javascript
// Before: src/js/core/errors.js
export class AppError extends Error {/* ... */}
export const ErrorHandler = {/* ... */};
```

```javascript
// After: src/core/errors/index.js
export * from './error-types';
export * from './error-handler';
export * from './error-boundary';
```

### RDF Model Refactoring

```javascript
// Before: src/js/services/rdf/rdf-model.js
export class RDFModel {
    constructor() {
        // Directly imports and uses state
    }
    // Methods that mix persistence and domain logic
}
export const rdfModel = new RDFModel();
```

```javascript
// After: src/domain/rdf/model.js
export class RDFModel {
    constructor(storage, eventBus) {
        this.storage = storage;
        this.eventBus = eventBus;
    }
    // Pure domain logic methods
}

// src/services/rdf/rdf-service.js
export class RDFService {
    constructor(model, storage, state) {
        this.model = model;
        this.storage = storage;
        this.state = state;
    }
    // Service methods (persistence, etc.)
}
```

## Implementation Strategy

1. **Create Core Infrastructure First**
   - Event system
   - New state management
   - Error handling framework
   
2. **Refactor Domain Models**
   - Separate data structure from operations
   - Create pure functions where possible
   
3. **Refactor Services**
   - Implement service interfaces
   - Break circular dependencies
   
4. **Update UI Components Last**
   - Connect to new state management
   - Use event system for communication

5. **Iterative Testing Throughout**
   - Add tests for each refactored component
   - Ensure original functionality is preserved

## Sample Implementation Timeline

1. **Phase 1 (Foundation)**
   - Set up new folder structure
   - Implement event system
   - Create interfaces for core services
   
2. **Phase 2 (Core Services)**
   - Refactor state management
   - Implement error handling system
   - Update RDF and SPARQL services
   
3. **Phase 3 (UI Layer)**
   - Refactor UI components
   - Update routing
   - Enhance form handling
   
4. **Phase 4 (Testing & Polish)**
   - Complete test coverage
   - Fix edge cases
   - Document new architecture

================
File: test/spec/refactoring-summary.md
================
# Squirt App Refactoring Summary

## Key Improvements

1. **Decoupled Architecture**
   - Created clear layers (core, domain, services, UI)
   - Introduced event bus for communication between components
   - Removed circular dependencies

2. **Improved State Management**
   - Implemented Redux-like central store
   - Added reducers for predictable state updates
   - Created selectors for consistent data access

3. **Enhanced Error Handling**
   - Created error type hierarchy
   - Centralized error processing and logging
   - Added user-friendly error notifications

4. **Modular Services**
   - Extracted storage, SPARQL, RDF, and endpoints into services
   - Implemented interfaces with dependency injection
   - Created factory functions for service instantiation

5. **Better Testing Support**
   - Added comprehensive unit tests
   - Created integration test for application flow
   - Added mocks and testing utilities

## Implementation Details

### New Folder Structure
```
src/
   core/
      events/        # Event bus system
      errors/        # Error types and handler
      state/         # Centralized state management
   domain/
      rdf/           # Core RDF model
   services/
      endpoints/     # Endpoint management
      rdf/           # RDF service implementation
      sparql/        # SPARQL service
      storage/       # Storage abstraction
   ui/
       notifications/ # Notification system
       router.js      # Navigation router
       views/         # View implementations
```

### Core Improvements

1. **Event Bus**
   - Added pub/sub event system
   - Standardized event types with constants
   - Components communicate through events, not direct references

2. **Error Handling**
   - Created AppError base class and specific subtypes
   - Centralized error handler with consistent logging
   - Added user-friendly error notifications

3. **State Management**
   - Implemented Redux-like store and reducers
   - Added action creators for type safety
   - Created selectors for data access

### Service Layer

1. **Storage Service**
   - Created abstract interface for storage
   - Implemented localStorage and in-memory variants
   - Added error handling for storage operations

2. **SPARQL Service**
   - Decoupled SPARQL operations from endpoint management
   - Added proper error handling for network and SPARQL errors
   - Implemented events for query and update lifecycle

3. **Endpoints Service**
   - Separated endpoint management from SPARQL operations
   - Added status monitoring and health checks
   - Implemented event-based status notifications

4. **RDF Service**
   - Split domain model from service implementation
   - Created pure functions for RDF operations
   - Added proper error handling and events

### UI Improvements

1. **Router**
   - Implemented hash-based routing
   - Added view lifecycle management
   - Created event-based navigation system

2. **Notifications**
   - Added centralized notification system
   - Created consistent UI for notifications
   - Implemented state-based rendering

## Testing Improvements

1. **Unit Tests**
   - Added tests for core functionality
   - Created mock implementations for services
   - Improved test coverage for critical components

2. **Integration Tests**
   - Added tests for application lifecycle
   - Tested service interactions
   - Verified event-based communication

## Benefits of Refactoring

1. **Improved Maintainability**
   - Clear separation of concerns
   - Consistent patterns across codebase
   - Better encapsulation of implementation details

2. **Enhanced Testability**
   - Services can be tested in isolation
   - Easy to mock dependencies
   - Better test coverage

3. **Better Error Handling**
   - Specific error types for different scenarios
   - Consistent error logging and reporting
   - User-friendly error messages

4. **Simplified State Management**
   - Predictable state updates
   - Clear data flow
   - Easier debugging

5. **Improved Performance**
   - Reduced unnecessary re-renders
   - Better control over asynchronous operations
   - More efficient event handling

## Next Steps

1. **Complete View Implementations**
   - Refactor remaining UI components
   - Implement remaining views
   - Add component tests

2. **Improve Documentation**
   - Add detailed API documentation
   - Create developer guide
   - Document architecture decisions

3. **Add Feature Enhancements**
   - Implement offline support
   - Add data synchronization
   - Improve UI/UX

================
File: test/spec/sparql.spec.js
================
import { postToSparql, querySparql } from '../../src/js/services/sparql/sparql.js';
import rdf from 'rdf-ext';

describe('SPARQL Operations', () => {
  const testDataset = rdf.dataset();
  const testSubject = rdf.namedNode('http://example.org/test');
  const testPredicate = rdf.namedNode('http://example.org/name');
  const testObject = rdf.literal('Test Entry');

  beforeEach(() => {
    testDataset.add(rdf.quad(testSubject, testPredicate, testObject));
  });

  it('should successfully post data to SPARQL endpoint', async () => {
    try {
      const result = await postToSparql(testDataset);
      expect(result).toBe(true);
    } catch (error) {
      fail('Should not throw error: ' + error.message);
    }
  });

  it('should verify posted data with query', async () => {
    const query = `
      SELECT ?o
      WHERE {
        <http://example.org/test> <http://example.org/name> ?o .
      }
    `;

    try {
      const result = await querySparql(query);
      expect(result.results.bindings.length).toBeGreaterThan(0);
      expect(result.results.bindings[0].o.value).toBe('Test Entry');
    } catch (error) {
      fail('Should not throw error: ' + error.message);
    }
  });

  it('should handle SPARQL syntax errors gracefully', async () => {
    const badQuery = 'SELECT * WHERE { INVALID SYNTAX }';

    try {
      await querySparql(badQuery);
      fail('Should throw error for invalid query');
    } catch (error) {
      expect(error).toBeDefined();
      expect(error.message).toMatch(/SPARQL query failed: 400 Parse error:/);
      expect(error.message).toContain('SELECT * WHERE { INVALID SYNTAX }');
      expect(error.message).toMatch(/Encountered " "in" "IN "" at line 1, column \d+/);
    }
  });

  it('should handle network errors gracefully', async () => {
    const badEndpoint = 'http://nonexistent-endpoint:3030/sparql';

    try {
      await fetch(badEndpoint);
      fail('Should throw error for network failure');
    } catch (error) {
      expect(error).toBeDefined();
      expect(error.message).toContain('fetch failed');
    }
  });

  it('should handle empty dataset gracefully', async () => {
    const emptyDataset = rdf.dataset();
    try {
      const result = await postToSparql(emptyDataset);
      expect(result).toBe(true);
    } catch (error) {
      fail('Should not throw error for empty dataset: ' + error.message);
    }
  });
});

================
File: test/spec/sparql1.spec.js
================
import { postToSparql, querySparql, getEndpoint } from '../../src/js/services/sparql/sparql.js';
import { state } from '../../src/js/core/state.js';
import rdf from 'rdf-ext';


global.fetch = jest.fn();

describe('SPARQL Operations', () => {
  const testDataset = rdf.dataset();
  const testSubject = rdf.namedNode('http://example.org/test');
  const testPredicate = rdf.namedNode('http://example.org/name');
  const testObject = rdf.literal('Test Entry');


  beforeEach(() => {
    testDataset.add(rdf.quad(testSubject, testPredicate, testObject));


    state.update('endpoints', [
      {
        url: 'http://test-query-endpoint:3030/sparql',
        label: 'Test Query Endpoint',
        type: 'query',
        status: 'active'
      },
      {
        url: 'http://test-update-endpoint:3030/sparql',
        label: 'Test Update Endpoint',
        type: 'update',
        status: 'active'
      }
    ]);


    global.fetch.mockReset();
  });

  it('should successfully post data to SPARQL endpoint', async () => {

    global.fetch.mockResolvedValueOnce({
      ok: true,
      status: 200,
      text: async () => 'Success'
    });

    const result = await postToSparql(testDataset);
    expect(result).toBe(true);


    expect(fetch).toHaveBeenCalledTimes(1);
    expect(fetch.mock.calls[0][0]).toBe('http://test-update-endpoint:3030/sparql');
    expect(fetch.mock.calls[0][1].method).toBe('POST');
    expect(fetch.mock.calls[0][1].headers['Content-Type']).toBe('application/sparql-update');
  });

  it('should verify posted data with query', async () => {
    const query = `
      SELECT ?o
      WHERE {
        <http://example.org/test> <http://example.org/name> ?o .
      }
    `;


    global.fetch.mockResolvedValueOnce({
      ok: true,
      status: 200,
      json: async () => ({
        results: {
          bindings: [
            {
              o: {
                type: 'literal',
                value: 'Test Entry'
              }
            }
          ]
        }
      })
    });

    const result = await querySparql(query);
    expect(result.results.bindings.length).toBeGreaterThan(0);
    expect(result.results.bindings[0].o.value).toBe('Test Entry');


    expect(fetch).toHaveBeenCalledTimes(1);
    expect(fetch.mock.calls[0][0]).toBe('http://test-query-endpoint:3030/sparql');
    expect(fetch.mock.calls[0][1].method).toBe('POST');
    expect(fetch.mock.calls[0][1].headers['Content-Type']).toBe('application/sparql-query');
  });

  it('should handle SPARQL syntax errors gracefully', async () => {
    const badQuery = 'SELECT * WHERE { INVALID SYNTAX }';


    global.fetch.mockResolvedValueOnce({
      ok: false,
      status: 400,
      text: async () => 'Parse error: Invalid syntax at line 1'
    });

    try {
      await querySparql(badQuery);
      fail('Should throw error for invalid query');
    } catch (error) {
      expect(error).toBeDefined();
      expect(error.message).toContain('SPARQL query failed: 400');
      expect(error.message).toContain('Parse error:');
    }
  });

  it('should handle network errors gracefully', async () => {
    global.fetch.mockRejectedValueOnce(new Error('Failed to fetch'));

    try {
      await querySparql('SELECT * WHERE { ?s ?p ?o }');
      fail('Should throw error for network failure');
    } catch (error) {
      expect(error).toBeDefined();
    }
  });

  it('should handle empty dataset gracefully', async () => {
    const emptyDataset = rdf.dataset();


    global.fetch.mockResolvedValueOnce({
      ok: true,
      status: 200,
      text: async () => 'Success'
    });

    const result = await postToSparql(emptyDataset);
    expect(result).toBe(true);


    expect(fetch).toHaveBeenCalledTimes(1);
  });
});

================
File: test/setup.js
================
global.fetch = jest.fn();


Object.defineProperty(window, 'location', {
  value: {
    hash: ''
  },
  writable: true
});


console.error = jest.fn();
console.warn = jest.fn();

================
File: .babelrc
================
{
  "presets": [
    ["@babel/preset-env", {
      "targets": {
        "node": "current"
      }
    }]
  ],
  "plugins": [
    "@babel/plugin-transform-modules-commonjs"
  ]
}

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

================
File: about.md
================
```sh
cd ~/hyperdata/squirt

npm run build
npm run dev

npm run rp

```

================
File: babel.config.json
================
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "browsers": [
            "last 2 chrome versions",
            "last 2 firefox versions",
            "last 2 safari versions"
          ]
        },
        "modules": false,
        "useBuiltIns": "usage",
        "corejs": 3
      }
    ]
  ]
}

================
File: jasmine.json
================
{
    "spec_dir": "test",
    "spec_files": [
        "**/*[sS]pec.js"
    ],
    "helpers": [],
    "stopSpecOnExpectationFailure": true,
    "random": false
}

================
File: jest.config.js
================
module.exports = {
  transform: {
    '^.+\\.(js|jsx)$': 'babel-jest'
  },
  testEnvironment: 'jsdom',
  moduleFileExtensions: ['js', 'json'],
  transformIgnorePatterns: ['/node_modules/(?!(@rdfjs|rdf-ext)/)'],
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1'
  },
  testMatch: ['**/test/spec/**/*.spec.js'],
  setupFiles: ['./test/setup.js']
};

================
File: LICENSE
================
MIT License

Copyright (c) 2025 Danny Ayers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "squirt",
  "version": "0.1.0",
  "type": "commonjs",
  "scripts": {
    "build": "webpack --mode production",
    "dev": "webpack serve --mode development",
    "test": "jest",
    "test:jasmine": "jasmine --config=jasmine.json",
    "rp": "tree --gitignore  -I 'knowledge|prompts|reference' > tree.xml && repomix -c repomix.config.json ."
  },
  "dependencies": {
    "@rdfjs/data-model": "^2.0.1",
    "@rdfjs/namespace": "^2.0.0",
    "@rdfjs/parser-n3": "^2.0.1",
    "@triply/yasgui": "^4.2.28",
    "codemirror": "^5.65.12",
    "cors": "^2.8.5",
    "marked": "^4.3.0",
    "rdf-ext": "^2.5.0"
  },
  "devDependencies": {
    "@babel/core": "^7.26.0",
    "@babel/plugin-transform-modules-commonjs": "^7.26.3",
    "@babel/preset-env": "^7.26.0",
    "babel-jest": "^29.7.0",
    "babel-loader": "^9.2.1",
    "chai": "^4.3.10",
    "css-loader": "^6.11.0",
    "file-loader": "^6.2.0",
    "html-webpack-plugin": "^5.6.0",
    "jasmine": "^5.1.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "mini-css-extract-plugin": "^2.9.2",
    "style-loader": "^3.3.4",
    "url-loader": "^4.1.1",
    "webpack": "^5.89.0",
    "webpack-cli": "^5.1.4",
    "webpack-dev-server": "^4.15.2"
  }
}

================
File: README.md
================
# squirt
UI client

================
File: tree.xml
================
.
 about.md
 babel.config.json
 jasmine.json
 jest.config.js
 LICENSE
 _notes
  architecture-required_2025-04-06.md
  requirements_2025-04-06.md
  _trellis.ttl
 package.json
 package-lock.json
 public
  favicon.ico
  index.html
  main.7aef7464.css
  main.bundle.js
 README.md
 repomix.config.json
 squirt_repomix.md
 src
  app.js
  config.json
  core
   errors
    error-handler.js
    error-types.js
    index.js
   errors.js
   events
    event-bus.js
    event-constants.js
   plugin-base.js
   plugin-manager.js
   state
    index.js
    store.js
   state.js
   views.js
  css
   form-styles.css
   layout-fixes.css
   mobile-fixes.css
   plugin-styles.css
   styles.css
   yasgui-styles.css
  domain
   rdf
       model.js
  html
   index.html
  plugins
   index.js
   wiki-plugin.js
   yasgui-plugin.js
  services
   endpoints
    endpoints-service.js
   rdf
    rdf-extractor.js
    rdf-model.js
   sparql
    endpoints.js
    sparql.js
    sparql-service.js
   storage
    storage-service.js
   templates
       post-article.njk
  ui
   components
    endpoint-indicator.js
    endpoints-list.js
    forms.js
    notifications.js
   notifications
    notifications.js
    router.js
   router.js
   views
       settings-view.js
       wiki-view.js
       yasgui-view.js
  utils
      namespaces.js
      utils.js
 test
  setup.js
  spec
      about.md
      enpoints.spec.js
      integration-test.js
      rdf-model.spec.js
      refactoring-plan.md
      refactoring-summary.md
      sparql1.spec.js
      sparql.spec.js
 tree.xml
 webpack.config.js

26 directories, 73 files

================
File: webpack.config.js
================
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
    entry: {
        main: './src/app.js'
    },
    output: {
        path: path.resolve('public'),
        filename: '[name].bundle.js',
        clean: true
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules\/(?!@triply).*/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['@babel/preset-env']
                    }
                }
            },
            {
                test: /\.css$/,
                use: [
                    MiniCssExtractPlugin.loader,
                    'css-loader'
                ]
            },
            {
                test: /\.(woff|woff2|eot|ttf|otf)$/i,
                type: 'asset/resource',
                generator: {
                    filename: 'fonts/[name].[hash:8][ext]'
                }
            },
            {
                test: /\.(png|jpg|jpeg|gif|svg)$/i,
                type: 'asset/resource',
                generator: {
                    filename: 'images/[name].[hash:8][ext]'
                }
            }
        ]
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './src/html/index.html',
            favicon: './public/favicon.ico',
            minify: false
        }),
        new MiniCssExtractPlugin({
            filename: '[name].[contenthash:8].css'
        })
    ],
    resolve: {
        extensions: ['.js', '.json'],
        alias: {

            '@triply/yasgui$': path.resolve(__dirname, 'node_modules/@triply/yasgui/build/yasgui.min.js'),
            '@': path.resolve(__dirname, 'src')
        }
    },
    devServer: {
        static: {
            directory: path.join(process.cwd(), 'public')
        },
        compress: true,
        hot: true,
        port: 9002
    },
    optimization: {
        minimize: false
    }
}
